<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RotationMatrix</title>
    <url>/2019/06/25/RotationMatrix/</url>
    <content><![CDATA[<h1 id="使用矩阵表示“旋转、平移、缩放”"><a href="#使用矩阵表示“旋转、平移、缩放”" class="headerlink" title="使用矩阵表示“旋转、平移、缩放”"></a>使用矩阵表示“旋转、平移、缩放”</h1><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>仿射变换，又称仿射映射，是指在几何中，一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间。<br><a id="more"></a></p>
<p>仿射变换是在几何上定义为两个向量空间之间的一个仿射变换或者仿射映射（来自拉丁语，affine，“和…相关”）由一个非奇异的线性变换(运用一次函数进行的变换)接上一个平移变换组成。</p>
<p>在有限维的情况，每个仿射变换可以由一个矩阵A和一个向量b给出，它可以写作A和一个附加的列b。一个仿射变换对应于一个矩阵和一个向量的乘法，而仿射变换的复合对应于普通的矩阵乘法，只要加入一个额外的行到矩阵的底下，这一行全部是0除了最右边是一个1，而列向量的底下要加上一个1。</p>
<h2 id="二维旋转变换"><a href="#二维旋转变换" class="headerlink" title="二维旋转变换"></a>二维旋转变换</h2><h3 id="原点"><a href="#原点" class="headerlink" title="原点"></a>原点</h3><p>首先要明白，在二维空间中，<code>旋转</code>指绕着某一个点旋转；而在三维空间中，<code>旋转</code>指绕着某一个轴。</p>
<p>那么最简单直观的就是绕着原点旋转：</p>
<p><img src="/2019/06/25/RotationMatrix/71080-20171116101008734-1171446672.png" alt="img"></p>
<p>如图所示点v 绕 原点旋转<em>θ</em> 角，得到点v’，假设 v点的坐标是(x, y) ，那么可以推导得到 v’点的坐标（x’, y’)</p>
<script type="math/tex; mode=display">
\begin{array}{}
设原点到v的距离是r，原点到v点的向量与x轴的夹角是\phi \\
\because
\begin{array}{}
x = rcos\phi,\\
y = rsin\phi,\\
x' = rcos(\phi + \theta),\\
y' = rsin(\phi + \theta),\\
\end{array}\\
\\
\therefore
\begin{array}{}
对x'和y'使用两角和公式展开：\\
x' = rcos\theta cos\phi − rsin\theta sin\phi \\
y' = rsin\theta cos\phi + rcos\theta sin\phi \\
\end{array}\\
\\
\therefore
\begin{array}{}
对x和y的等式带入得：\\
x' = xcos\theta − ysin\theta \\
y' = xsin\theta + ycos\theta \\
\end{array}\\
\\令v = \left[
\begin{array}{}
x\\
y
\end{array}
\right]

那么v'可以使用矩阵表示为：\\
v' = \left[
\begin{array}{}
x'\\
y'
\end{array}
\right]
=
\left[
\begin{array}{cc}
cos\theta & -sin\theta\\
sin\theta & cos\theta\\
\end{array}
\right]
*
\left[
\begin{array}{}
x\\
y
\end{array}
\right]
\end{array}</script><p>由于使用的是三角恒等式，因此将结论推广到钝角乃至更大的角度也依然成立。</p>
<h3 id="任意点"><a href="#任意点" class="headerlink" title="任意点"></a>任意点</h3><p>想象一下，一个向量（图形）在二维空间中旋转，实际上可以看作进行了<code>相对于原点的旋转</code>和<code>相对于原点的平移</code>两个行为。</p>
<p>那么，现在x’和y’的表达式就变成如下情况：</p>
<script type="math/tex; mode=display">
\begin{array}{}
x' = xcos\theta − ysin\theta +tx \\
y' = xsin\theta + ycos\theta +ty \\
\end{array}\\</script><p>那么很明显，现在x’和y’是由三个量决定的，因此将矩阵从两列扩展到三列：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{}
x'\\
y'\\
1
\end{array}
\right]
=
\left[
\begin{array}{ccc}
cos\theta & -sin\theta & tx\\
sin\theta & cos\theta & ty\\
0&0&1
\end{array}
\right]
*
\left[
\begin{array}{}
x\\
y\\
1
\end{array}
\right]</script><p>特别的，当没有发生变换时：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{}
x'\\
y'\\
1
\end{array}
\right]
=
\left[
\begin{array}{ccc}
1 & 0 & 0\\
0 & 1 & 0\\
0&0&1
\end{array}
\right]
*
\left[
\begin{array}{}
x\\
y\\
1
\end{array}
\right]</script><h2 id="三维旋转变换"><a href="#三维旋转变换" class="headerlink" title="三维旋转变换"></a>三维旋转变换</h2><h3 id="绕x轴旋转"><a href="#绕x轴旋转" class="headerlink" title="绕x轴旋转"></a>绕x轴旋转</h3><p>YOZ平面刚好发生二维旋转：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{}
x'\\
y'\\
z'\\
1
\end{array}
\right]
=
\left[
\begin{array}{c}
1 & 0 & 0 & 0\\
0 & cos\theta & -sin\theta & 0\\
0 & sin\theta & cos\theta & 0 \\
0&0&0&1
\end{array}
\right]
*
\left[
\begin{array}{}
x\\
y\\
z\\
1
\end{array}
\right]</script><h3 id="绕y轴旋转"><a href="#绕y轴旋转" class="headerlink" title="绕y轴旋转"></a>绕y轴旋转</h3><p>XOZ平面刚好发生二维旋转：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{}
x'\\
y'\\
z'\\
1
\end{array}
\right]
=
\left[
\begin{array}{c}
cos\theta & 0 & -sin\theta & 0\\
0 & 1 & 0 & 0\\
sin\theta & 0 & cos\theta & 0 \\
0&0&0&1
\end{array}
\right]
*
\left[
\begin{array}{}
x\\
y\\
z\\
1
\end{array}
\right]</script><h3 id="绕z轴旋转"><a href="#绕z轴旋转" class="headerlink" title="绕z轴旋转"></a>绕z轴旋转</h3><p>XOY平面刚好发生二维旋转：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{}
x'\\
y'\\
z'\\
1
\end{array}
\right]
=
\left[
\begin{array}{c}
cos\theta & -sin\theta & 0 & 0\\
sin\theta & cos\theta & 0 & 0\\
0 & 0 & 1 & 0 \\
0&0&0&1
\end{array}
\right]
*
\left[
\begin{array}{}
x\\
y\\
z\\
1
\end{array}
\right]</script><h2 id="旋转矩阵-in-Swift"><a href="#旋转矩阵-in-Swift" class="headerlink" title="旋转矩阵 in Swift"></a>旋转矩阵 in Swift</h2><p>在playground中键入并执行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">var</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">node.position = <span class="type">SCNVector3</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"node.position"</span>)</span><br><span class="line"><span class="built_in">print</span>(node.position)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"node.simdTransform"</span>)</span><br><span class="line"><span class="built_in">print</span>(node.simdTransform)</span><br></pre></td></tr></table></figure>
<p>你将会在终端看到：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">node.simdTransform</span><br><span class="line">simd_float4x4([[<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>], [<span class="number">4.0</span>, <span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>]])</span><br></pre></td></tr></table></figure>
<p>这里的<code>simd_float4x4</code>就是旋转矩阵，它描述了节点<code>node</code>在它的父节点空间里的位置信息。</p>
<p>将上述信息转换成矩阵的形式可得：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{}
1.0 & 0.0 & 0.0 & 4.0\\
0.0 & 1.0 & 0.0 & 3.0\\
0.0 & 0.0 & 1.0 & 2.0\\
0.0 & 0.0 & 0.0 & 1.0\\
\end{array}
\right]</script><h2 id="三维信息-in-swift"><a href="#三维信息-in-swift" class="headerlink" title="三维信息 in swift"></a>三维信息 in swift</h2><p>对于如下一个节点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SceneKit</span><br><span class="line"><span class="keyword">var</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">node.position = <span class="type">SCNVector3</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>在终端获取它的位置(position)、旋转（rotation）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"node.position"</span>)</span><br><span class="line"><span class="built_in">print</span>(node.position)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"node.rotation"</span>)</span><br><span class="line"><span class="built_in">print</span>(node.rotation)</span><br></pre></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">node.position</span><br><span class="line"><span class="type">SCNVector3</span>(x: <span class="number">4.0</span>, y: <span class="number">3.0</span>, z: <span class="number">2.0</span>)</span><br><span class="line">node.rotation</span><br><span class="line"><span class="type">SCNVector4</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, z: <span class="number">0.0</span>, w: <span class="number">0.0</span>)</span><br><span class="line"><span class="comment">//四分量旋转矢量指定前三个分量中的旋转轴的方向和第四个中的旋转角度（以弧度表示）。</span></span><br></pre></td></tr></table></figure>
<h3 id="orientation"><a href="#orientation" class="headerlink" title="orientation"></a>orientation</h3><p>节点的方向，表示为四元数。</p>
<p>四元数是用于描述三维空间中的旋转的数学构造。 虽然它的实现与4分量矢量的实现不同，但您可以使用与SCNVector4结构相同的字段指定四元数值。</p>
<p>SceneKit使用单位四元数（其组件满足方程x <em> x + y </em> y + z <em> z + w </em> w == 1）用于节点的方向属性。</p>
<h3 id="eulerAngles"><a href="#eulerAngles" class="headerlink" title="eulerAngles"></a>eulerAngles</h3><p>节点的方向，以弧度表示为俯仰，偏航和滚转角度。</p>
<p>此向量中的组件顺序与旋转轴匹配：</p>
<ul>
<li><p>Pitch（x分量）是围绕节点x轴的旋转。</p>
</li>
<li><p>Yaw（y分量）是绕节点y轴的旋转。</p>
</li>
<li><p>Roll（z分量）是绕节点z轴的旋转。</p>
</li>
</ul>
<blockquote>
<p>SceneKit以与组件相反的顺序相对于节点的pivot属性应用这些旋转：首先滚动，然后是偏航，然后是俯仰。 rotation，eulerAngles和orientation属性都会影响节点转换属性的旋转方面。 对其中一个属性的任何更改都会反映在其他属性中。</p>
</blockquote>
<h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><p>用于选择形状的比例因子相对于包含它的节点的局部坐标空间的选项。</p>
<p>此键的值是包含SCNVector3结构的NSValue对象，其组件描述x轴，y轴和z轴方向中的每个方向的比例因子。 默认值为向量{1.0,1.0,1.0}，指定不更改比例。</p>
<blockquote>
<p>在模拟碰撞时，SceneKit的物理模拟忽略包含物理实体的节点的比例属性。 相反，使用此选项可在创建自定义物理形状时提供比例因子。 （如果为节点创建物理主体而未指定自定义形状，则SceneKit会使用节点的scale属性在创建时推断此比例因子。）</p>
</blockquote>
<h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><p>单指令流多数据流（英语：Single Instruction Multiple Data，缩写：SIMD）是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserVector</span><span class="params">(<span class="keyword">in</span> frame: ARFrame?)</span></span> -&gt; (direction: <span class="type">SCNVector3</span>, position: <span class="type">SCNVector3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = frame &#123;</span><br><span class="line">        <span class="keyword">let</span> mat = <span class="type">SCNMatrix4</span>(frame!.camera.transform)</span><br><span class="line">        <span class="keyword">let</span> direction = <span class="type">SCNVector3</span>(-mat.m31, -mat.m32, -mat.m33)</span><br><span class="line">        <span class="keyword">let</span> position = <span class="type">SCNVector3</span>(mat.m41, mat.m42, mat.m43)</span><br><span class="line">        <span class="keyword">return</span> (direction, position)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (.zero, .zero)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>Swift</tag>
        <tag>SceneKit</tag>
      </tags>
  </entry>
  <entry>
    <title>SCNMaterial</title>
    <url>/2018/12/10/SCNMaterial/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当创建一个材质时，定义了一组可视化属性和它们的选项，然后您可以将它们用于场景中的多个几何图形。<br>一个材质有几个视觉属性，每个属性都定义了SceneKit光照和阴影处理的不同部分。每个可视化属性都是SCNMaterialProperty类的一个实例，该类为SceneKit的呈现提供了一个纯色、纹理或其他2D内容。然后，材质的lightingModel属性确定SceneKit用于将视觉属性与场景中的灯光组合在一起的公式，从而为渲染场景中的每个像素生成最终颜色。有关呈现过程的更多细节，请参见SCNMaterial.LightingModel。<br>使用SCNGeometry类的firstMaterial或materials属性将一个或多个材料附加到它的实例。多个几何图形可以引用相同的材料。在这种情况下，改变材质的属性会改变使用它的每个几何图形的外观。</p>
<blockquote>
<p>内容均翻译自 <a href="https://developer.apple.com/documentation" target="_blank" rel="noopener">apple developer documentation</a></p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="SCNMaterial"><a href="#SCNMaterial" class="headerlink" title="SCNMaterial"></a>SCNMaterial</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SCNMaterial</span> : <span class="title">NSObject</span></span></span><br></pre></td></tr></table></figure>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(mdlMaterial: <span class="type">MDLMaterial</span>)</span><br></pre></td></tr></table></figure>
<p>always:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="type">SCNMaterial</span>()</span><br></pre></td></tr></table></figure>
<h2 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h2><ul>
<li>Creating a Material</li>
<li>init(mdlMaterial: MDLMaterial)</li>
<li>var name: String?</li>
<li>Choosing a Shading Model</li>
<li>var lightingModel: SCNMaterial.LightingModel</li>
<li>struct SCNMaterial.LightingModel</li>
<li>Visual Properties for Physically Based Shading</li>
<li>var diffuse: SCNMaterialProperty</li>
<li>var metalness: SCNMaterialProperty</li>
<li>var roughness: SCNMaterialProperty</li>
<li>Visual Properties for Special Effects</li>
<li>var normal: SCNMaterialProperty</li>
<li>var displacement: SCNMaterialProperty</li>
<li>var emission: SCNMaterialProperty</li>
<li>var selfIllumination: SCNMaterialProperty</li>
<li>var ambientOcclusion: SCNMaterialProperty</li>
<li>Visual Properties for Basic Shading</li>
<li>var diffuse: SCNMaterialProperty</li>
<li>var ambient: SCNMaterialProperty</li>
<li>var specular: SCNMaterialProperty</li>
<li>var reflective: SCNMaterialProperty</li>
<li>var multiply: SCNMaterialProperty</li>
<li>var transparent: SCNMaterialProperty</li>
<li>var shininess: CGFloat</li>
<li>var fresnelExponent: CGFloat</li>
<li>var locksAmbientWithDiffuse: Bool</li>
<li>Managing Opacity and Blending</li>
<li>var transparency: CGFloat</li>
<li>var transparencyMode: SCNTransparencyMode</li>
<li>enum SCNTransparencyMode</li>
<li>var blendMode: SCNBlendMode</li>
<li>enum SCNBlendMode</li>
<li>Customizing Rendered Appearance</li>
<li>var isLitPerPixel: Bool</li>
<li>var isDoubleSided: Bool</li>
<li>var cullMode: SCNCullMode</li>
<li>enum SCNCullMode</li>
<li>var fillMode: SCNFillMode</li>
<li>enum SCNFillMode</li>
<li>Managing Render Targets</li>
<li>var writesToDepthBuffer: Bool</li>
<li>var readsFromDepthBuffer: Bool</li>
<li>var colorBufferWriteMask: SCNColorMask</li>
<li>struct SCNColorMask</li>
</ul>
<hr>
<h1 id="Lighting-models"><a href="#Lighting-models" class="headerlink" title="Lighting models"></a>Lighting models</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lightingModel: <span class="type">SCNMaterial</span>.<span class="type">LightingModel</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>材质的lightingModel属性决定了SceneKit使用的公式，该公式将其漫反射颜色和其他视觉属性与场景中的灯光和其他内容结合在一起，从而为渲染场景中的每个渲染像素生成最终颜色。</p>
<h2 id="材质的光照模型类型"><a href="#材质的光照模型类型" class="headerlink" title="材质的光照模型类型"></a>材质的光照模型类型</h2><p><img src="/2018/12/10/SCNMaterial/ae0a5ad4-c04c-4eac-8491-8a8ec311407a.png" alt="img"></p>
<ul>
<li>constant：Uniform shading that incorporates ambient lighting only.</li>
<li>均衡（扁平化）的阴影，在渲染时只计算（包含）ambient信息</li>
<li>lambert：Shading that incorporates ambient and diffuse properties only.</li>
<li>在渲染时只计算（包含）ambient信息和diffuse信息</li>
<li>blinn：Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Blinn-Phong formula.</li>
<li>在渲染时只计算（包含）ambient信息、diffuse信息、specular信息，而且specular高光区是用Blinn-Phong法则计算的</li>
<li>phong：Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Phong formula.</li>
<li>在渲染时只计算（包含）ambient信息、diffuse信息、specular信息，而且specular高光区是用Phong法则计算的</li>
<li>physicallyBases：Shading based on a realistic abstraction of physical lights and materials.</li>
<li>基于物理光和材料的现实抽象的阴影，包含了真实情况下,物理光源和材质对光的漫反射和吸收</li>
</ul>
<hr>
<h1 id="物理纹理的可视化属性"><a href="#物理纹理的可视化属性" class="headerlink" title="物理纹理的可视化属性"></a>物理纹理的可视化属性</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p> Visual Properties for Physically Based Shading</p>
</blockquote>
<p>总共包含三个属性：</p>
<ul>
<li>diffuse：An object that manages the material’s diffuse response to lighting.</li>
<li>用于控制材料对光线漫反射的反映（纯物理状态下的属性或直接物理属性）</li>
<li>metalness：An object that provides color values to determine how metallic the material’s surface appears.</li>
<li>根据颜色值来决定材料表面金属化（反光）程度</li>
<li>roughness：An object that provides color values to determine the apparent smoothness of the surface.</li>
<li>根据颜色值来决定材料表面光洁（凹凸）程度</li>
</ul>
<h2 id="diffuse（漫反射）"><a href="#diffuse（漫反射）" class="headerlink" title="diffuse（漫反射）"></a>diffuse（漫反射）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> diffuse: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/10/SCNMaterial/60d7b841-ae16-40ce-a2ab-79ab36b438b7.png" alt="img"></p>
<p>漫反射阴影描述的是从材料表面每个点均匀反射到各个方向的光的数量和颜色。像素的漫反射颜色与视点无关，因此它可以被看作是一种材料的“基色”或纹理。</p>
<h2 id="metalness（金属性-反光-贴图）"><a href="#metalness（金属性-反光-贴图）" class="headerlink" title="metalness（金属性(反光)贴图）"></a>metalness（金属性(反光)贴图）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> metalness: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>此属性仅度量颜色值的总强度;纹理内容最好用灰度来定义。</p>
<p>这种性质通常近似于物理表面的某些方面，如折射率、产生锐反射的倾向、以及在掠掠角产生菲涅尔反射的倾向，这些因素共同产生了整体的金属或非金属(也称为介质)外观。较低的数值(较深的颜色)会使材料看起来更像介质表面。较高的数值(较亮的颜色)会使表面看起来更金属。</p>
<h2 id="roughness（光洁程度）"><a href="#roughness（光洁程度）" class="headerlink" title="roughness（光洁程度）"></a>roughness（光洁程度）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> roughness: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>此属性仅度量颜色值的总强度;纹理内容最好用灰度来定义。</p>
<p>这个特性近似于表面的微观细节——例如微小的碰撞和裂纹。通过将这些“微面”近似为单个术语，该特性有助于生成类似于真实物理中的能量守恒定律的照明计算，从而在哑光和闪亮表面之间产生更真实的变化。</p>
<p>较低的数值(较深的颜色)会使材料呈现光泽，并带有清晰的高光。较高的值(较亮的颜色)会导致高光发散，而材料的漫反射颜色会变得更加反射。</p>
<hr>
<h1 id="特殊效果的可视化属性"><a href="#特殊效果的可视化属性" class="headerlink" title="特殊效果的可视化属性"></a>特殊效果的可视化属性</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Visual Properties for Special Effects</p>
</blockquote>
<p>总共包含五个属性：</p>
<ul>
<li>var normal: SCNMaterialProperty</li>
<li>An object that defines the nominal orientation of the surface at each point for use in lighting.</li>
<li>var displacement: SCNMaterialProperty</li>
<li>var emission: SCNMaterialProperty</li>
<li>An object that defines the color emitted by each point on a surface.</li>
<li>var selfIllumination: SCNMaterialProperty</li>
<li>An object that provides color values representing the global illumination of the surface.</li>
<li>var ambientOcclusion: SCNMaterialProperty</li>
<li>An object that provides color values to be multiplied with the ambient light affecting the material.</li>
</ul>
<h2 id="normal"><a href="#normal" class="headerlink" title="normal"></a>normal</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> normal: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>要模拟光与材料的相互作用，就需要了解每一点表面的方向。通常，由几何对象提供的法向量提供此信息。然而，这限制了表面轮廓的细节级别，因为一个几何结构只能为每个顶点提供一个唯一的表面法向量(增加顶点数量来建模一个非常详细的表面需要很高的性能成本)。</p>
<p>或者，您可以使用纹理图像作为法线映射，它描述纹理中每个像素的表面方向。当SceneKit使用图像时，它将每个图像的R、G和B分量视为曲面法向量的X、Y和Z分量。因为法线贴图纹理可以存储比几何图形更详细的表面信息，所以您可以使用材料的法线属性来模拟粗糙的表面，例如石头，或者在光滑的表面添加浮雕或雕刻设计。</p>
<p>默认情况下，normal属性的contents对象是白色的。将normal属性的内容设置为任何纯色都会禁用normal映射，导致SceneKit仅使用几何图形提供的表面normal信息对材料进行阴影处理。将normal属性的内容设置为图像或其他纹理映射内容将启用normal映射，这也将自动将材质的isLitPerPixel属性设置为true。</p>
<p>下图显示了在其他属性具有默认内容的材质上将normal属性的内容设置为纹理图像的效果。</p>
<p><img src="/2018/12/10/SCNMaterial/9192ade0-d6ec-46b9-aa52-0988d3f02a88.png" alt="img"></p>
<h2 id="displacement"><a href="#displacement" class="headerlink" title="displacement"></a>displacement</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> displacement: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="emission"><a href="#emission" class="headerlink" title="emission"></a>emission</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emission: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用发射贴图(emissive map)纹理来模拟表面的部分，这些部分会发光。SceneKit并不将材料视为光源——相反，发射特性决定了独立于照明的材料的颜色。(为了创建一个发光的对象，你可能希望结合一个几何图形，发射地图和额外的SCNLight对象添加到场景。)</p>
<p>默认情况下，emissive属性的contents对象是黑色的，这导致属性没有可见效果。将发射属性的内容设置为任何一种纯色，都会为材料添加一种不依赖于灯光的统一颜色。要创建选择性辉光效果，请将属性的内容设置为图像或其他纹理映射内容，其发光区域使用明亮的颜色，其他区域使用较暗的颜色。在发射贴图(emissive map)的深色部分(以及不透明度降低的部分)中，材质的其他视觉属性有助于它在场景照明下的外观。</p>
<p>下图显示了一个材质(带有纹理作为漫反射(diffuse)属性)在提供一个发射地图(emissive map)图像之前和之后。</p>
<p><img src="/2018/12/10/SCNMaterial/b3a74868-b2ba-4e74-92b0-dfd314c22aeb.png" alt="img"></p>
<h2 id="selfIllumination"><a href="#selfIllumination" class="headerlink" title="selfIllumination"></a>selfIllumination</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selfIllumination: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>自照明适用于所有材料，但对于那些使用基于物理的阴影的材料尤其有用(参见physicallyBased)。基于物理的材料最适合于基于环境的照明(请参阅SCNScene属性lightingEnvironment)，但是对于某些材料来说，让一个表面本身定义它的部分照明是有用的——例如，一个物体的位置从提供主要照明环境的“天空”中模糊了它。当您为这个属性指定内容时，它们覆盖了环境照明对漫反射阴影的贡献，但是环境照明仍然对高光效果有贡献。</p>
<h2 id="ambientOcclusion"><a href="#ambientOcclusion" class="headerlink" title="ambientOcclusion"></a>ambientOcclusion</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ambientOcclusion: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>使用此属性可将环境遮挡纹理映射指定到表面。如果场景中没有环境光，则此属性无效。如果该属性不是nil, SceneKit将忽略ambient属性。</p>
<p>当使用基于物理的阴影时(参见physicallyBased)，环境遮挡近似于掩盖全局光照的大规模表面细节。</p>
<hr>
<h1 id="基础纹理的可视化属性"><a href="#基础纹理的可视化属性" class="headerlink" title="基础纹理的可视化属性"></a>基础纹理的可视化属性</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Visual Properties for Basic Shading</p>
</blockquote>
<p>总共包含九个属性：</p>
<ul>
<li>var diffuse: SCNMaterialProperty</li>
<li>An object that manages the material’s diffuse response to lighting.</li>
<li>var ambient: SCNMaterialProperty</li>
<li>An object that manages the material’s response to ambient lighting.</li>
<li>var specular: SCNMaterialProperty</li>
<li>An object that manages the material’s specular response to lighting.</li>
<li>var reflective: SCNMaterialProperty</li>
<li>An object that defines the reflected color for each point on a surface.</li>
<li>var multiply: SCNMaterialProperty</li>
<li>An object that provides color values that are multiplied with pixels in a material after all other shading is complete.</li>
<li>var transparent: SCNMaterialProperty</li>
<li>An object that determines the opacity of each point in a material.</li>
<li>var shininess: CGFloat</li>
<li>The sharpness of specular highlights. Animatable.</li>
<li>var fresnelExponent: CGFloat</li>
<li>A factor affecting the material’s reflectivity. Animatable.</li>
<li>var locksAmbientWithDiffuse: Bool</li>
<li>A Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.</li>
</ul>
<h2 id="diffuse"><a href="#diffuse" class="headerlink" title="diffuse"></a>diffuse</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> diffuse: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/10/SCNMaterial/60d7b841-ae16-40ce-a2ab-79ab36b438b7.png" alt="img"></p>
<p>漫反射阴影描述的是从材料表面每个点均匀反射到各个方向的光的数量和颜色。像素的漫反射颜色与视点无关，因此它可以被看作是一种材料的“基色”或纹理。</p>
<h2 id="ambient"><a href="#ambient" class="headerlink" title="ambient"></a>ambient</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ambient: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>环境阴影(Ambient shading)描述材料反射的环境光的数量和颜色。在一个表面上的所有点上，环境阴影在所有方向上都是均匀的。如果一个场景不包含周围环境类型的灯光，这个属性对材质的外观没有影响。</p>
<p>默认情况下，ambient属性的contents对象是深灰色的。更改ambient属性的内容可以为场景中没有被灯光直接照亮的区域指定不同的颜色或纹理。为了使材料对环境光和漫射光的响应一致，将其locksambientwith漫射属性设置为true。</p>
<p>下图显示了在将环境属性的内容设置为纯色之前和之后的材质(带有纹理作为漫反射(diffuse)属性)。</p>
<p><img src="/2018/12/10/SCNMaterial/d4124591-7d69-44c2-bbc2-061fda9565a5.png" alt="img"></p>
<p>材质的lightingModel属性决定了SceneKit用于将其环境颜色和其他视觉属性与场景中的灯光和其他内容组合在一起的公式，从而为场景中的每个呈现像素生成最终颜色。有关详细信息，请参见照明模型。</p>
<p>此材料属性不适用于基于物理的材料(请参见physicallyBased)。</p>
<h2 id="specular"><a href="#specular" class="headerlink" title="specular"></a>specular</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> specular: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>高光材质(Specular shading)描述的是材料直接反射到观看者身上的光的数量和颜色，在表面形成一个明亮的高光，并模拟光滑或有光泽的外观。您可以使用材质的光泽属性来调整高光的锐度。</p>
<p>默认情况下，高光(specular)属性的内容对象是黑色的，这将导致材质看起来暗淡无光。改变高光(specular)属性的内容到一个更亮的颜色导致高光(specular)高亮出现在那个颜色，使表面看起来闪亮。当你对高光(specular)属性应用纹理时，纹理图像就变成了高光贴图(specular map)——图像中每个像素的亮度决定了材料表面每个点在被光照时产生高光的趋势。</p>
<p>下图显示了材质(带有纹理作为漫反射(diffuse)属性)在提供高光贴图图像之前和之后的效果。请注意，明亮的高光只出现在高光贴图(specular map)图像为白色的部分表面。</p>
<p><img src="/2018/12/10/SCNMaterial/b209fa42-9bf8-4a77-90e1-e7c5f79f4224.png" alt="img"></p>
<p>此材料属性不适用于基于物理的材料(请参见 physicallyBased)。</p>
<h2 id="reflective"><a href="#reflective" class="headerlink" title="reflective"></a>reflective</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reflective: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>您可以通过使表面反射其环境来模拟镜像或镀铬处理。SceneKit不呈现场景中对象的实时反射，但它可以使用环境映射纹理来模拟静态或动画图像的反射。当渲染表面上的每个像素时，SceneKit将光线从该点跟踪到环境映射中的一个像素，就像表面反射了该图像一样。</p>
<p>默认情况下，反射(reflective)属性的contents对象是白色的，这导致属性没有可见效果。将反射(reflective)属性的内容设置为任何纯色都会为材质添加均匀的阴影。要创建反射(reflective)效果，请将属性的内容设置为图像或其他纹理映射内容。</p>
<p>要使用环境映射产生镜像效果，纹理图像应该采用以下两种形式之一:<br>一个球面图，一个正方形的图像，其内容描述了一个被镜像球面反射的环境。<br>一个立方体映射，由六个正方形图像组成的阵列，它们共同构成一个包围场景的假想立方体，其内部表面被材质反射。您可以通过将反射属性的contents对象设置为一个包含6张图像的NSArray实例来创建一个多维数据集映射，每个图像按照以下顺序对应场景世界坐标空间中的一个方向:+X、-X、+Y、-Y、+Z、-Z(或右、左、上、下、近、远)。</p>
<p>下图显示了在为反射(reflective)属性提供立方体映射之前和之后的材质(带有纹理作为其普通(normal)属性)。</p>
<p><img src="/2018/12/10/SCNMaterial/194a1b48-1c03-4a10-9c6a-3c6c8665448a.png" alt="img"></p>
<p>此材料属性不适用于基于物理的材料(请参见physicallyBased)。相反，这些材料根据它们的金属度和粗糙度特性反射基于环境的照明(参见SCNScene lightingEnvironment属性)。</p>
<h2 id="multiply"><a href="#multiply" class="headerlink" title="multiply"></a>multiply</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> multiply: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>将材质的其他视觉属性与灯光和场景的其他信息相结合后，scene kit将每个渲染像素的颜色乘以该属性提供的颜色。您可以使用此属性使表面变暗或着色，而不受光照和其他属性的影响，或者通过阴影映射将预先计算的光照添加到场景中。</p>
<p>默认情况下，multiply属性的contents对象是白色的，导致属性没有可见效果。</p>
<p>下图显示了在将multiply属性的内容设置为纯色之前和之后的材质(带有纹理，用于漫反射(diffuse)和发射(emission)属性)。请注意，正片叠底的颜色甚至可以调节由辐射贴图添加的明亮区域。</p>
<p><img src="/2018/12/10/SCNMaterial/7da498a6-88ec-4a2e-a175-ea4952a05d28.png" alt="img"></p>
<h2 id="transparent"><a href="#transparent" class="headerlink" title="transparent"></a>transparent</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transparent: <span class="type">SCNMaterialProperty</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>使用此属性可选择性地使材料的某些部分呈现透明。可以使用透明(transparency)属性统一调整材质的不透明度，也可以使用节点的不透明度属性对附加到节点上的所有内容进行调整。</p>
<p>默认情况下，透明属性的contents对象是完全不透明的黑色，这导致属性没有可见效果。将透明属性的内容设置为任何纯色，将基于该颜色的不透明度值均匀地淡入材质的不透明度。</p>
<p>要使材质的某些部分看起来是透明的，请将属性的内容设置为图像或其他纹理映射内容，其alpha通道定义了完全或部分不透明的区域。</p>
<p>下图显示了半透明材质在为其透明属性提供纹理图像之前和之后。(为了使透明效果更加明显，透明材质后面显示了一个蓝色球体。)</p>
<p><img src="/2018/12/10/SCNMaterial/1fb27661-a358-46dc-8aaa-96acbe481fc6.png" alt="img"></p>
<p>transparencyMode控制SceneKit如何从透明属性的内容中解释颜色信息。</p>
<h2 id="shininess"><a href="#shininess" class="headerlink" title="shininess"></a>shininess</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shininess: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>材料的光泽(shininess)与其镜面(specular)特性和场景中的灯光(lighting)相互作用，从而在表面上产生明亮的高光。一个较高的值会产生更清晰的高光，使表面看起来更光滑和有光泽。</p>
<p>您可以对该属性的值进行动画更改。参见Animating SceneKit Content</p>
<h2 id="fresnelExponent"><a href="#fresnelExponent" class="headerlink" title="fresnelExponent"></a>fresnelExponent</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fresnelExponent: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>材料的菲涅尔指数(Fresnel exponent)与其反射(reflective)特性相互作用，根据其相对于观察者的角度确定表面反射的强度。较高的菲涅尔指数增加以浅角度观察材料时的反射率。</p>
<p>A higher Fresnel exponent increases the visibility of reflections when the material is viewed from a shallow angle.</p>
<p>您可以对该属性的值进行动画更改。参见Animating SceneKit Content</p>
<h2 id="locksAmbientWithDiffuse"><a href="#locksAmbientWithDiffuse" class="headerlink" title="locksAmbientWithDiffuse"></a>locksAmbientWithDiffuse</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locksAmbientWithDiffuse: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当建模真实世界的照明，在可见的环境光(ambient)和漫射光(diffuse)，一个表面通常被认为有一个单一的“基础”颜色或纹理。</p>
<p>当该属性值为false时，SceneKit没有这个限制:您可以使用材质的漫反射属性来提供在直接照明下可见的颜色或纹理，而使用它的ambient属性来为未直接照明的区域提供不同的颜色或纹理。</p>
<p>当这个属性的值为true时，或者当使用基于物理的阴影模式时，SceneKit将漫反射属性用于环境照明，忽略环境(ambient)属性，并确保材料对环境光和漫反射光的响应一致。</p>
<p>对于所有平台上的新应用程序，此属性的默认值为true。(在OS X v10.9和更早的版本中，默认值为false。)<br>您可以对该属性的值进行动画更改。参见Animating SceneKit Content</p>
<p>动画化此属性会在呈现每个状态的结果之间逐渐消失。</p>
<hr>
<h1 id="管理不透明度和混合"><a href="#管理不透明度和混合" class="headerlink" title="管理不透明度和混合"></a>管理不透明度和混合</h1><h2 id="transparency"><a href="#transparency" class="headerlink" title="transparency"></a>transparency</h2><h3 id="transparency-1"><a href="#transparency-1" class="headerlink" title="transparency"></a>transparency</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transparency: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>SceneKit通过将材质透明属性的颜色乘以该属性的值来确定表面中每个呈现像素的总不透明度。然后，材质的透明模式属性决定了材质的像素如何融入场景。</p>
<p>还可以使用节点的不透明度属性统一调整附加到节点的所有内容的不透明度。</p>
<p>您可以对该属性的值进行动画更改。参见Animating SceneKit Content</p>
<h3 id="transparencyMode"><a href="#transparencyMode" class="headerlink" title="transparencyMode"></a>transparencyMode</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transparencyMode: <span class="type">SCNTransparencyMode</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>默认的透明模式是SCNTransparencyMode.aOne。有关可用值及其效果，请参见scntransparent mode。</p>
<h3 id="SCNTransparencyMode"><a href="#SCNTransparencyMode" class="headerlink" title="SCNTransparencyMode"></a>SCNTransparencyMode</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SCNTransparencyMode</span> : <span class="title">Int</span></span></span><br><span class="line"><span class="class">'''</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">aOne</span></span></span><br><span class="line"><span class="class">//<span class="title">SceneKit</span> <span class="title">derives</span> <span class="title">transparency</span> <span class="title">information</span> <span class="title">from</span> <span class="title">the</span> <span class="title">alpha</span> <span class="title">channel</span> <span class="title">of</span> <span class="title">colors</span>. <span class="title">The</span> <span class="title">value</span> 1.0 <span class="title">is</span> <span class="title">opaque</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">rgbZero</span></span></span><br><span class="line"><span class="class">//<span class="title">SceneKit</span> <span class="title">derives</span> <span class="title">transparency</span> <span class="title">information</span> <span class="title">from</span> <span class="title">the</span> <span class="title">luminance</span> <span class="title">of</span> <span class="title">colors</span>. <span class="title">The</span> <span class="title">value</span> 0.0 <span class="title">is</span> <span class="title">opaque</span>.</span></span><br><span class="line"><span class="class">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="blending"><a href="#blending" class="headerlink" title="blending"></a>blending</h2><h3 id="blendMode"><a href="#blendMode" class="headerlink" title="blendMode"></a>blendMode</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blendMode: <span class="type">SCNBlendMode</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>使用SCNBlendMode的默认混合模式。alpha，材质根据alpha(不透明度)值进行混合——alpha值高的像素比alpha值低的像素更不透明。更改此属性以创建特殊效果。</p>
<p>例如，SCNBlendMode.add模式可以使对象看起来发光。</p>
<h3 id="SCNBlendMode"><a href="#SCNBlendMode" class="headerlink" title="SCNBlendMode"></a>SCNBlendMode</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SCNBlendMode</span> : <span class="title">Int</span></span></span><br><span class="line"><span class="class">'''</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">alpha</span></span></span><br><span class="line"><span class="class">//<span class="title">Blend</span> <span class="title">by</span> <span class="title">multiplying</span> <span class="title">source</span> <span class="title">and</span> <span class="title">destination</span> <span class="title">color</span> <span class="title">values</span> <span class="title">by</span> <span class="title">their</span> <span class="title">corresponding</span> <span class="title">alpha</span> <span class="title">values</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">add</span></span></span><br><span class="line"><span class="class">//<span class="title">Blend</span> <span class="title">by</span> <span class="title">adding</span> <span class="title">the</span> <span class="title">source</span> <span class="title">color</span> <span class="title">to</span> <span class="title">the</span> <span class="title">destination</span> <span class="title">color</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">subtract</span></span></span><br><span class="line"><span class="class">//<span class="title">Blend</span> <span class="title">by</span> <span class="title">subtracting</span> <span class="title">the</span> <span class="title">source</span> <span class="title">color</span> <span class="title">from</span> <span class="title">the</span> <span class="title">destination</span> <span class="title">color</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">multiply</span></span></span><br><span class="line"><span class="class">//<span class="title">Blend</span> <span class="title">by</span> <span class="title">multiplying</span> <span class="title">the</span> <span class="title">source</span> <span class="title">color</span> <span class="title">with</span> <span class="title">the</span> <span class="title">background</span> <span class="title">color</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">screen</span></span></span><br><span class="line"><span class="class">//<span class="title">Blend</span> <span class="title">by</span> <span class="title">multiplying</span> <span class="title">the</span> <span class="title">inverse</span> <span class="title">of</span> <span class="title">the</span> <span class="title">source</span> <span class="title">color</span> <span class="title">with</span> <span class="title">the</span> <span class="title">inverse</span> <span class="title">of</span> <span class="title">the</span> <span class="title">destination</span> <span class="title">color</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">replace</span></span></span><br><span class="line"><span class="class">//<span class="title">Blend</span> <span class="title">by</span> <span class="title">replacing</span> <span class="title">the</span> <span class="title">destination</span> <span class="title">color</span> <span class="title">with</span> <span class="title">the</span> <span class="title">source</span> <span class="title">color</span>, <span class="title">ignoring</span> <span class="title">alpha</span>.</span></span><br><span class="line"><span class="class">'''</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="自定义外观呈现"><a href="#自定义外观呈现" class="headerlink" title="自定义外观呈现"></a>自定义外观呈现</h1><h2 id="var-isLitPerPixel-Bool"><a href="#var-isLitPerPixel-Bool" class="headerlink" title="var isLitPerPixel: Bool"></a>var isLitPerPixel: Bool</h2><p>当该属性的值为true(默认值)时，SceneKit为每个呈现的像素独立执行光照计算。这种方法提供了更好的呈现质量，但是会对呈现性能产生负面影响。</p>
<p>如果将该属性的值更改为false, SceneKit将为几何图形中的每个顶点执行光照计算，并允许GPU在顶点之间的像素之间插入光照结果。根据几何图形表面的形状和顶点数量以及被渲染的材质属性，这种方法可以在不显著影响视觉质量的情况下提高渲染性能。</p>
<p>您可以对该属性的值进行动画更改。参见Animating SceneKit Content</p>
<p>动画化此属性会在呈现每个状态的结果之间逐渐消失。</p>
<h2 id="var-isDoubleSided-Bool"><a href="#var-isDoubleSided-Bool" class="headerlink" title="var isDoubleSided: Bool"></a>var isDoubleSided: Bool</h2><p>当该属性的值为false(默认值)时，SceneKit从一侧使用材质呈现一个表面。几何图形中的顶点数据和法向量指定每个多边形的哪一侧被认为是它的正面，几何图形相对于摄像机的方向决定了当前哪些正面是可见的。</p>
<p>如果将此属性的值更改为YES, SceneKit将同时呈现每个多边形的前表面和后表面。SceneKit假设面法线是正面法向量的负值。</p>
<p>您可以对该属性的值进行动画更改。参见Animating SceneKit Content</p>
<p>动画化此属性会在呈现每个状态的结果之间逐渐消失</p>
<h2 id="var-cullMode-SCNCullMode"><a href="#var-cullMode-SCNCullMode" class="headerlink" title="var cullMode: SCNCullMode"></a>var cullMode: SCNCullMode</h2><p>几何图形中的顶点数据和法向量指定每个多边形的哪一侧被认为是它的正面，几何图形相对于摄像机的方向决定了当前哪些正面是可见的。通常，后表面只出现在封闭几何图形的内部，被前表面所遮挡，因此渲染这些表面需要性能成本，但没有可见效果。</p>
<p>该属性的默认值是back，指定SceneKit应该选择或不呈现背面。您可以更改此属性的值，以使SceneKit只呈现材料的背面。有关可用值，请参见SCNCullMode。</p>
<p>您可以对该属性的值进行动画更改。参见Animating SceneKit Content</p>
<p>动画化此属性会在呈现每个状态的结果之间逐渐消失</p>
<h2 id="SCNCullMode"><a href="#SCNCullMode" class="headerlink" title="SCNCullMode"></a>SCNCullMode</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SCNCullMode</span> : <span class="title">Int</span></span></span><br><span class="line"><span class="class">'''</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">back</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">front</span></span></span><br><span class="line"><span class="class">'''</span></span><br></pre></td></tr></table></figure>
<p>几何图形中的顶点数据和法向量指定每个多边形的哪一侧被认为是它的正面，几何图形相对于摄像机的方向决定了当前哪些正面是可见的。通常，后表面只出现在封闭几何图形的内部，被前表面所遮挡，因此渲染这些表面需要性能成本，但没有可见效果。</p>
<hr>
<h1 id="管理渲染目标"><a href="#管理渲染目标" class="headerlink" title="管理渲染目标"></a>管理渲染目标</h1><h2 id="var-writesToDepthBuffer-Bool"><a href="#var-writesToDepthBuffer-Bool" class="headerlink" title="var writesToDepthBuffer: Bool"></a>var writesToDepthBuffer: Bool</h2><p>SceneKit的呈现过程使用深度缓冲区来确定相对于查看器呈现的表面的顺序。该属性的默认值为true，指定SceneKit为每个呈现的像素保存深度信息，以便稍后的呈现传递使用。</p>
<p>通常，在呈现半透明对象时禁用对深度缓冲区的写入，因为呈现过程的后续阶段可能需要关于其背后不透明对象的深度信息。</p>
<h2 id="var-readsFromDepthBuffer-Bool"><a href="#var-readsFromDepthBuffer-Bool" class="headerlink" title="var readsFromDepthBuffer: Bool"></a>var readsFromDepthBuffer: Bool</h2><p>SceneKit的呈现过程使用深度缓冲区来确定相对于查看器呈现的表面的顺序。该属性的默认值为true，指定SceneKit在渲染材质时将每个渲染像素的深度与其深度缓冲区中的相应值进行比较。如果像素的深度大于深度缓冲区中相应的点，SceneKit不会呈现像素。</p>
<p>通常，在呈现无论场景中已经呈现的内容如何都应该可见的对象时(例如，游戏中的抬头显示)，您将禁用从深度缓冲区读取。在这种情况下，还应该为节点的renderingOrder属性设置一个高值，该属性包含要始终可见的任何内容。</p>
<hr>
]]></content>
      <categories>
        <category>Swift</category>
        <category>SceneKit</category>
        <category>SCNMaterial</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SceneKit</tag>
        <tag>SCNMaterial</tag>
      </tags>
  </entry>
  <entry>
    <title>如何书写一份 PlaygroundBook (2)</title>
    <url>/2020/05/14/HackthePlaygroundBook-2/</url>
    <content><![CDATA[<blockquote>
<p>本文以Apple Developer 官网资料以及笔者的实践和经历，归纳笔者所知道的“书写”一份 Playground Book 所能用到的技巧。</p>
<p>本文：</p>
<p>创建于： 2020/02/25</p>
<p>更新于：2020/02/25</p>
<p>当前版本：</p>
<p>Swift: version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)</p>
<p>Xcode: version 11.3.1 (11C504)</p>
<p>Playgrounds (on Mac) : Version 3.2 (1137.33.1)</p>
<p>Playgrounds (on iPad) : Version 3.2 (1084.31)</p>
<p>注意：本文的绝大部份涉及例子和代码的内容笔者只会在 Playgrounds (on Mac) 上进行测试，笔者认为两个平台在 Playground Book 本身的技术上并无差异。</p>
</blockquote>
<a id="more"></a>
<h1 id="Playground-的注解"><a href="#Playground-的注解" class="headerlink" title="Playground 的注解"></a>Playground 的注解</h1><blockquote>
<p>在本文中会大量出现表示诸如：<code>Swift Playground Book</code> 、<code>Swift Playground Page</code> 等概念的名词，笔者认为将这些名词翻译出来（如：书、书页、章节）会使阅读十分不顺且难以理解，但直接使用英文全称有些冗长且同样不好理解。因此，笔者作出以下约定：</p>
<ul>
<li>将 <code>Swift playground Book(s)</code> 表示为 “book”</li>
<li>将 <code>Swift playground Chapter(s)</code> 表示为 “Chapter”</li>
<li>将 <code>Swift playground Page(s)</code> 表示为 “page”</li>
<li>将 <code>Swift module(s)</code> 或 <code>UserModule</code> 表示为 “module”</li>
<li>将 <code>Introduction</code> 或 <code>引导页</code> 表示为 ”cutscene“ </li>
</ul>
<p>以上概念不仅表示相对应的 Swift Playground Book 结构，还会表示对应结构的根目录。</p>
</blockquote>
<h2 id="为“page”书写描述短文"><a href="#为“page”书写描述短文" class="headerlink" title="为“page”书写描述短文"></a>为“page”书写描述短文</h2><p>在 Swift 代码中添加注释标记，以此将文本作为描述短文呈现给用户。</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/image-20200225151547479.png" alt="image-20200225151547479" style="zoom: 25%;"></p>
<p>“page”总是需要描述短文来介绍在“page”上教授的概念。 可以使用一种特殊的 Swift 注释将一行或一小段文本标记为描述短文。在 Swift Playgrounds 中显示“page”的 <code>main.swift</code> 文件时，标记为描述短文的注释将使用具有一定比例的字体显示。 </p>
<h3 id="添加单行的描述短文"><a href="#添加单行的描述短文" class="headerlink" title="添加单行的描述短文"></a>添加单行的描述短文</h3><p>要将一句简短的描述短文添加到“page”中，可以使用一句以冒号开头的 Swift 注释（<code>//:</code>）。如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//: This line contains a short sentence.</span></span><br></pre></td></tr></table></figure>
<p>不带冒号的注释将被视为普通的Swift注释，并以等宽字体显示。 任何形式的注释之外的文本都将被视为 Swift 代码，并在点击“运行我的代码”时运行。</p>
<blockquote>
<p>Example Code:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">//: This line contains a short sentence.</span></span><br><span class="line">&gt; <span class="comment">// This line doesn't contains a short sentence.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Example Result:</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/image-20200225153551829.png" alt="image-20200225153551829" style="zoom: 33%;"></p>
</blockquote>
<h3 id="添加多行的描述短文"><a href="#添加多行的描述短文" class="headerlink" title="添加多行的描述短文"></a>添加多行的描述短文</h3><p>使用多行 Swift 注释获得更长的段落。 可以通过在注释的开始定界符后立即添加一个冒号来表示多行注释（<code>/*:</code>）。如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*:</span></span><br><span class="line"><span class="comment">    Roses are `UIColor.red`,</span></span><br><span class="line"><span class="comment">    Violets are 🔵,</span></span><br><span class="line"><span class="comment">    Swift Playgrounds are rad,</span></span><br><span class="line"><span class="comment">    and so are you!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>无需使用特殊的定界符即可关闭多行注释； 使用常规注释结束语法（<code>* /</code>）来结束多行描述短文的注释块。</p>
<blockquote>
<p>Example Code:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">/*:</span></span><br><span class="line"><span class="comment">&gt;  Roses are `UIColor.red`,</span></span><br><span class="line"><span class="comment">&gt;  Violets are 🔵,</span></span><br><span class="line"><span class="comment">&gt;  Swift Playgrounds are rad,</span></span><br><span class="line"><span class="comment">&gt;  and so are you!</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Example Result:</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/image-20200225154132754.png" alt="image-20200225154132754" style="zoom:33%;"></p>
</blockquote>
<h3 id="引用本地化中的描述短文"><a href="#引用本地化中的描述短文" class="headerlink" title="引用本地化中的描述短文"></a>引用本地化中的描述短文</h3><p>使用特殊的注释语法将“page”上的内容本地化：<code>//:#localized(key:</code><em>identifier</em><code>)</code> 。标识符键（<code>identifier</code>）必须对应于这个“page”的 PrivateResources 文件夹中每个本地化文件夹中的 <code>Prose.strings</code> 文件中的条目。</p>
<p>下述的例子中，“ExplanationOfLoops”引用了“page”的 PrivateResources 文件夹内的 <code>en.lproj</code> 文件夹内 <code>Prose.strings</code> 文件里包含的描述短文。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//:#localized(key: "ExplanationOfLoops")</span></span><br></pre></td></tr></table></figure>
<p>字符串文件（Strings File）（一种以 <code>.string</code> 为后缀结尾的文件）包含多个键值对（key-value），其中键（key）是用于标识本地化的描述短文代码块的短语，而值（value）是本地化的描述短文。</p>
<p>下面的示例展示了进行英文本地化操作的“ExplanationOfLoops”在 <code>Prose.strings</code> 文件内的键值对：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* An intro to loops. */</span></span><br><span class="line"><span class="string">"ExplanationOfLoops"</span> = <span class="string">"Use loops to repeat an action multiple times until a condition is met."</span>;</span><br></pre></td></tr></table></figure>
<p>经过渲染后，“page”会显示“Use loops to repeat an action multiple times until a condition is met.”而不是“ExplanationOfLoops”。</p>
<p>如果“page”有多个本地化语言的版本，那么此时引用的内容将与用户 iPad 语言版本保持一致。</p>
<p>字符串文件（Strings File）是用于多种本地化和国际化处理的通用格式。</p>
<blockquote>
<p>创建后，某一“page”的文件结构应类似于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">&gt; └── Page1.playgroundpage</span><br><span class="line">&gt;  ├── Manifest.plist</span><br><span class="line">&gt;  ├── PrivateResources</span><br><span class="line">&gt;  │   └── en.lproj</span><br><span class="line">&gt;  │       └── Prose.strings</span><br><span class="line">&gt;  └── main.swift</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>进行文章叙述的操作后可以看到：</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/image-20200225161657673.png" alt="image-20200225161657673" style="zoom:33%;"></p>
</blockquote>
<hr>
<h2 id="指定“page”上可编辑的区域"><a href="#指定“page”上可编辑的区域" class="headerlink" title="指定“page”上可编辑的区域"></a>指定“page”上可编辑的区域</h2><p>用过使用符号来对 <code>main.swift</code> 中的允许用户编辑和复制的代码进行标记，以此引导用户进行学习。</p>
<p>可以通过使用特殊的注释语法将代码区域标记为可编辑区域。 使用可编辑和不可编辑的代码区域来指导用户完成关卡所需要编辑的代码。</p>
<p>默认情况下，除非添加至少一个可编辑区域，否则“page”上的所有代码都是可编辑的。 将“page”中的任何区域标记为可编辑，将锁定页面上的其余代码。 对于面向初学者的“page”，建议将可编辑区域限制在一个较小的区域，以避免可能的意外编辑使得“page”难以恢复。</p>
<h3 id="标记内联可编辑区域"><a href="#标记内联可编辑区域" class="headerlink" title="标记内联可编辑区域"></a>标记内联可编辑区域</h3><p>可以使用内联可编辑区域来使用户编辑一小段代码。 例如，通过首先让用户尝试改变单个值或变量来查看它如何影响整个页面的执行情况，从而逐步揭示更大范围的代码是如何工作的。</p>
<p>可以使用一个特殊的注释表达式来添加一个内联可编辑区域：</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/7826cecd-2735-4d81-9144-dd89df6730f3.png" alt="A diagram showing &quot;/*#-editable-code&quot;, followed by placeholder text, followed by &quot;*/&quot;, followed by the content placeholder, followed by &quot;/*#-end-editable-code*/&quot;."></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*#-editable-code */</span> <span class="comment">/*#-end-editable-code*/</span></span><br></pre></td></tr></table></figure>
<p>占位符（<code>placeholder text</code>）是在用户开始编辑并添加自己的代码之前一直显示的文本。 内容（<code>content</code>）是直到该值被编辑之前 Swift 代码默认值的文本。</p>
<p>下述例子中的内敛可编辑区域在编辑前会一直显示“number of repetitions”，并且会使用 <code>1</code>  作为 Swift 代码的初始值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//: Enter a value for the number of repetitions so that `x` is set to 25</span></span><br><span class="line"><span class="comment">//: ---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ... <span class="comment">/*#-editable-code number of repetitions*/</span><span class="number">1</span><span class="comment">/*#-end-editable-code*/</span> &#123;</span><br><span class="line">    x += <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当显示在“page”上时，上述例子中的代码将与在一个可点击的按钮中的占位符文本一起显示，点击按钮以激活编辑功能。</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/image-20200225170450179.png" alt="image-20200225170450179" style="zoom:33%;"></p>
<blockquote>
<p>注意：</p>
<p>当 <code>content</code> 没有内容时，可编辑区域才会显示出 <code>placeholder text</code> 的内容。</p>
<p>否则将直接显示出 <code>content</code> 的内容。</p>
</blockquote>
<h3 id="标记多行可编辑区域"><a href="#标记多行可编辑区域" class="headerlink" title="标记多行可编辑区域"></a>标记多行可编辑区域</h3><p>使用相同的特殊注释语法标记多行的可编辑区域。</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/c23f0e08-f514-4ec2-9be8-ab143b439dbc.png" alt="img" style="zoom:67%;"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#-editable-code</span></span><br><span class="line"><span class="comment">//#-end-editable-code</span></span><br></pre></td></tr></table></figure>
<p>在多行可编辑区域中编写的内容必须与周围的代码具有相同的缩进级别。</p>
<h3 id="使用占位符标记可编辑区域"><a href="#使用占位符标记可编辑区域" class="headerlink" title="使用占位符标记可编辑区域"></a>使用占位符标记可编辑区域</h3><p>可以在可编辑区域使用特殊的占位符。 这种占位符在“page”上表现为一个可以点击选择的标签（label），它允许包含空格和特殊字符。 可以在这种占位符标记中包含任何 Swift 的类型（<code>class</code> 或 <code>struct</code>）的名称，以此限制在可编辑区域中输入的值的类型。</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/67d5c91b-0e1e-4299-a978-5491e259030c.png" alt="img" style="zoom: 50%;"></p>
<p>当用户选择了一个“page”上的一个占位符就会使输入快捷栏显示出来。如果选择的占位符包含了一个指定的类型，那么就会显示出便于输入该类型的特定的弹出框（如果 Swift Playground 具有的该功能）。例如，如果占位符所指定输入的类型是 <code>Int</code> 类型，那么当选中这个占位符时将会弹出数字输入框。</p>
<p>以下展示了无类型指定和有类型指定的占位符变量的声明方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> untypedLlamaCount = <span class="comment">/*#-editable-code*/</span>&lt;#number of llamas#&gt;<span class="comment">/*#-end-editable-code*/</span></span><br><span class="line">     </span><br><span class="line"><span class="keyword">var</span> typedLlamaCount = <span class="comment">/*#-editable-code*/</span>&lt;#<span class="type">T</span>##number of llamas##<span class="type">Int</span>#&gt;<span class="comment">/*#-end-editable-code*/</span></span><br></pre></td></tr></table></figure>
<p>以下这张图片展示了当指定输入类型为 <code>Int</code> 的占位符被选中后弹出数字输入框时的界面：</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/a73a5a58-8565-43b7-a52e-e015561dadfa.png" alt="Screenshot showing a 10-digit number entry interface in response to a tapped placeholder token with an Int type." style="zoom:33%;"></p>
<blockquote>
<p>注意：</p>
<p>在 Swift 代码文件本身也可以渲染占位符（Xcode 的优秀功能），所以当声明正确的占位符后，在代码文件中同样会被渲染成占位符。</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/image-20200225232918682.png" alt="image-20200225232918682"></p>
<p>比较奇怪的是笔者这里按照要求书写代码（复制粘贴）之后，在两个平台上都未能显示出上述的数字输入框。</p>
</blockquote>
<h3 id="使可编辑区域能够被复制"><a href="#使可编辑区域能够被复制" class="headerlink" title="使可编辑区域能够被复制"></a>使可编辑区域能够被复制</h3><hr>
<h2 id="在“page”上隐藏代码"><a href="#在“page”上隐藏代码" class="headerlink" title="在“page”上隐藏代码"></a>在“page”上隐藏代码</h2><p>使用特殊的 Swift 注释方法使得 “page”（<code>main.swift</code>）上的代码隐藏起来，但依旧会被执行。</p>
<p>可以隐藏那些与“page”所要展示的内容无关的代码，比如“page”设置相关的函数的调用、评估用户进度的代码、可编辑区域中的函数等。当用户运行“page”时，被隐藏的代码依然会被执行。</p>
<p>可以将想要隐藏的代码放置在 <code>/hidden-code</code> 和 <code>/end-hidden-code</code> 两个定界符之间。</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/10d92be8-4f95-457f-88de-901872a81478.png" alt="Diagram showing the hidden-code and end-hidden code comment syntax. The first line is &quot;//#-hidden-code&quot;, followed by a placeholder line, terminated with a line with contents &quot;//#-end-hidden-code&quot;." style="zoom: 50%;"></p>
<p>下述内容展示了在“page”上书写的原始的代码，包括了被隐藏的代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#-hidden-code</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"><span class="keyword">let</span> viewRect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span> , height: <span class="number">400</span>)</span><br><span class="line"><span class="keyword">let</span> theView = <span class="type">CustomView</span>(frame: viewRect)</span><br><span class="line"><span class="type">PlaygroundPage</span>.current.liveView = theView</span><br><span class="line"><span class="comment">//#-end-hidden-code</span></span><br><span class="line"><span class="comment">//#-editable-code</span></span><br><span class="line">theView.markColor = <span class="type">UIColor</span>.darkGray</span><br><span class="line">theView.isChecked = <span class="literal">true</span></span><br><span class="line"><span class="comment">//#-end-editable-code</span></span><br></pre></td></tr></table></figure>
<p>下述图片展示了上述代码在被 Swift Playground 渲染之后的结果。</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/image-20200226001358954.png" alt="image-20200226001358954" style="zoom: 33%;"></p>
<hr>
<h2 id="自定义快捷栏中分代码补全"><a href="#自定义快捷栏中分代码补全" class="headerlink" title="自定义快捷栏中分代码补全"></a>自定义快捷栏中分代码补全</h2><p>通过在快捷栏中隐藏不必要的符号和显示其他的符号来引导用户完成解决方案。</p>
<p>通过隐藏和显示不同的符号或符号集来自定义快捷方式栏中显示的代码补全。可以在编辑“page”的任何时候显示或隐藏某个代码补全。</p>
<p>下图显示了“学习编码1”中的自定义代码补全。 自定义快捷方式栏仅显示四种方法（<code>function</code>），而不显示所有可能的代码补全，例如 Swift 标准库或当前模块中的公共符号。</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/62783ae7-c9e3-456b-bae1-97b5d9b4a0f5.png" alt="img" style="zoom: 50%;"></p>
<h3 id="添加用于描述代码补全的注释"><a href="#添加用于描述代码补全的注释" class="headerlink" title="添加用于描述代码补全的注释"></a>添加用于描述代码补全的注释</h3><p>通过一行代码补全定界符（code-completion delimiter）来指定某一代码补全显示或隐藏。注意，这句注释不需要遵从附近代码的缩进格式。</p>
<p><img src="https://docs-assets.developer.apple.com/published/efef6d214b/5406d079-a662-4ab9-bb1f-8de4c353e0c9.png" alt="img"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#-code-completion(&lt;#namespace#&gt;, hide, &lt;#completions#&gt;)</span></span><br><span class="line"><span class="comment">//#-code-completion(&lt;#namespace#&gt;, show, &lt;#completions#&gt;)</span></span><br></pre></td></tr></table></figure>
<p>使用代码补全定界符可以在可能的补全列表中添加或删除一个符号或一组符号。 在第一个参数命名空间（<code>namespace</code>）中，指定可能的符号的空间。 在下一个参数中，指定要执行的操作：从可能的代码完成列表中添加符号（<code>show</code>）或删除符号（<code>hide</code>）。 命名空间（<code>namespace</code>）和操作（<code>action</code>）的组合通过使用英文逗号隔开的补全列表的形式呈现，例如函数名称或模块名称。</p>
<p>在“page”上包含许多代码补全定界符。 用户在快捷栏中看到的可能使用的补全的列表包括在当前插入点处可见的所有符号。 当插入点位与“page”的代码源文件（<code>main.swift</code>）中的代码补全定界符的下方时，符合要求的代码定界符才会生效。</p>
<h3 id="选择符号的命名空间"><a href="#选择符号的命名空间" class="headerlink" title="选择符号的命名空间"></a>选择符号的命名空间</h3><p>使用代码补全定界符的命名空间（<code>namespace</code>）参数，以此来决定要显示或隐藏的符号的范围。 可以使用以下任何值来选择符号名称空间：</p>
<ul>
<li><p><code>bookauxiliarymodule</code></p>
<ul>
<li>任何来自该“book”中名为 <code>Sources</code> 文件夹内的 Swift 源文件中的公共符号。</li>
</ul>
</li>
<li><p><code>chapterauxiliarymodule</code></p>
<ul>
<li>任何来自当前“chapter”中名为 <code>Sources</code> 文件夹内的 Swift 源文件中的公共符号。</li>
</ul>
</li>
<li><p><code>currentmodule</code></p>
<ul>
<li>任何来自当前“page”的公共符号。</li>
</ul>
</li>
<li><p><code>description</code></p>
<ul>
<li><p>逗号分隔的字符串列表中的任何公共符号。</p>
</li>
<li><p>对应的 <code>completions</code> 参数：字符串的列表，可根据快捷方式栏中显示的名称与符号补全进行匹配。</p>
</li>
<li><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#-code-completion(description, show, "randomInt(from: Int, to: Int)", "turnLock(up: Book, numberOfTimes: Int)")</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>everything</code></p>
<ul>
<li><p>任何来自“module”的公共符号。</p>
</li>
<li><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#-code-completion(everything, hide)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>identifier</code></p>
<ul>
<li><p>逗号分隔的参数列表中的任何关键字。</p>
</li>
<li><p>对应的 <code>completions</code> 参数：标识符列表，包括函数名称，标点，变量和任何其他符号。</p>
</li>
<li><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#-code-completion(identifier, show, moveForward(), turnLeft(), collectGem(), toggleSwitch())</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>keyword</code></p>
<ul>
<li><p>逗号分隔的参数列表中的任何关键字。</p>
</li>
<li><p>对应的 <code>completions</code> 参数：<code>for</code> 、 <code>func</code> 、 <code>if</code> 、 <code>let</code> 、 <code>var</code>  and  <code>while</code> 。</p>
</li>
<li><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#-code-completion(keyword, for)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>literal</code></p>
<ul>
<li>逗号分隔的参数列表中的任何字面量类型。</li>
<li>对应的 <code>completions</code> 参数：<code>array</code> 、 <code>boolean</code> 、 <code>color</code> 、 <code>dictionary</code> 、 <code>image</code> 、 <code>integer</code> 、 <code>nil</code> 、<code>string</code> and <code>tuple</code> 。</li>
</ul>
</li>
<li><p><code>module</code></p>
<ul>
<li>任何来自特定“module”的公共符号</li>
<li>对应的 <code>completions</code> 参数：“module”的名称组成的列表。</li>
</ul>
</li>
<li><p><code>pageauxiliarymodule</code></p>
<ul>
<li>任何来自当前“page”中名为 <code>Sources</code> 文件夹内的 Swift 源文件中的公共符号。</li>
</ul>
</li>
<li><p><code>snippet</code></p>
<ul>
<li>逗号分隔的参数列表中的所有代码片段。</li>
<li>对应的 <code>completions</code> 参数：代码片段的名称组成的列表。</li>
</ul>
</li>
</ul>
<p>如果需要在重载符号之间消除歧义，使用 <code>description</code> 而不是 <code>identifier</code> 作为命名空间（<code>namespace</code>）的参数。 <code>description</code>  包含可用于选择特定重载的类型信息。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#-code-completion(identifier, show, randomInt(from:to:), turnLock(up:numberOfTimes:)</span></span><br><span class="line"><span class="comment">//#-code-completion(description, show, "randomInt(from: Int, to: Int)", "turnLock(up: Book, numberOfTimes: Int)")</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="本地化代码注释和字符串"><a href="#本地化代码注释和字符串" class="headerlink" title="本地化代码注释和字符串"></a>本地化代码注释和字符串</h2><p>标记一块代码区域将它替换为为当前用户本地化之后的代码。</p>
<p>如果要编写一个能够在多个语言地区发布的“book”，可以使用注释语法对每个页面上的被划分为本地化区域的注释和字符串进行本地化。</p>
<h3 id="添加本地化操作定界符"><a href="#添加本地化操作定界符" class="headerlink" title="添加本地化操作定界符"></a>添加本地化操作定界符</h3><p>将需要本地化操作的代码包裹在定界符中，比如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//#-localizable-zone(welcome1)</span></span><br><span class="line"><span class="comment">Welcome!</span></span><br><span class="line"><span class="comment">//#-end-localizable-zone</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>每个定界符带有一个唯一的区域标识符（例如， <code>welcome1</code> ， <code>welcome2</code> 等），该标识符与为每个页面定义的 <code>LocalizableCode.strings</code> 文件中的条目匹配。</p>
<p>还可以使用内联注释定界符使字符串本地化；例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"/*#-localizable-zone(welcome2)*/Hello!/*#-end-localizable-zone*/"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<p>仅使用本地化定界符将代码注释和字符串文字括起来。 这样做有助于确保不会引入对语言环境敏感的编译错误。</p>
</blockquote>
<h3 id="创建一个本地化文件"><a href="#创建一个本地化文件" class="headerlink" title="创建一个本地化文件"></a>创建一个本地化文件</h3><p>当用户打开“book”中的“page”时，系统会在 <code>LocalizableCode.strings</code> 文件的相应语言目录（例如，“page” / <code>PrivateResources</code> / <code>de.lproj</code> 目录中查找德语本地化字符串）中查找。 然后，将分隔符与其对应的区域 ID 匹配，并用本地化的文本替换页面中的文本字符串。</p>
<p>将本地化字符串文件格式化为本地化标识符列表，后跟本地化字符串。 以下示例定义了由 <code>welcome1</code> 和 <code>welcome2</code> 标识的内容的本地化形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initial greeting. */</span></span><br><span class="line"><span class="string">"welcome1"</span> = <span class="string">"Willkommen!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Second greeting. */</span></span><br><span class="line"><span class="string">"welcome2"</span> = <span class="string">"Guten Tag!"</span>;</span><br></pre></td></tr></table></figure>
<p>经过渲染，经过本地化处理的注释和字符串会显示在界面的相应的位置上。</p>
<p><img src="/2020/05/14/HackthePlaygroundBook-2/image-20200226013254388.png" alt="image-20200226013254388" style="zoom: 67%;"></p>
<hr>
]]></content>
      <categories>
        <category>Swift</category>
        <category>PlaygroundBook</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>PlaygroundBook</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structures in Swift — Standard Library</title>
    <url>/2018/12/12/Data-Structures-in-Swift/</url>
    <content><![CDATA[<h1 id="Standard-Library"><a href="#Standard-Library" class="headerlink" title="Standard Library"></a>Standard Library</h1><p>在深入学习数据结构之前，首先将看到一些Swift中的基础数据结构。Swift标准库是指定义Swift语言核心组件的框架。在里面，你会发现各种各样的工具和类型，以帮助建立Swift应用程序。<br>在本篇，将重点介绍标准库直接提供的两个数据结构:数组和字典。</p>
<blockquote>
<p>内容源于：By Matthijs Hollemans. “Data Structures &amp; Algorithms in Swift”. Apple Books.<br><a id="more"></a></p>
</blockquote>
<h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><h2 id="创建-声明-一个数组"><a href="#创建-声明-一个数组" class="headerlink" title="创建(声明)一个数组"></a>创建(声明)一个数组</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">Number</span> = [<span class="type">Int</span>]()  <span class="comment">// 声明一个空数组</span></span><br><span class="line"><span class="keyword">var</span> fibonacci:[<span class="type">Int</span>] = []  <span class="comment">// 同，声明一个空数组</span></span><br><span class="line"><span class="keyword">var</span> fibonacciNumber = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>]  <span class="comment">// 声明一个数组，元素类型是Int</span></span><br></pre></td></tr></table></figure>
<p>注：数组的声明，必须包含两点——用以表示数组的标识和数组元素的类型，其中元素类型决定了所有元素的统一类型，同时swift可以自行推断数据类型</p>
<h2 id="获取数组中的数据-内容"><a href="#获取数组中的数据-内容" class="headerlink" title="获取数组中的数据(内容)"></a>获取数组中的数据(内容)</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fibonacciNumber[<span class="number">4</span>]  <span class="comment">// 获取数组的第五个元素，数组以0为第一个的标记</span></span><br><span class="line">fibonacciNumber[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment">// 将第一个元素赋值为1</span></span><br><span class="line">fibonacciNumber[<span class="number">0</span>...<span class="number">3</span>] = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  <span class="comment">// 将首四个元素赋值</span></span><br><span class="line">fibonacciNumber  <span class="comment">// 获取数组本身</span></span><br></pre></td></tr></table></figure>
<h2 id="属性-amp-方法-amp-常用操作"><a href="#属性-amp-方法-amp-常用操作" class="headerlink" title="属性&amp;方法&amp;常用操作"></a>属性&amp;方法&amp;常用操作</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fibonacciNumber.<span class="built_in">count</span>  <span class="comment">// 获取数组的元素个数</span></span><br><span class="line">fibonacci.isEmpty  <span class="comment">// 判断数组是否为空</span></span><br><span class="line">fibonacciNumber.isEmpty  <span class="comment">// 判断数组是否为空</span></span><br><span class="line">fibonacciNumber.<span class="built_in">contains</span>(<span class="number">4</span>)  <span class="comment">// 判断数组是否包含某个元素</span></span><br><span class="line">fibonacciNumber.first  <span class="comment">// 获取数组第一个元素</span></span><br><span class="line">fibonacciNumber.last  <span class="comment">// 获取数组最后一个元素</span></span><br><span class="line">fibonacciNumber.removeFirst()  <span class="comment">// 移除第一个元素，返回移除的元素</span></span><br><span class="line">fibonacciNumber.removeLast()  <span class="comment">// 移除最后一个元素，返回元素</span></span><br><span class="line">fibonacciNumber.<span class="built_in">min</span>()  <span class="comment">// 求出数组中最小的元素</span></span><br><span class="line">fibonacciNumber.<span class="built_in">min</span>(by: &gt;)  <span class="comment">// 求出数组中最小的元素，以'&gt;'规则</span></span><br><span class="line">fibonacciNumber.<span class="built_in">max</span>()  <span class="comment">// 求出数组中最大的元素</span></span><br><span class="line">fibonacciNumber.<span class="built_in">max</span>(by: &gt;)  <span class="comment">// 求出数组中最大的元素，以'&gt;'规则</span></span><br><span class="line">fibonacciNumber.<span class="built_in">dropFirst</span>()  <span class="comment">// 移除第一个元素，返回结果数组</span></span><br><span class="line">fibonacciNumber.<span class="built_in">dropLast</span>()  <span class="comment">// 移除最后一个元素，返回结果数组</span></span><br><span class="line">fibonacciNumber.<span class="built_in">dropLast</span>(<span class="number">2</span>)  <span class="comment">// 移除最后两个元素，返回结果数组</span></span><br><span class="line">fibonacciNumber.<span class="built_in">dropFirst</span>(<span class="number">2</span>)  <span class="comment">// 移除前两个元素，返回结果数组</span></span><br><span class="line">fibonacciNumber.forEach &#123; (word) <span class="keyword">in</span>  <span class="comment">// 遍历数组，每次读取的结果以word指代</span></span><br><span class="line"><span class="built_in">print</span>(word)</span><br><span class="line">&#125;</span><br><span class="line">fibonacciNumber.append(<span class="number">55</span>)  <span class="comment">// 在数组尾添加元素55</span></span><br><span class="line">fibonacciNumber += [<span class="number">89</span>]  <span class="comment">// 在数组尾添加元素89</span></span><br><span class="line">fibonacciNumber.insert(<span class="number">0</span>, at: <span class="number">0</span>)  <span class="comment">// 在数组序列为0的位置插入0</span></span><br><span class="line">fibonacciNumber.remove(at: <span class="number">0</span>)  <span class="comment">// 移除数组序列为0的元素</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> fibonacciNumber &#123;  <span class="comment">// 遍历数组，每次读取的结果以item指代</span></span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (index,value) <span class="keyword">in</span> fibonacciNumber.enumerated()&#123;  </span><br><span class="line"><span class="comment">// 元组遍历字典，字典由数组元素和其序列合成</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(index+1) and \(value)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fibonacciNumber.<span class="built_in">sort</span>(by : &gt;)  <span class="comment">// 原地排序数组，数组本身被更改，'&gt;'为规则 </span></span><br><span class="line">fibonacciNumber.sorted()  <span class="comment">// 为数组排序，返回结果，不更改自身</span></span><br><span class="line">fibonacciNumber.reversed()  <span class="comment">// 反转数组</span></span><br><span class="line">fibonacciNumber.<span class="built_in">distance</span>(from: <span class="number">1</span>, to: <span class="number">4</span>)  <span class="comment">// 获取距离</span></span><br></pre></td></tr></table></figure>
<h1 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h1><h2 id="创建-声明-一个字典"><a href="#创建-声明-一个字典" class="headerlink" title="创建(声明)一个字典"></a>创建(声明)一个字典</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> character = [<span class="type">Int</span>:<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">var</span> letter:[<span class="type">Int</span>:<span class="type">String</span>] = [:]</span><br><span class="line"><span class="keyword">var</span> characters = [</span><br><span class="line"><span class="number">1</span>:<span class="string">"R"</span>,</span><br><span class="line"><span class="number">2</span>:<span class="string">"B"</span>,</span><br><span class="line"><span class="number">3</span>:<span class="string">"C"</span>,</span><br><span class="line"><span class="number">4</span>:<span class="string">"D"</span>,</span><br><span class="line"><span class="number">5</span>:<span class="string">"E"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>注：字典的声明，必须包含三点——用以表示字典的标识以及key值和value值的类型，其中key值和value值的类型决定了相应部分的统一类型，同时swift可以自行推断数据类型</p>
<h2 id="获取字典中的数据-内容"><a href="#获取字典中的数据-内容" class="headerlink" title="获取字典中的数据(内容)"></a>获取字典中的数据(内容)</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">characters[<span class="number">3</span>]  <span class="comment">// key为3的value</span></span><br><span class="line">characters[<span class="number">1</span>] = <span class="string">"A"</span>  <span class="comment">// 将key为1的value赋值为A</span></span><br><span class="line">characters[<span class="number">0</span>] = <span class="literal">nil</span>  <span class="comment">// 将key为0的value赋值为nil(即清除这个键值对)</span></span><br><span class="line">characters  <span class="comment">// 获取字典</span></span><br></pre></td></tr></table></figure>
<h2 id="属性-amp-方法-amp-常用操作-1"><a href="#属性-amp-方法-amp-常用操作-1" class="headerlink" title="属性&amp;方法&amp;常用操作"></a>属性&amp;方法&amp;常用操作</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">characters.keys  <span class="comment">// 获取所有key值，返回一个数组</span></span><br><span class="line">characters.keys.sorted()  <span class="comment">// 获取所有key值，返回一个排序后的数组</span></span><br><span class="line">characters.values  <span class="comment">// 获取所有value值，返回一个数组</span></span><br><span class="line">characters.index(forKey: <span class="number">2</span>)  <span class="comment">// 获取key的序列，返回Dictionary&lt;Key, Value&gt;.Index</span></span><br><span class="line">characters.first  <span class="comment">// 获取字典的第一个键值对，返回元组</span></span><br><span class="line">characters.<span class="built_in">min</span>(by: &gt;)  <span class="comment">// 获取字典key排序后的第一个键值对，返回元组</span></span><br><span class="line">characters.<span class="built_in">max</span>(by: &gt;)  <span class="comment">// 获取字典key排序后的第一个键值对，返回元组</span></span><br><span class="line">characters.forEach &#123;  <span class="comment">// 遍历字典</span></span><br><span class="line">word <span class="keyword">in</span></span><br><span class="line"><span class="built_in">print</span>(word)</span><br><span class="line">&#125;</span><br><span class="line">characters.<span class="built_in">count</span>  <span class="comment">// 获取字典元素个数</span></span><br><span class="line">characters.isEmpty  <span class="comment">// 判空</span></span><br><span class="line">characters.updateValue(<span class="string">"F"</span>, forKey: <span class="number">6</span>)  <span class="comment">// 更新字典，如果有则替代，否则新增，并返回新的value</span></span><br><span class="line">characters.removeValue(forKey: <span class="number">6</span>)  <span class="comment">// 移除key为6的键值对，如果有则返回移除的value，否则是nil</span></span><br><span class="line"><span class="keyword">var</span> dictionary = [<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">2</span>]</span><br><span class="line">dictionary.merge([<span class="string">"a"</span>: <span class="number">3</span>, <span class="string">"c"</span>: <span class="number">4</span>]) &#123; (current, <span class="number">_</span>) <span class="keyword">in</span> current &#125;</span><br><span class="line"><span class="comment">// 更新字典，如果有重复的，保留原有的key和value</span></span><br><span class="line">dictionary.merge([<span class="string">"a"</span>: <span class="number">5</span>, <span class="string">"d"</span>: <span class="number">6</span>]) &#123; (<span class="number">_</span>, new) <span class="keyword">in</span> new &#125;</span><br><span class="line"><span class="comment">// 更新字典，如果有重复的，更新旧的value</span></span><br><span class="line"><span class="keyword">for</span> (name,path) <span class="keyword">in</span> characters &#123;  <span class="comment">// 遍历字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(name) and \(path)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letters = <span class="string">"abracadabra"</span></span><br><span class="line"><span class="keyword">let</span> letterCount = letters.<span class="built_in">reduce</span>(into: [:]) &#123; counts, letter <span class="keyword">in</span></span><br><span class="line">counts[letter, <span class="keyword">default</span>: <span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计字母频率</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> numberSum = numbers.<span class="built_in">reduce</span>(<span class="number">0</span>, &#123; x, y <span class="keyword">in</span></span><br><span class="line">x + y</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 求数组元素和</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Data Structures</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>数据结构</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>周二实验剧场：搭建个人Leanote云笔记本</title>
    <url>/2019/02/27/Tuesday-lab-leanote/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>参数类型</th>
<th>操作计算机</th>
<th>服务器计算机</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>MacBookPro</td>
<td>阿里云服务器ECS</td>
</tr>
<tr>
<td>CPU</td>
<td>Intel i5-8259U</td>
<td>1核</td>
</tr>
<tr>
<td>Memory</td>
<td>8192MiB</td>
<td>2 GB</td>
</tr>
<tr>
<td>OS</td>
<td>macOS Mojave 10.14.3</td>
<td>CentOS 7.3 64位</td>
</tr>
<tr>
<td>信息来源</td>
<td>neofetch</td>
<td>阿里云云服务器管理控制台</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>搭建个人Leanote云笔记本</p>
<p>文章内容<a href="https://cloud.tencent.com/developer/labs/lab/10171" target="_blank" rel="noopener">来自</a><strong>腾讯云 开发者实验室</strong>——<strong>搭建个人Leanote云笔记本</strong></p>
</blockquote>
<a id="more"></a>
<h1 id="准备MongoDB"><a href="#准备MongoDB" class="headerlink" title="准备MongoDB"></a>准备MongoDB</h1><p>Leanote依赖MongoDB作为数据储存。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先应该<a href="https://docs.mongodb.com/manual/installation/#mongodb-supported-platforms" target="_blank" rel="noopener">查看</a>使用的服务器的操作系统是否是MongoDB支持的平台。</p>
<p>然后选择相应的方式安装MongoDB至你的服务器。</p>
<p>笔者由于是CentOS的操作系统，因此没什么兼容问题。</p>
<p>笔者选择上传MongoDB的源文件。</p>
<p>具体操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[下载] --&gt; B[解压]</span><br><span class="line">B --&gt; C((上传))</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mongod --bind_ip localhost --port 27017 --dbpath /data/db/ --logpath=/var/<span class="built_in">log</span>/mongod.log --fork</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里笔者在/home路径下新建了一个data文件夹，然后在/data/home路径下新建了db文件夹。</p>
</blockquote>
<hr>
<h1 id="安装Leanote"><a href="#安装Leanote" class="headerlink" title="安装Leanote"></a>安装Leanote</h1><p><a href="https://leanote.com" target="_blank" rel="noopener">Leanote</a>在<a href="https://github.com/leanote/leanote" target="_blank" rel="noopener">Github</a>上开源，相关内容可以点击查看。</p>
<p>那么开始安装：</p>
<p>由于笔者已经在服务器上配置过ftp了，那么这里选择手动上传<a href="http://leanote.org/#download" target="_blank" rel="noopener">安装包</a>的方式。</p>
<p>亦可以从<a href="https://github.com/leanote/leanote/wiki/Leanote-source-installation-on-Mac-and-Linux-(En" target="_blank" rel="noopener">Github</a>)上找到使用源的安装方式。</p>
<p>具体操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[下载] --&gt; B[解压]</span><br><span class="line">B --&gt; C((上传))</span><br></pre></td></tr></table></figure>
<h2 id="配置Leanote"><a href="#配置Leanote" class="headerlink" title="配置Leanote"></a>配置Leanote</h2><h3 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h3><p>确保在Leanote安装目录下，键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim leanote/conf/appconf</span><br></pre></td></tr></table></figure>
<p>修改<code>app.secret=</code>这一项，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">app.secret=qcloud666</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据Leanote官方的要求，这里需要自定义设置来保障安全。</p>
</blockquote>
<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>确保在Leanote安装目录下，键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mongorestore -h localhost -d leanote --dir /home/leanote/mongodb_backup/leanote_install_data/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中dir的位置必须对应绝对位置</p>
</blockquote>
<hr>
<h1 id="启动Leanote"><a href="#启动Leanote" class="headerlink" title="启动Leanote"></a>启动Leanote</h1><h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><p>在Leanote的bin目录下，键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash run.sh</span><br></pre></td></tr></table></figure>
<p>出现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Listening on.. 0.0.0.0:9000</span><br></pre></td></tr></table></figure>
<p>则启动成功。</p>
<p>只要在服务器安全组和防火墙开放9000端口就可以正常访问了。</p>
<h2 id="外网连接"><a href="#外网连接" class="headerlink" title="外网连接"></a>外网连接</h2><p>购买域名并添加地址映射或者直接使用IP地址访问服务器，记得添加端口号。</p>
]]></content>
      <categories>
        <category>周二实验剧场</category>
        <category>APP</category>
      </categories>
      <tags>
        <tag>周二实验剧场</tag>
        <tag>APP</tag>
      </tags>
  </entry>
  <entry>
    <title>SCNMaterialProperty</title>
    <url>/2018/12/11/SCNMaterialProperty/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用于储存显示一种材料的视觉特性的颜色或纹理的容器</p>
<p>一种材料有几个视觉特性，共同决定了它在光照和阴影下的外观。SceneKit通过将来自材质属性的信息与灯光的位置、强度和颜色相结合来呈现场景中的每个像素。</p>
<p>材质属性的内容可以是一种颜色，它提供了横跨材质表面的统一效果；也可以是一种纹理，SceneKit使用材质所附的几何对象提供的纹理坐标，将其映射到材质表面。反过来，纹理可以来自任何的几个来源，如图像对象、一个图像文件的URL、一套专门格式的图像或图像作为一个立方体地图、甚至动画内容核心提供的动画、SpriteKit、或AVFoundation-for全部选项，请参阅contents属性。</p>
<blockquote>
<p>内容均翻译自 <a href="https://developer.apple.com/documentation" target="_blank" rel="noopener">apple developer documentation</a></p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>通常，在使用第三方创作工具创建3D资产时，您将纹理图像与材料相关联，而包含这些资产的场景文件引用外部图像文件。为了在应用程序包中传递资产时获得最好的结果，将场景文件放置在扩展名为.scnassets的文件夹中，并将作为这些场景纹理引用的图像文件放置在资产目录中。<br>然后Xcode优化场景和纹理资源，以便在每个目标设备上获得最佳性能，并为交付特性(如应用程序细化和按需资源)准备纹理资源。</p>
</blockquote>
<p>SceneKit以不同的方式为材质的每个可视属性使用材质属性的contents对象。例如:</p>
<p>当你为漫反射属性提供一种颜色时，它决定了材质的基本颜色几何图形，当材质被白光照射时，它会以这种颜色的渐变出现阴影。如果您提供一个图像，SceneKit将图像映射到几何图形的表面，而不是使用统一的底色进行着色。</p>
<p>当您为高光属性提供一种颜色时，它会影响从使用该材料的几何图形表面直接反射到查看器的光的颜色。如果你提供一个灰度图像，它决定了材料的趋势，以反射光直接向观众在图像中较亮的像素，使这些区域的材料显得更闪亮，和较暗的像素使材料显得更哑光。</p>
<p>法线属性指定表面在每个点的方向。默认情况下，材质是均匀光滑的，因此为这个属性指定颜色没有任何用处。相反，您可以为该属性指定一个描述曲面轮廓的图像。SceneKit在照明中使用了这张图像(称为法线贴图)，创建了一个复杂的、凹凸不平的表面的错觉，而不会增加几何图形的复杂性。</p>
<p>有关每个可视化属性及其内容如何影响材料外观的详细信息，请参见SCNMaterial。</p>
<p>SceneKit还在其他地方使用SCNMaterialProperty对象:</p>
<p>为了提供要在场景后呈现的内容，在SCNScene对象的后台属性中，</p>
<p>在SCNLight对象的gobo属性中，影响光源照明的颜色和形状。</p>
<p>在符合SCNShadable协议的类中，将纹理采样器绑定到自定义GLSL着色器源代码片段。</p>
<hr>
<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(contents: <span class="type">Any</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="处理物理性质的信息"><a href="#处理物理性质的信息" class="headerlink" title="处理物理性质的信息"></a>处理物理性质的信息</h1><blockquote>
<p>Working with Material Property Contents</p>
</blockquote>
<h2 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contents: <span class="type">Any</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>对于每个可视化属性及其内容如何影响材料外观，请参见SCNMaterial<br>contents的内容可以是下列的任意一种：</p>
<ul>
<li>颜色 (NSColor/UIColor or CGColor)，指定材料表面的统一颜色</li>
<li>数字 (NSNumber)，为材料的表面指定一个统一的标量值(用于基于物理的属性，如金属度-metalness)</li>
<li>图片 (NSImage/UIImage or CGImage)，指定要映射到材质表面的纹理</li>
<li>指定图像文件位置的NSString或NSURL对象</li>
<li>视频播放器(AVPlayer)或实时视频捕捉预览(AVCaptureDevice，仅限iOS)</li>
<li>Core Animation 层 (CALayer)</li>
<li>纹理 (SKTexture, MDLTexture, MTLTexture, or GLKTextureInfo)</li>
<li>SpriteKit场景(SKScene)</li>
<li>一种特殊格式的图像或由六个图像组成的数组，用于指定立方体映射的面</li>
</ul>
<p>当您检查从文件中加载的场景元素时，这个值总是一个color对象(根据平台，是NSColor或UIColor类的)或一个image对象(根据平台，是NSImage或UIImage类的)。因此，您可以使用类型自省(Objective-C中的isKind(of:)方法，或者Swift中的is操作符或let-as匹配)来确定material属性内容的类型。</p>
<h3 id="Using-Animated-Content"><a href="#Using-Animated-Content" class="headerlink" title="Using Animated Content"></a>Using Animated Content</h3><p>在ios11中，你可以使用AVCaptureDevice对象作为一个材质属性来预览来自捕获设备的实时视频。在ios11、tvos11和macOS 10.13中，您可以使用AVPlayer对象作为视频播放的材料属性。</p>
<p>您可以指定任何核心动画层作为material属性的内容，例如具有动画子层层次结构的层。SceneKit不能使用已经在其他地方显示的层(例如，UIView对象的支持层)。</p>
<p>您可以使用SpriteKit框架为material属性提供静态或动画内容。SpriteKit提供了生成和修改纹理图像的选项，例如generatingNormalMap()方法。您还可以使用整个动画SpriteKit场景作为材质属性的内容。当您使用SKTexture对象作为材质属性的内容时，wrapS、wrapT、contentsTransform、minificationFilter、magniationfilter和mipFilter属性将自动更新，以匹配SpriteKit纹理的相应特性。</p>
<p>如果当前内容是纯色，则可以使用显式或隐式动画(请参见Animating SceneKit内容)更改为另一种颜色，从而创建在两种颜色之间淡入的效果。使用动画从其他内容类型转换到其他内容类型会导致瞬时转换——对于纹理内容类型(或者本身就是动画的类型)之间的动画转换，创建一个着色器修饰符(参见SCNShadable)。</p>
<h3 id="Using-Cube-Map-Texures"><a href="#Using-Cube-Map-Texures" class="headerlink" title="Using Cube Map Texures"></a>Using Cube Map Texures</h3><p>SceneKit仅支持用于材质的反射属性或场景背景或lightingEnvironment属性的立方体映射。您可以以下表中描述的任何一种方式提供多维数据集映射。在这些格式中，垂直条提供了最好的性能，因为它匹配SceneKit用于呈现立方体纹理的内存布局。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Description</th>
<th>Image Size Requirements</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vertical strip (single image)</td>
<td>height == 6 * width</td>
<td><img src="/2018/12/11/SCNMaterialProperty/scenekitcubemap_column_2x_e2dc2b5c-52c2-4c85-8ce0-9f07ff4f01c4.png" alt="img"></td>
</tr>
<tr>
<td>Horizontal strip (single image)</td>
<td>6 * height == width</td>
<td><img src="/2018/12/11/SCNMaterialProperty/scenekitcubemap_row_2x_fc38741d-bcd9-4c53-9854-6077c3ea9635.png" alt="img"></td>
</tr>
<tr>
<td>Spherical projection (single image)<br>(pixel x/y positions map to latitude/longitude coordinates on a sphere)</td>
<td>2 * height == width</td>
<td><img src="/2018/12/11/SCNMaterialProperty/scenekitcubemap_latlong_2x_54c3929d-ac29-4a27-b78b-0097e31fddfb.png" alt="img"></td>
</tr>
<tr>
<td>Array of six images<br>(face order: +X, -X, +Y, -Y, +Z, -Z)</td>
<td>height == width<br>same size for all images</td>
<td>[<img src="/2018/12/11/SCNMaterialProperty/scenekitcubemap_1_2x_c94df0c7-ab3c-40f9-bd74-909ea31aee6a-20181210232114500.png" alt="img"> \</td>
<td><img src="/2018/12/11/SCNMaterialProperty/scenekitcubemap_2_2x_c1495ba2-d942-47f8-a5ca-b8c0cd572337-20181210232200247.png" alt="img"> \</td>
<td><img src="/2018/12/11/SCNMaterialProperty/scenekitcubemap_3_2x_f061c6dc-ee6b-464e-a9ca-cbb1481a4af3-20181210232222920.png" alt="img"> \</td>
<td><img src="/2018/12/11/SCNMaterialProperty/scenekitcubemap_4_2x_3ff87a0a-f5a2-4428-a2e4-ba957aa20a1e-20181210232234104.png" alt="img"> \</td>
<td><img src="/2018/12/11/SCNMaterialProperty/scenekitcubemap_5_2x_01471007-ccce-46e8-8e79-b09d569fb8ab-20181210232242931.png" alt="img"> \</td>
<td><img src="/2018/12/11/SCNMaterialProperty/scenekitcubemap_6_2x_0fbe1e8c-b044-43eb-8ea8-fdd7f2c9c189-20181210232251622.png" alt="img">]</td>
</tr>
</tbody>
</table>
</div>
<h2 id="intensity"><a href="#intensity" class="headerlink" title="intensity"></a>intensity</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intensity: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>默认强度是1.0。降低强度会淡出材质属性的内容，根据所代表的SCNMaterial对象的视觉属性，会产生不同的效果:</p>
<p>对于法向特性，强度改变法向映射表面的表观粗糙度。降低强度使表面看起来更光滑。</p>
<p>对于倍增特性，降低强度将材料特性的颜色与白色混合，有效降低了颜色倍增效应的强度。</p>
<p>对于所有其他性能，降低强度会降低材料性能的含量。</p>
<p>您可以对该属性的值进行动画更改。参见Animating SceneKit Content</p>
<hr>
<h1 id="配置纹理映射属性"><a href="#配置纹理映射属性" class="headerlink" title="配置纹理映射属性"></a>配置纹理映射属性</h1><blockquote>
<p>配置纹理映射属性</p>
</blockquote>
<h2 id="var-contentsTransform-SCNMatrix4"><a href="#var-contentsTransform-SCNMatrix4" class="headerlink" title="var contentsTransform: SCNMatrix4"></a>var contentsTransform: SCNMatrix4</h2><blockquote>
<p>The transformation applied to the material property’s visual contents. Animatable.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contentsTransform: <span class="type">SCNMatrix4</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>SceneKit将此转换应用于材质所附的几何对象提供的纹理坐标，然后使用得到的坐标映射材质属性在材质表面的内容。(如果material属性的contents对象是常量颜色，则此转换无效。)</p>
<p>例如，您可以使用此属性来增长、偏移或旋转相对于材质表面的纹理，如下所示。</p>
<p><img src="/2018/12/11/SCNMaterialProperty/22c269c6-f7ea-474a-a6bd-d7a49d88aa92.png" alt="img"></p>
<p>您可以对该属性的值进行动画更改。参见Animating SceneKit Content</p>
<h2 id="var-wrapS-SCNWrapMode"><a href="#var-wrapS-SCNWrapMode" class="headerlink" title="var wrapS: SCNWrapMode"></a>var wrapS: SCNWrapMode</h2><blockquote>
<p>The wrapping behavior for the S texture coordinate.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wrapS: <span class="type">SCNWrapMode</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>包装模式决定了材质纹理坐标超出0.0到1.0范围的情况下的纹理映射行为。例如，如果您使用contentsTransform属性来收缩相对于几何图形表面的纹理，那么您将使用wrap模式属性来确定纹理是否在表面上重复。</p>
<p>S纹理坐标测量纹理图像的水平轴，从图像左边缘的0.0增加到右边缘的1.0。</p>
<p>默认的包装模式是SCNWrapMode.clamp。请参阅SCNWrapMode了解可用模式及其效果。</p>
<h2 id="var-wrapT-SCNWrapMode"><a href="#var-wrapT-SCNWrapMode" class="headerlink" title="var wrapT: SCNWrapMode"></a>var wrapT: SCNWrapMode</h2><blockquote>
<p>The wrapping behavior for the T texture coordinate.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wrapT: <span class="type">SCNWrapMode</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>包装模式决定了材质纹理坐标超出0.0到1.0范围的情况下的纹理映射行为。例如，如果您使用contentsTransform属性来收缩相对于几何图形表面的纹理，那么您将使用wrap模式属性来确定纹理是否在表面上重复。</p>
<p>纹理坐标测量纹理图像的纵轴，从图像底部的0.0增加到顶部的1.0。</p>
<p>默认的包装模式是SCNWrapMode.clamp。请参阅SCNWrapMode了解可用模式及其效果。</p>
<h2 id="enum-SCNWrapMode"><a href="#enum-SCNWrapMode" class="headerlink" title="enum SCNWrapMode"></a>enum SCNWrapMode</h2><blockquote>
<p>Modes to apply to texture wrapping, used by the <code>wrapT</code> and <code>wrapS</code> properties.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SCNWrapMode</span> : <span class="title">Int</span></span></span><br><span class="line"><span class="class">'''</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">clamp</span></span></span><br><span class="line"><span class="class">//<span class="title">Texture</span> <span class="title">coordinates</span> <span class="title">are</span> <span class="title">clamped</span> <span class="title">to</span> <span class="title">the</span> <span class="title">range</span> <span class="title">from</span> 0.0 <span class="title">to</span> 1.0, <span class="title">inclusive</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> `<span class="title">repeat</span>`</span></span><br><span class="line"><span class="class">//<span class="title">Texture</span> <span class="title">sampling</span> <span class="title">uses</span> <span class="title">only</span> <span class="title">the</span> <span class="title">fractional</span> <span class="title">part</span> <span class="title">of</span> <span class="title">texture</span> <span class="title">coordinates</span>, <span class="title">passing</span> <span class="title">through</span> <span class="title">the</span> <span class="title">range</span> <span class="title">from</span> 0.0 <span class="title">to</span> (<span class="title">but</span> <span class="title">not</span> <span class="title">including</span>) 1.0.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">clampToBorder</span></span></span><br><span class="line"><span class="class">//<span class="title">Texture</span> <span class="title">sampling</span> <span class="title">uses</span> <span class="title">texture</span> <span class="title">colors</span> <span class="title">for</span> <span class="title">coordinates</span> <span class="title">in</span> <span class="title">the</span> <span class="title">range</span> <span class="title">from</span> 0.0 <span class="title">to</span> 1.0 (<span class="title">inclusive</span>) <span class="title">and</span> <span class="title">the</span> <span class="title">material</span> <span class="title">property</span>’<span class="title">s</span> <span class="title">borderColor</span> <span class="title">value</span> <span class="title">otherwise</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">mirror</span></span></span><br><span class="line"><span class="class">//<span class="title">Texture</span> <span class="title">sampling</span> <span class="title">of</span> <span class="title">texture</span> <span class="title">coordinates</span> <span class="title">outside</span> <span class="title">range</span> <span class="title">from</span> 0.0 <span class="title">to</span> 1.0 <span class="title">should</span> <span class="title">behave</span> <span class="title">as</span> <span class="title">if</span> <span class="title">the</span> <span class="title">range</span> <span class="title">reverses</span> <span class="title">before</span> <span class="title">repeating</span>.</span></span><br><span class="line"><span class="class">'''</span></span><br></pre></td></tr></table></figure>
<p>包装模式决定了材质纹理坐标超出0.0到1.0范围的情况下的纹理映射行为。例如，如果您使用contentsTransform属性来收缩相对于几何图形表面的纹理，那么您将使用wrap模式属性来确定纹理是否在表面上重复。下图显示了每种包装模式对其他相同材料的影响。</p>
<p><img src="/2018/12/11/SCNMaterialProperty/a708d857-d063-472e-96ca-70976eb62c49.png" alt="img"></p>
<h2 id="var-minificationFilter-SCNFilterMode"><a href="#var-minificationFilter-SCNFilterMode" class="headerlink" title="var minificationFilter: SCNFilterMode"></a>var minificationFilter: SCNFilterMode</h2><blockquote>
<p>Texture filtering for rendering the material property’s image contents at a size smaller than that of the original image.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minificationFilter: <span class="type">SCNFilterMode</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="var-magnificationFilter-SCNFilterMode"><a href="#var-magnificationFilter-SCNFilterMode" class="headerlink" title="var magnificationFilter: SCNFilterMode"></a>var magnificationFilter: SCNFilterMode</h2><blockquote>
<p>Texture filtering for rendering the material property’s image contents at a size larger than that of the original image.</p>
</blockquote>
<p>当材质表面的某些部分看起来比原始纹理图像大或小时，纹理过滤决定材质属性内容的外观。例如，纹理坐标在远离摄像机的一点可能对应于纹理图像中几个像素的区域。SceneKit使用缩小过滤器来确定采样texel在该点的颜色。</p>
<p>默认的缩小过滤器是scnfilter.linear。请参阅SCNWrapMode了解可用模式及其效果。</p>
<h2 id="var-mipFilter-SCNFilterMode"><a href="#var-mipFilter-SCNFilterMode" class="headerlink" title="var mipFilter: SCNFilterMode"></a>var mipFilter: SCNFilterMode</h2><blockquote>
<p>Texture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> magnificationFilter: <span class="type">SCNFilterMode</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当材质表面的某些部分看起来比原始纹理图像大或小时，纹理过滤决定材质属性内容的外观。例如，在摄像机附近的一个点上的纹理坐标可能对应于纹理图像中像素的一小部分。SceneKit使用放大过滤器来确定采样texel在该点的颜色。</p>
<p>默认的放大过滤器是scnfilter.linear。请参阅SCNWrapMode了解可用模式及其效果。</p>
<h2 id="enum-SCNFilterMode"><a href="#enum-SCNFilterMode" class="headerlink" title="enum SCNFilterMode"></a>enum SCNFilterMode</h2><blockquote>
<p>Texture filtering modes, used by the <code>minificationFilter</code>,<code>magnificationFilter</code>, and <code>mipFilter</code> properties.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SCNFilterMode</span> : <span class="title">Int</span></span></span><br><span class="line"><span class="class">'''</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">none</span></span></span><br><span class="line"><span class="class">//<span class="title">No</span> <span class="title">texture</span> <span class="title">filtering</span> <span class="title">is</span> <span class="title">applied</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">nearest</span></span></span><br><span class="line"><span class="class">//<span class="title">Texture</span> <span class="title">filtering</span> <span class="title">returns</span> <span class="title">the</span> <span class="title">color</span> <span class="title">from</span> <span class="title">only</span> <span class="title">one</span> <span class="title">texel</span>, <span class="title">whose</span> <span class="title">location</span> <span class="title">is</span> <span class="title">nearest</span> <span class="title">to</span> <span class="title">the</span> <span class="title">coordinates</span> <span class="title">being</span> <span class="title">sampled</span>.</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">linear</span></span></span><br><span class="line"><span class="class">//<span class="title">Texture</span> <span class="title">filtering</span> <span class="title">sample</span> <span class="title">texels</span> <span class="title">from</span> <span class="title">the</span> <span class="title">neighborhood</span> <span class="title">of</span> <span class="title">the</span> <span class="title">coordinates</span> <span class="title">being</span> <span class="title">sampled</span> <span class="title">and</span> <span class="title">linearly</span> <span class="title">interpolates</span> <span class="title">their</span> <span class="title">colors</span>.</span></span><br><span class="line"><span class="class">'''</span></span><br></pre></td></tr></table></figure>
<p>当材质表面的某些部分看起来比原始纹理图像大或小时，纹理过滤决定材质属性内容的外观。例如，当纹理被应用到一个远离相机的平面上时:</p>
<p>在相机附近的一个点的纹理坐标可以对应原始图像中一个像素的一小部分。SceneKit使用放大率过滤器属性来确定采样后的texel的颜色。</p>
<p>纹理坐标在远离摄像机的一点可能对应于原始图像中几个像素的区域。SceneKit使用minificationFilter属性来确定采样texel的颜色。</p>
<p>SceneKit还在为纹理图像生成mipmap级别时使用mipFilter属性指定的过滤器。</p>
<h2 id="var-maxAnisotropy-CGFloat"><a href="#var-maxAnisotropy-CGFloat" class="headerlink" title="var maxAnisotropy: CGFloat"></a>var maxAnisotropy: CGFloat</h2><blockquote>
<p>The amount of anisotropic texture filtering to be used when rendering the material property’s image contents.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxAnisotropy: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>各向异性滤波是一种提高纹理呈现质量的过程，当纹理表面出现一个相对于相机的极端角度。这个过程通过从纹理的多个mipmap级别对每个呈现的像素进行采样来完成——各向异性是指每个像素的采样数量。各向异性越高，渲染质量越好，但渲染性能越差。</p>
<p>例如，下图左边的图像没有使用各向异性滤波，导致在棋盘模式后退到一定距离时呈现工件。其他图像使用更高的maxAnisotropy值，减少了呈现伪影。各向异性滤波需要mipmap，因此只有当mipFilter属性的值不是scnfilter.none时，该属性才生效。</p>
<p><img src="/2018/12/11/SCNMaterialProperty/5a2465a2-a8ab-42ae-9f73-bf6c1af20af2.png" alt="img"></p>
<p>SceneKit会根据需要自动增加或减少每个渲染像素的各向异性，以最大限度地提高渲染质量，直到该属性指定的限制。绘制时所使用的最大各向异性电平取决于所使用的图形硬件。将此属性的值设置为MAXFLOAT常量(默认值)，以使用GPU支持的最高各向异性级别。最大各向异性值为1.0或更低将禁用各向异性过滤。</p>
<h2 id="var-mappingChannel-Int"><a href="#var-mappingChannel-Int" class="headerlink" title="var mappingChannel: Int"></a>var mappingChannel: Int</h2><blockquote>
<p>The source of texture coordinates for mapping the material property’s image contents.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mappingChannel: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>
<p>一个几何图形可以有多个独立的纹理坐标来源，每个来源都定义一个唯一的映射通道号。您可以使用这些通道以不同的方式映射材料的不同视觉属性。例如，表示图片框的几何图形可以使用一组纹理坐标来映射图片本身的材质，而另一组纹理坐标可以将图片放到图片框中。</p>
<p>有关使用多个纹理映射通道创建几何图形的信息，请参见SCNGeometry。</p>
<hr>
]]></content>
      <categories>
        <category>Swift</category>
        <category>SceneKit</category>
        <category>SCNMaterialProperty</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SceneKit</tag>
        <tag>SCNMaterialProperty</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 动画学习——《A GUIDE TO IOS ANIMATION 2.0》学习笔记</title>
    <url>/2019/01/15/UIAnmations-with-Swift/</url>
    <content><![CDATA[<blockquote>
<p>文章内容均来自于<strong>KittenYang</strong> 这是他的<a href="https://github.com/KittenYang" target="_blank" rel="noopener">github</a>主页<a href="https://github.com/KittenYang" target="_blank" rel="noopener">https://github.com/KittenYang</a></p>
<p>由于书本本身是由object-c代码写的，同时正巧我正在学习iOS Animation部分来丰富UI界面的设计技术因此记录下自己的学习轨迹以及自己对于Swift的理解，希望能够帮助到以Swift为起点的iOSer。</p>
</blockquote>
<p>UI设计，尤其是UI的动画设计十分有趣且富有创造性和挑战性。</p>
<p>它需要的不仅仅是纯coding方面的技能，因此还包含了一个人的艺术能力、设计能力、对代码的绝对熟悉程度(使用合适的代码来完成相应的功能，而Swift语言在UI方面有许多技术点)、以及想象力(将脑海中的或者视觉效果图转化成相应需要的功能甚至是技术点等)</p>
<a id="more"></a>
<h1 id="Bezier-Curve"><a href="#Bezier-Curve" class="headerlink" title="Bézier Curve"></a>Bézier Curve</h1><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>本部分将以贝塞尔曲线为主体完成类似于以下gif的效果：</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/gooeyCircle-3384745.gif" alt="gooeyCircle"></p>
<hr>
<h2 id="ch-1-初识Bezier-Curve"><a href="#ch-1-初识Bezier-Curve" class="headerlink" title="ch-1 初识Bézier Curve"></a>ch-1 初识Bézier Curve</h2><h3 id="起源和应用"><a href="#起源和应用" class="headerlink" title="起源和应用"></a>起源和应用</h3><p>在数学的数值分析领域中，贝塞尔曲线（英语：Bézier curve，亦作“贝塞尔”）是计算机图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝兹曲面，其中贝兹三角是一种特殊的实例。</p>
<p>贝塞尔曲线于1962年，由法国工程师皮埃尔·贝兹（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由保尔·德·卡斯特里奥于1959年运用德卡斯特里奥算法开发，以稳定数值的方法求出贝塞尔曲线。</p>
<p>由于需要点阵化更精细的分辨率时，重新插值（补点）的计算量较小，贝塞尔曲线被广泛地在计算机图形中用来为平滑曲线建立模型。贝塞尔曲线是矢量图形文件和相应软件（如PostScript、PDF等）能够处理的唯一曲线，用于光滑地近似其他曲线。其中，二次和三次贝塞尔曲线最为常用。</p>
<hr>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="线性贝塞尔曲线"><a href="#线性贝塞尔曲线" class="headerlink" title="线性贝塞尔曲线"></a>线性贝塞尔曲线</h4><p>给定点P0、P1，线性贝塞尔曲线只是一条两点之间的直线。这条线由下式给出：</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/99f09ec6ec6e08747a87600d769f1e08c1f05f00" alt="{\mathbf  {B}}(UIAnmations-with-Swift/99f09ec6ec6e08747a87600d769f1e08c1f05f00)={\mathbf  {P}}_{0}+({\mathbf  {P}}_{1}-{\mathbf  {P}}_{0})t=(1-t){\mathbf  {P}}_{0}+t{\mathbf  {P}}_{1}{\mbox{ , }}t\in [0,1]"><br>且其等同于线性插值。</p>
<h4 id="二次方贝塞尔曲线"><a href="#二次方贝塞尔曲线" class="headerlink" title="二次方贝塞尔曲线"></a>二次方贝塞尔曲线</h4><p>二次方贝塞尔曲线的路径由给定点P0、P1、P2的函数B（t）追踪：</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d28ed03475106564d4a959647acb2b7fa34935ef" alt="{\mathbf  {B}}(UIAnmations-with-Swift/d28ed03475106564d4a959647acb2b7fa34935ef)=(1-t)^2{\mathbf  {P}}_{0}+2t(1-t){\mathbf  {P}}_{1}+t^2{\mathbf  {P}}_{2}{\mbox{ , }}t\in [0,1]"><br>TrueType字型就运用了以贝兹样条组成的二次贝塞尔曲线。</p>
<h4 id="三次方贝塞尔曲线"><a href="#三次方贝塞尔曲线" class="headerlink" title="三次方贝塞尔曲线"></a>三次方贝塞尔曲线</h4><p>P0、P1、P2、P3四个点在平面或在三维空间中定义了三次方贝塞尔曲线。曲线起始于P0走向P1，并从P2的方向来到P3。一般不会经过P1或P2；这两个点只是在那里提供方向资讯。P0和P1之间的间距，决定了曲线在转而趋进P2之前，走向P1方向的“长度有多长”。</p>
<p>曲线的参数形式为：</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/671f651757c2e7efb48da5801e835d3cafe4eeba" alt="{\mathbf  {B}}(UIAnmations-with-Swift/671f651757c2e7efb48da5801e835d3cafe4eeba)={\mathbf  {P}}_{0}(1-t)^{3}+3{\mathbf  {P}}_{1}t(1-t)^{2}+3{\mathbf  {P}}_{2}t^{2}(1-t)+{\mathbf  {P}}_{3}t^{3}{\mbox{ , }}t\in [0,1]"><br>现代的成象系统，如PostScript、Asymptote和Metafont，运用了以贝兹样条组成的三次贝塞尔曲线，用来描绘曲线轮廓。</p>
<hr>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="线性曲线"><a href="#线性曲线" class="headerlink" title="线性曲线"></a>线性曲线</h4><p>线性贝塞尔曲线函数中的<em>t</em>会经过由<strong>P</strong>0至<strong>P</strong>1的<strong>B</strong>（<em>t</em>）所描述的曲线。例如当<em>t=0.25</em>时，<strong>B</strong>（<em>t</em>）即一条由点<strong>P</strong>0至<strong>P</strong>1路径的四分之一处。就像由0至1的连续<em>t</em>，<strong>B</strong>（<em>t</em>）描述一条由<strong>P</strong>0至<strong>P</strong>1的直线。</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/Bezier_1_big-3381562.gif" alt="Bezier_1_big"></p>
<h4 id="二次曲线"><a href="#二次曲线" class="headerlink" title="二次曲线"></a>二次曲线</h4><p>为建构二次贝塞尔曲线，可以中介点<strong>Q</strong>0和<strong>Q</strong>1作为由0至1的<em>t</em>：</p>
<ul>
<li>由<strong>P</strong>0至<strong>P</strong>1的连续点<strong>Q</strong>0，描述一条线性贝塞尔曲线。</li>
<li>由<strong>P</strong>1至<strong>P</strong>2的连续点<strong>Q</strong>1，描述一条线性贝塞尔曲线。</li>
<li>由<strong>Q</strong>0至<strong>Q</strong>1的连续点<strong>B</strong>（<em>t</em>），描述一条二次贝塞尔曲线。</li>
</ul>
<p><img src="/2019/01/15/UIAnmations-with-Swift/Bezier_2_big-3381619.gif" alt="Bezier_2_big"></p>
<h4 id="高阶曲线"><a href="#高阶曲线" class="headerlink" title="高阶曲线"></a>高阶曲线</h4><p>为建构高阶曲线，便需要相应更多的中介点。对于三次曲线，可由线性贝塞尔曲线描述的中介点<strong>Q</strong>0、<strong>Q</strong>1、<strong>Q</strong>2，和由二次曲线描述的点<strong>R</strong>0、<strong>R</strong>1所建构：</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/Bezier_3_big-3381685.gif" alt="Bezier_3_big"></p>
<p>对于四次曲线，可由线性贝塞尔曲线描述的中介点<strong>Q</strong>0、<strong>Q</strong>1、<strong>Q</strong>2、<strong>Q</strong>3，由二次贝塞尔曲线描述的点<strong>R</strong>0、<strong>R</strong>1、<strong>R</strong>2，和由三次贝塞尔曲线描述的点<strong>S</strong>0、<strong>S</strong>1所建构：</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/Bezier_4_big-3381711.gif" alt="Bezier_4_big"></p>
<p>还可参阅五阶贝塞尔曲线的构成：</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/BezierCurve-3381729.gif" alt="BezierCurve"></p>
<p>这些运动轨迹使用de Casteljau算法计算出贝塞尔曲线。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A#%E5%AF%A6%E4%BE%8B%E8%AA%AA%E6%98%8E" target="_blank" rel="noopener">维基百科：贝塞尔曲线</a></p>
</blockquote>
<hr>
<h2 id="ch-2-实例：MeliceraCircle"><a href="#ch-2-实例：MeliceraCircle" class="headerlink" title="ch-2 实例：MeliceraCircle"></a>ch-2 实例：MeliceraCircle</h2><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p><img src="/2019/01/15/UIAnmations-with-Swift/ch2.gif" alt="ch2"></p>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>首先，以贝塞尔曲线解析红色小球是如何构成的：</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/2390274-4dfc08fc94489a70.png" alt="2390274-4dfc08fc94489a70"></p>
<p>可以看到，小球由四个基准点与8个控制点(control point)组成：弧AB（cp：c1、c2）、弧BC（cp：c3、c4）、弧CD（cp：c5、c6）、弧DA（cp：c7、c8）</p>
<p>依据贝塞尔曲线的定义和绘制原理，通过改变这些点来改变弧的形状从而改变小球的形状</p>
<p>为了方便计算点的坐标，引入一个外接矩形以辅助</p>
<p>这里，将定义一个名为<code>CircleLayer</code>的类，它继承自<code>CALayer</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleLayer</span>:<span class="title">CALayer</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>同时需要一些基准来约束和辅助</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MovingPoint</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">POINT_B</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">POINT_D</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> outsideRectSize:<span class="type">CGFloat</span> = <span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>那么我们将采取绘制的手段将我们的小球绘制在<code>UIView</code>上(addSublayer)，当然这是之后的工作</p>
<p>依据<code>CALayer</code>这个类的特性，通过重写<code>draw(in ctx: CGContext)</code>和调用<code>setNeedsDisplay()</code>来达到更新我们的绘制</p>
<h4 id="具体的代码如下："><a href="#具体的代码如下：" class="headerlink" title="具体的代码如下："></a>具体的代码如下：</h4><p>首先，声明一些变量作为储存属性记录需要的信息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> outsideRect:<span class="type">CGRect</span>! <span class="comment">// 记录外接矩形的信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> currentProgress:<span class="type">CGFloat</span> = <span class="number">0.5</span> <span class="comment">// 记录当前的变形进度，以0.5为中值(圆形)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> movePoint:<span class="type">MovingPoint</span>! <span class="comment">// 记录当前移动的点(方向)</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，这里的变量都被添加了<code>private</code>作为读取的权限约束</p>
<p>其次，声明一个名为<code>progress</code>的计算属性，以便于改变小球外形时只需要更新这个属性即可，而不是通过函数(不适合)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> progress:<span class="type">CGFloat</span> = <span class="number">0.0</span> &#123;</span><br><span class="line"><span class="keyword">didSet</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，将补充<code>didSet{}</code>中的内容</p>
<p>第一，计算外接矩形的尺寸</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buff = (progress - <span class="number">0.5</span>)*(frame.size.width - outsideRectSize)</span><br><span class="line"><span class="keyword">let</span> origin_x = position.x - outsideRectSize/<span class="number">2</span> + buff</span><br><span class="line"><span class="keyword">let</span> origin_y = position.y - outsideRectSize/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">self</span>.outsideRect = <span class="type">CGRect</span>(x: origin_x, y: origin_y, width: outsideRectSize, height: outsideRectSize)</span><br></pre></td></tr></table></figure>
<p>第二，判断变形的方向</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> progress &lt;= <span class="number">0.5</span> &#123;</span><br><span class="line">movePoint = .<span class="type">POINT_B</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"B点动"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">movePoint = .<span class="type">POINT_D</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"D点动"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，有了外接矩形，可以开始绘制工作了</p>
<p>先将<code>CircleLayer</code>补充完整(添加初始化)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>(layer: <span class="type">Any</span>) &#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>(layer: layer)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> layer = layer <span class="keyword">as</span>? <span class="type">CircleLayer</span> &#123;</span><br><span class="line">progress = layer.progress</span><br><span class="line">outsideRect = layer.outsideRect</span><br><span class="line">currentProgress = layer.currentProgress</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"init(code:) has not been implemented"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再添加<code>draw(in ctx: CGContext)</code>方法，并重写</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> offset = outsideRect.size.width / <span class="number">3.6</span></span><br><span class="line"><span class="keyword">let</span> movedDistance = (outsideRect.size.width * <span class="number">1</span> / <span class="number">6</span>) * <span class="built_in">abs</span>(<span class="keyword">self</span>.progress - <span class="number">0.5</span>) * <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> rectCenter = <span class="type">CGPoint</span>(x: outsideRect.origin.x + outsideRect.size.width / <span class="number">2</span>,</span><br><span class="line">y: outsideRect.origin.y + outsideRect.size.height / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pointA = <span class="type">CGPoint</span>(x: rectCenter.x,</span><br><span class="line">y: outsideRect.origin.y + movedDistance)</span><br><span class="line"><span class="keyword">let</span> pointB = <span class="type">CGPoint</span>(x: movePoint == .<span class="type">POINT_D</span> ? rectCenter.x + outsideRect.size.width / <span class="number">2</span>:rectCenter.x + outsideRect.size.width / <span class="number">2</span> + movedDistance * <span class="number">2</span>,</span><br><span class="line">y: rectCenter.y)</span><br><span class="line"><span class="keyword">let</span> pointC = <span class="type">CGPoint</span>(x: rectCenter.x,</span><br><span class="line">y: rectCenter.y + outsideRect.size.height / <span class="number">2</span> - movedDistance)</span><br><span class="line"><span class="keyword">let</span> pointD = <span class="type">CGPoint</span>(x: movePoint == .<span class="type">POINT_D</span> ? outsideRect.origin.x - movedDistance * <span class="number">2</span> : outsideRect.origin.x,</span><br><span class="line">y: rectCenter.y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp1 = <span class="type">CGPoint</span>(x: pointA.x + offset,</span><br><span class="line">y: pointA.y)</span><br><span class="line"><span class="keyword">let</span> cp2 = <span class="type">CGPoint</span>(x: pointB.x,</span><br><span class="line">y: <span class="keyword">self</span>.movePoint == .<span class="type">POINT_D</span> ? pointB.y - offset : pointB.y - offset + movedDistance)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp3 = <span class="type">CGPoint</span>(x: pointB.x,</span><br><span class="line">y: <span class="keyword">self</span>.movePoint == .<span class="type">POINT_D</span> ? pointB.y + offset : pointB.y + offset - movedDistance)</span><br><span class="line"><span class="keyword">let</span> cp4 = <span class="type">CGPoint</span>(x: pointC.x + offset,</span><br><span class="line">y: pointC.y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp5 = <span class="type">CGPoint</span>(x: pointC.x - offset,</span><br><span class="line">y: pointC.y)</span><br><span class="line"><span class="keyword">let</span> cp6 = <span class="type">CGPoint</span>(x: pointD.x,</span><br><span class="line">y: <span class="keyword">self</span>.movePoint == .<span class="type">POINT_D</span> ? pointD.y + offset - movedDistance : pointD.y + offset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp7 = <span class="type">CGPoint</span>(x: pointD.x,</span><br><span class="line">y: <span class="keyword">self</span>.movePoint == .<span class="type">POINT_D</span> ? pointD.y - offset + movedDistance : pointD.y - offset)</span><br><span class="line"><span class="keyword">let</span> cp8 = <span class="type">CGPoint</span>(x: pointA.x - offset,</span><br><span class="line">y: pointA.y)</span><br><span class="line"></span><br><span class="line"><span class="comment">//外接虚线矩形</span></span><br><span class="line"><span class="keyword">let</span> rectPath = <span class="type">UIBezierPath</span>(rect: outsideRect)</span><br><span class="line">ctx.addPath(rectPath.cgPath)</span><br><span class="line">ctx.setStrokeColor(<span class="type">UIColor</span>.black.cgColor)</span><br><span class="line">ctx.setLineWidth(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> dash = [<span class="type">CGFloat</span>(<span class="number">5.0</span>), <span class="type">CGFloat</span>(<span class="number">5.0</span>)]</span><br><span class="line">ctx.setLineDash(phase: <span class="number">0</span>, lengths: dash)</span><br><span class="line">ctx.strokePath()</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆的边界</span></span><br><span class="line"><span class="keyword">let</span> ovalPath = <span class="type">UIBezierPath</span>()</span><br><span class="line">ovalPath.move(to: pointA)</span><br><span class="line">ovalPath.addCurve(to: pointB, controlPoint1: cp1, controlPoint2: cp2)</span><br><span class="line">ovalPath.addCurve(to: pointC, controlPoint1: cp3, controlPoint2: cp4)</span><br><span class="line">ovalPath.addCurve(to: pointD, controlPoint1: cp5, controlPoint2: cp6)</span><br><span class="line">ovalPath.addCurve(to: pointA, controlPoint1: cp7, controlPoint2: cp8)</span><br><span class="line">ovalPath.close()</span><br><span class="line"></span><br><span class="line">ctx.addPath(ovalPath.cgPath)</span><br><span class="line">ctx.setStrokeColor(<span class="type">UIColor</span>.black.cgColor)</span><br><span class="line">ctx.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">ctx.setLineDash(phase: <span class="number">0</span>, lengths: [<span class="type">CGFloat</span>]())</span><br><span class="line">ctx.drawPath(using: .fillStroke)</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记出每个点并连线，方便观察，给所有关键点染色 -- 白色,辅助线颜色 -- 白色</span></span><br><span class="line">ctx.setFillColor(<span class="type">UIColor</span>.yellow.cgColor)</span><br><span class="line">ctx.setStrokeColor(<span class="type">UIColor</span>.black.cgColor)</span><br><span class="line"><span class="keyword">let</span> points = [<span class="type">NSValue</span>(cgPoint: pointA),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: pointB),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: pointC),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: pointD),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: cp1),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: cp2),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: cp3),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: cp4),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: cp5),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: cp6),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: cp7),</span><br><span class="line"><span class="type">NSValue</span>(cgPoint: cp8)]</span><br><span class="line">drawPoint(points: points, ctx: ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接辅助线</span></span><br><span class="line"><span class="keyword">let</span> helperline = <span class="type">UIBezierPath</span>()</span><br><span class="line">helperline.move(to: pointA)</span><br><span class="line">helperline.addLine(to: cp1)</span><br><span class="line">helperline.addLine(to: cp2)</span><br><span class="line">helperline.addLine(to: pointB)</span><br><span class="line">helperline.addLine(to: cp3)</span><br><span class="line">helperline.addLine(to: cp4)</span><br><span class="line">helperline.addLine(to: pointC)</span><br><span class="line">helperline.addLine(to: cp5)</span><br><span class="line">helperline.addLine(to: cp6)</span><br><span class="line">helperline.addLine(to: pointD)</span><br><span class="line">helperline.addLine(to: cp7)</span><br><span class="line">helperline.addLine(to: cp8)</span><br><span class="line">helperline.close()</span><br><span class="line"></span><br><span class="line">ctx.addPath(helperline.cgPath)</span><br><span class="line"><span class="keyword">let</span> dash2 = [<span class="type">CGFloat</span>(<span class="number">2.0</span>), <span class="type">CGFloat</span>(<span class="number">2.0</span>)]</span><br><span class="line">ctx.setLineDash(phase: <span class="number">0</span>, lengths: dash2)</span><br><span class="line">ctx.strokePath()</span><br></pre></td></tr></table></figure>
<p>其中，为了绘制圆点，需要使用<code>drawPoint</code>方法，将其添加至类中</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">drawPoint</span><span class="params">(points: [NSValue], ctx: CGContext)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pointValue <span class="keyword">in</span> points &#123;</span><br><span class="line"><span class="keyword">let</span> point = pointValue.cgPointValue</span><br><span class="line">ctx.fill(<span class="type">CGRect</span>(x: point.x - <span class="number">2</span>, y: point.y - <span class="number">2</span>, width: <span class="number">4</span>, height: <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在<code>progress</code>中的<code>didSet</code>内容的最后添加</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">setNeedsDisplay()</span><br></pre></td></tr></table></figure>
<p>为了能够更好地观察<code>CircleLayer</code>与<code>progress</code>之间的联动</p>
<p>在storyboard上添加一个<code>UILabel</code>和一个<code>UISlider</code></p>
<p>添加一个名为<code>CircleView</code>的类</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> circleLayer = <span class="type">CircleLayer</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">circleLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: frame.size.width, height: frame.size.height)</span><br><span class="line">circleLayer.contentsScale = <span class="type">UIScreen</span>.main.scale</span><br><span class="line">layer.addSublayer(circleLayer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并将<code>ViewController</code>改写为并连接对应的控件</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> progressLabel: <span class="type">UILabel</span>!</span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> slider: <span class="type">UISlider</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> circleView: <span class="type">CircleView</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">circleView = <span class="type">CircleView</span>(frame:<span class="type">CGRect</span>(x: view.frame.size.width/<span class="number">2</span> - <span class="number">320</span>/<span class="number">2</span>,</span><br><span class="line">y: view.frame.size.height/<span class="number">2</span> - <span class="number">320</span>/<span class="number">2</span>,</span><br><span class="line">width: <span class="number">320</span>,</span><br><span class="line">height: <span class="number">320</span>))</span><br><span class="line">view.addSubview(circleView)</span><br><span class="line"></span><br><span class="line">circleView.circleLayer.progress = <span class="type">CGFloat</span>(slider.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">valuechange</span><span class="params">(<span class="number">_</span> sender: UISlider)</span></span> &#123;</span><br><span class="line">progressLabel.text = <span class="string">"Current: \(sender.value)"</span></span><br><span class="line">circleView.circleLayer.progress = <span class="type">CGFloat</span>(sender.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="ch-3-实例：GooeySlideMenu"><a href="#ch-3-实例：GooeySlideMenu" class="headerlink" title="ch-3 实例：GooeySlideMenu"></a>ch-3 实例：GooeySlideMenu</h2><h3 id="预览-1"><a href="#预览-1" class="headerlink" title="预览"></a>预览</h3><p><img src="/2019/01/15/UIAnmations-with-Swift/QQ20181129-121040-HD.gif" alt="QQ20181129-121040-HD"></p>
<h3 id="How-1"><a href="#How-1" class="headerlink" title="How"></a>How</h3><p>就如同上一章节，首先要做的是拆解这个动画：</p>
<ol>
<li>点击按钮，触发点击事件</li>
<li>有一个蓝色的UIView从左侧出现</li>
<li>这个UIView的右侧边界有一个用圆弧变成直线的动画</li>
<li>并且，发生了回弹</li>
<li>点击后返回上一页面</li>
</ol>
<p>那么，和之前一样，构建一个名为<code>GooeySlideMenu</code>的类，继承自<code>UIView</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GooeySlideMenu</span>: <span class="title">UIView</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>同时，如同其他的类一样<code>GooeySlideMenu</code>也需要初始化</p>
<p>但是它很特殊，因为它一直占据你的整个屏幕，因此不需要设定它的<code>frame</code></p>
<p>尽管如此，依然需要一些额外的数据：菜单的颜色(menuColor)、模糊效果的类型(blurStyle)、菜单的宽度(menuBlankWidth)</p>
<p>将这些封装成一个结构体</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MenuOptions</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> menuColor: <span class="type">UIColor</span></span><br><span class="line"><span class="keyword">var</span> blurStyle: <span class="type">UIBlurEffect</span>.<span class="type">Style</span></span><br><span class="line"><span class="keyword">var</span> menuBlankWidth: <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体将在初始化的时候用到</p>
<h4 id="具体代码如下："><a href="#具体代码如下：" class="headerlink" title="具体代码如下："></a>具体代码如下：</h4><p>首先，完成初始化的内容</p>
<p>这里需要自定义一个初始化方法，结构如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(options: <span class="type">MenuOptions</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要用到两个属性：<code>option</code>、<code>kWindow</code>，将它们声明在类中</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> option: <span class="type">MenuOptions</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> keyWindow: <span class="type">UIWindow</span>?</span><br></pre></td></tr></table></figure>
<p>那么现在开始补充<code>init(options: MenuOptions) {}</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">option = options</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> kWindow = <span class="type">UIApplication</span>.shared.keyWindow&#123;</span><br><span class="line"><span class="comment">// 判断所需的UIWindow是否存在</span></span><br><span class="line">keyWindow = kWindow</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">let</span> frame = <span class="type">CGRect</span>(</span><br><span class="line">x: -kWindow.frame.size.width/<span class="number">2</span> - options.menuBlankWidth,</span><br><span class="line">y: <span class="number">0</span>,</span><br><span class="line">width: kWindow.frame.size.width/<span class="number">2</span> + options.menuBlankWidth,</span><br><span class="line">height: kWindow.frame.size.height)</span><br><span class="line"><span class="comment">// 计算尺寸</span></span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>(frame:frame)</span><br><span class="line"><span class="comment">// 完成父类的初始化</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 初始化无效</span></span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>(frame:<span class="type">CGRect</span>.zero)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置其他的view，再接下来补充</span></span><br><span class="line">setUpViews()</span><br></pre></td></tr></table></figure>
<p>为了让菜单能够总是在最上层不被遮挡，选择将它直接添加在UIWIndow上，也正因为如此，通过UIWindow计算frame属性</p>
<p>接下来，完成<code>setUpViews()</code>方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setUpViews</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>将它写在扩展中</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">GooeySlideMenu</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>setUpViews()</code>的内容如下：</p>
<p>这里需要额外的三个属性：<code>blurView</code>、<code>helperSideView</code>、<code>helperCenterView</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> blurView: <span class="type">UIVisualEffectView</span>!</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> helperSideView: <span class="type">UIView</span>!</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> helperCenterView: <span class="type">UIView</span>!</span><br></pre></td></tr></table></figure>
<p>接下来就是正题</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> keyWindow = keyWindow &#123;</span><br><span class="line">blurView = <span class="type">UIVisualEffectView</span>(effect: <span class="type">UIBlurEffect</span>(style: option.blurStyle))</span><br><span class="line">blurView.frame = keyWindow.frame</span><br><span class="line">blurView.alpha = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">helperSideView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: -<span class="number">40</span>, y: <span class="number">0</span>, width: <span class="number">40</span>, height: <span class="number">40</span>))</span><br><span class="line">helperSideView.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">helperSideView.isHidden = <span class="literal">true</span></span><br><span class="line">keyWindow.addSubview(helperSideView)</span><br><span class="line"></span><br><span class="line">helperCenterView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: -<span class="number">40</span>,</span><br><span class="line">y: keyWindow.frame.height/<span class="number">2</span> - <span class="number">20</span>,</span><br><span class="line">width: <span class="number">40</span>,</span><br><span class="line">height: <span class="number">40</span>))</span><br><span class="line">helperCenterView.backgroundColor = <span class="type">UIColor</span>.yellow</span><br><span class="line">helperCenterView.isHidden = <span class="literal">true</span></span><br><span class="line">keyWindow.addSubview(helperCenterView)</span><br><span class="line"></span><br><span class="line">backgroundColor = <span class="type">UIColor</span>.clear</span><br><span class="line">keyWindow.insertSubview(<span class="keyword">self</span>, belowSubview: helperSideView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，使用两个被隐藏的视图来辅助完成右侧边界曲线在绘制时所需要的计算</p>
<p>接下来，在类中完成绘制(<code>draw(_ rect: CGRect)</code>)的方法</p>
<p>和之前，在<code>MeliceraCircle</code>中一样，通过在适当的时候执行<code>setNeedsDisplay()</code>来更新视图</p>
<p>这里需要一个属性<code>diff</code>，具体的功能会在下文阐述</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> diff: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p>具体如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br><span class="line">path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br><span class="line">path.addLine(to: <span class="type">CGPoint</span>(x: frame.width-option.menuBlankWidth, y: <span class="number">0</span>))</span><br><span class="line">path.addQuadCurve(to: <span class="type">CGPoint</span>(x: frame.width-option.menuBlankWidth,</span><br><span class="line">y: frame.height),</span><br><span class="line">controlPoint: <span class="type">CGPoint</span>(x: frame.width-option.menuBlankWidth+diff,</span><br><span class="line">y: frame.height/<span class="number">2</span>))</span><br><span class="line">path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: frame.height))</span><br><span class="line">path.close()</span><br><span class="line"><span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">context?.addPath(path.cgPath)</span><br><span class="line">option.menuColor.<span class="keyword">set</span>()</span><br><span class="line">context?.fillPath()</span><br></pre></td></tr></table></figure>
<p>菜单画面的绘制由上边界、右边界、下边界组成，其中右边界是由贝塞尔曲线构成，其他都是直线</p>
<p>接下来，需要一个方法来计算<code>diff</code></p>
<p>通过两个辅助视图(<code>helperSideView</code> <code>helperCenterView</code>)来计算，用以计算贝塞尔曲线中的控制点</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">handleDisplayLinkAction</span><span class="params">(displaylink: CADisplayLink)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> sideHelperPresentationLayer = helperSideView.layer.presentation()!</span><br><span class="line"><span class="keyword">let</span> centerHelperPresentationLayer = helperCenterView.layer.presentation()!</span><br><span class="line"><span class="comment">// 捕捉实时的layer层</span></span><br><span class="line"><span class="keyword">let</span> centerRect = centerHelperPresentationLayer.frame</span><br><span class="line"><span class="keyword">let</span> sideRect   = sideHelperPresentationLayer.frame</span><br><span class="line"><span class="comment">// 获取捕捉到的layer层的frame数据</span></span><br><span class="line">diff = sideRect.origin.x - centerRect.origin.x</span><br><span class="line"><span class="comment">// 计算</span></span><br><span class="line">setNeedsDisplay()</span><br><span class="line"><span class="comment">// 绘制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，补充整个动画的逻辑：绘制方法受到通过两个辅助视图的位置计算而得的<code>diff</code>的影响，那么在辅助视图运动的时候，实时计算<code>diff</code>随后再重新绘制曲线，以1/60秒的速度刷新界面，完成动画</p>
<p>这里提到了1/60秒，也就是每秒60帧，是因为接下来要用到的重要技术：<code>CADisplayLink</code></p>
<p>先在类中声明</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> displayLink: <span class="type">CADisplayLink</span>?</span><br></pre></td></tr></table></figure>
<p>以及<code>animationCount</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> animationCount: <span class="type">Int</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后在扩展中书写</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">beforeAnimation</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> displayLink == <span class="literal">nil</span> &#123;</span><br><span class="line">displayLink = <span class="type">CADisplayLink</span>(target: <span class="keyword">self</span>, selector: #selector(handleDisplayLinkAction(displaylink:)))</span><br><span class="line"><span class="comment">// 为displayLink添加所需要刷新的内容</span></span><br><span class="line">displayLink?.add(to: <span class="type">RunLoop</span>.main, forMode: <span class="type">RunLoop</span>.<span class="type">Mode</span>.<span class="keyword">default</span>)</span><br><span class="line"><span class="comment">// 添加至主线程</span></span><br><span class="line">&#125;</span><br><span class="line">animationCount+=<span class="number">1</span></span><br><span class="line"><span class="comment">// 动画计数器自增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">finishAnimation</span><span class="params">()</span></span> &#123;</span><br><span class="line">animationCount-=<span class="number">1</span></span><br><span class="line"><span class="comment">// 动画计数器自减</span></span><br><span class="line"><span class="keyword">if</span> animationCount == <span class="number">0</span> &#123;</span><br><span class="line">displayLink?.invalidate()</span><br><span class="line"><span class="comment">// 在合适的时候注销</span></span><br><span class="line">displayLink = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 并取消引用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CADisplayLink</code>能够以每秒60次的速度刷新界面，只需要把它加入主线程中即可</p>
<p>在我们需要的动画开始前开启<code>CADisplayLink</code>，然后在结束的时候判断动画是否都执行完，再根据结果注销(和<code>timer</code>如出一辙)</p>
<p>那么代码的最后一部分，完成出现(<code>trigger()</code>)和消失(<code>tapToUntrigger()</code>)动画的方法</p>
<p>由于每个方法的内容很多，这里会分成几部分讲解</p>
<p>首先是<code>trigger()</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trigger</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !triggered &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> keyWindow = keyWindow &#123;</span><br><span class="line"><span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tapToUntrigger()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在将以下内容替换掉<code>code</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">keyWindow.insertSubview(blurView, belowSubview: <span class="keyword">self</span>)</span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>, animations: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>?.frame = <span class="type">CGRect</span>(</span><br><span class="line">x: <span class="number">0</span>,</span><br><span class="line">y: <span class="number">0</span>,</span><br><span class="line">width: keyWindow.frame.size.width/<span class="number">2</span> + (<span class="keyword">self</span>?.option.menuBlankWidth)!,</span><br><span class="line">height: keyWindow.frame.size.height)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 改变使GooeySlideMenu放大至设定的尺寸</span></span><br></pre></td></tr></table></figure>
<p>展现GooeySlideMenu</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">beforeAnimation()</span><br><span class="line"><span class="comment">// 开启刷新</span></span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.7</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.5</span>, initialSpringVelocity: <span class="number">0.9</span>, options:[.beginFromCurrentState,.allowUserInteraction],animations: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>?.helperSideView.center = <span class="type">CGPoint</span>(x: keyWindow.center.x, y: (<span class="keyword">self</span>?.helperSideView.frame.size.height)!)</span><br><span class="line">&#125;,completion: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (finish) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>?.finishAnimation()</span><br><span class="line"><span class="comment">// 结束刷新</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第一步动画，调整<code>helperSideView</code></p>
<p>其中：</p>
<ul>
<li><code>.beginFromCurrentState</code> 如果这个动画 animates 了一个之前已经指定好或<strong>in-flight</strong>的动画 animated 过的属性, 那么不是取消之前的动画(立即完成所请求的变化), 如果它正常发生, 这个动画会使用显示层来决定从哪儿开始, 并且, 如果可能的话, 它会把它的动画和之前的动画混合在一块儿。</li>
<li><code>.allowUserInteraction</code> 允许在动画执行时的用户交互</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>, animations: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>?.blurView.alpha = <span class="number">1.0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调整毛玻璃特效</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">beforeAnimation()</span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.7</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.8</span>, initialSpringVelocity: <span class="number">2.0</span>, options: [.beginFromCurrentState,.allowUserInteraction], animations: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>?.helperCenterView.center = keyWindow.center</span><br><span class="line">&#125;, completion: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (finished) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">if</span> finished &#123;</span><br><span class="line"><span class="keyword">let</span> tapGesture = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(<span class="type">GooeySlideMenu</span>.tapToUntrigger))</span><br><span class="line"><span class="keyword">self</span>?.blurView.addGestureRecognizer(tapGesture)</span><br><span class="line"><span class="keyword">self</span>?.finishAnimation()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第二步动画，调整<code>helperCenterView</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">triggered = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>如上完成<code>trigger()</code>方法</p>
<p>接下来是<code>tapToUntrigger()</code>方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">tapToUntrigger</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>填入</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>?.frame = <span class="type">CGRect</span>(</span><br><span class="line">x: -<span class="keyword">self</span>!.keyWindow!.frame.size.width/<span class="number">2</span> - <span class="keyword">self</span>!.option.menuBlankWidth,</span><br><span class="line">y: <span class="number">0</span>,</span><br><span class="line">width: <span class="keyword">self</span>!.keyWindow!.frame.size.width/<span class="number">2</span> + <span class="keyword">self</span>!.option.menuBlankWidth,</span><br><span class="line">height: <span class="keyword">self</span>!.keyWindow!.frame.size.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">beforeAnimation()</span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.7</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.6</span>, initialSpringVelocity: <span class="number">0.9</span>, options: [.beginFromCurrentState,.allowUserInteraction], animations: &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>.helperSideView.center = <span class="type">CGPoint</span>(x: -<span class="keyword">self</span>.helperSideView.frame.height/<span class="number">2</span>,</span><br><span class="line">y: <span class="keyword">self</span>.helperSideView.frame.height/<span class="number">2</span>)</span><br><span class="line">&#125;) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (finish) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>?.finishAnimation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>.blurView.alpha = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">beforeAnimation()</span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.7</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.7</span>, initialSpringVelocity: <span class="number">2.0</span>, options: [.beginFromCurrentState,.allowUserInteraction], animations: &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>.helperCenterView.center = <span class="type">CGPoint</span>(x: -<span class="keyword">self</span>.helperSideView.frame.size.height/<span class="number">2</span>,</span><br><span class="line">y: <span class="keyword">self</span>.frame.height/<span class="number">2</span>)</span><br><span class="line">&#125;) &#123; (finish) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>.finishAnimation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">triggered = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>至此，<code>GooeySlideMenu</code>类就完成了</p>
<p>接下来是ViewController的内容，改写为</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cellIdentifier = <span class="string">"demoCell"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> menu: <span class="type">GooeySlideMenu</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">title = <span class="string">"首页"</span></span><br><span class="line"><span class="keyword">let</span> menuOptions = <span class="type">MenuOptions</span>(</span><br><span class="line">menuColor: <span class="type">UIColor</span>(red: <span class="number">0.0</span>, green: <span class="number">0.722</span>, blue: <span class="number">1.0</span>, alpha: <span class="number">1.0</span>),</span><br><span class="line">blurStyle: .dark,</span><br><span class="line">menuBlankWidth: <span class="number">50.0</span></span><br><span class="line">)</span><br><span class="line">menu = <span class="type">GooeySlideMenu</span>(options: menuOptions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">didButtonTapped</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">menu?.trigger()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line"><span class="keyword">let</span> demoCell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, <span class="keyword">for</span>: indexPath <span class="keyword">as</span> <span class="type">IndexPath</span>)</span><br><span class="line">demoCell.textLabel?.text = <span class="string">"NO.\(indexPath.row+1)"</span></span><br><span class="line"><span class="keyword">return</span> demoCell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>storyboard补充成如图，并链接相应的插座函数</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/image-20181202162454320-3739094.png" alt="image-20181202162454320"></p>
<hr>
<h2 id="ch-4-实例：QQ-未读气泡的拖拽交互"><a href="#ch-4-实例：QQ-未读气泡的拖拽交互" class="headerlink" title="ch-4 实例：QQ 未读气泡的拖拽交互"></a>ch-4 实例：QQ 未读气泡的拖拽交互</h2><h3 id="预览-2"><a href="#预览-2" class="headerlink" title="预览"></a>预览</h3><p><img src="/2019/01/15/UIAnmations-with-Swift/ch4.gif" alt="ch4"></p>
<h3 id="How-2"><a href="#How-2" class="headerlink" title="How"></a>How</h3><ol>
<li>首先在拖动的时候，会发现有一部分跟随拖动手势发生了位移，还有一部分依然待在原地</li>
<li>然后如果把首和尾两个部分想象成两个圆心在同一直线上的圆的话，不难发现：</li>
</ol>
<ul>
<li>尾部的圆在拖动时逐渐缩小至消失</li>
<li>首部的圆内有数字(UILabel)</li>
<li>以两个圆的切点在圆心的连线的同侧的切线为基准绘制粘性边界</li>
<li>粘性边界在拖动过程中会发生细小变化</li>
</ul>
<ol>
<li>最后可以看到在松手之后，气泡重新归位了</li>
<li>最后将上述几点结合，将内容分解为数学和绘制两个部分，分别用代码实现</li>
</ol>
<p>来看一下这其中的数学问题：</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/Screen-Shot-2015-03-03-at-14-25-22.png" alt="img"></p>
<p>其中，Tips: OA ⊥ AB, PB ⊥ AB ,且 OA=PB=d/2。</p>
<p>按照惯例，依然需要新建一个新工程并添加一个新文件：CuteView.swift，并引入UIKit</p>
<p>这次需要一个类和一个结构体：</p>
<ul>
<li>class CuteView: UIView，使用控件时调用的类</li>
<li>struct BubbleOptions，在初始化类时用于帮助我们设置部分必要参数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CuteView</span>: <span class="title">UIView</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BubbleOptions</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体的代码如下：-1"><a href="#具体的代码如下：-1" class="headerlink" title="具体的代码如下："></a>具体的代码如下：</h4><p>首先，补充结构体至：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BubbleOptions</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> text: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"><span class="comment">//设置气泡内的文字内容</span></span><br><span class="line"><span class="keyword">var</span> bubbleWidth: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="comment">//设置气泡的直径</span></span><br><span class="line"><span class="keyword">var</span> viscosity: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="comment">//设置粘性边界的粘连程度</span></span><br><span class="line"><span class="keyword">var</span> bubbleColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.white</span><br><span class="line"><span class="comment">//设置气泡的颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是结构体，因此为了使用时安全，为所有的属性都设置了初始值。</p>
<p>接下来以初始化函数为起点开始coding：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(point: <span class="type">CGPoint</span>, superView: <span class="type">UIView</span>, options: <span class="type">BubbleOptions</span>) &#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x:point.x, y:point.y, width:options.bubbleWidth, height:options.bubbleWidth))</span><br><span class="line"><span class="comment">//完成父类的初始化</span></span><br><span class="line">bubbleOptions = options</span><br><span class="line"><span class="comment">//将结构体赋予类</span></span><br><span class="line">initialPoint = point</span><br><span class="line"><span class="comment">//设置初始位置</span></span><br><span class="line">containerView = superView</span><br><span class="line"><span class="comment">//记录父视图</span></span><br><span class="line">containerView.addSubview(<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">//添加子视图</span></span><br><span class="line">setUp()</span><br><span class="line"><span class="comment">//建立视图内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于已经将大小抽离到BubbleOptions这个结构体中，那么初始化函数的参数就变为point(视图位置) 、superView(父视图)、options(相关设置)。</p>
<p>那么相对应的父类的实现只需要计算对应参数即可，由于气泡是圆形的，因此用正方形的view承载即可，同时也可以看出BubbleOptions中的bubbleWidth属性是直径。</p>
<p>这里，构造函数中出现了几个新的属性，需要声明在类中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bubbleOptions: <span class="type">BubbleOptions</span>!&#123;</span><br><span class="line"><span class="keyword">didSet</span>&#123;</span><br><span class="line">bubbleLabel.text = bubbleOptions.text</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> initialPoint: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>.zero</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> containerView: <span class="type">UIView</span>!</span><br></pre></td></tr></table></figure>
<p>别忘了加上必要初始化函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，来完成初始化函数中的setUp()函数：</p>
<p>在开始之前，分析一下具体的实现过程。事实上整个效果可以分为三部分：</p>
<ul>
<li>一个随着拖动而移动的圆形视图</li>
<li>一个处在原地的圆形视图</li>
<li>一段根据两个圆形视图绘制出来的视图层(CAShapeLayer)</li>
</ul>
<p>而这些都是直接加在父视图上的</p>
<p>先补充要使用到的属性，将这些写入类中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> frontView: <span class="type">UIView</span>?</span><br><span class="line"><span class="comment">//随着拖动而移动的圆形视图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> bubbleLabel: <span class="type">UILabel</span>!</span><br><span class="line"><span class="comment">//用来显示文字的Label</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> cutePath: <span class="type">UIBezierPath</span>!</span><br><span class="line"><span class="comment">//曲线</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> fillColorForCute: <span class="type">UIColor</span>!</span><br><span class="line"><span class="comment">//曲线填充颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> animator: <span class="type">UIDynamicAnimator</span>!</span><br><span class="line"><span class="comment">//为其动态项提供物理相关功能和动画的对象，并为这些动画提供上下文。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> snap: <span class="type">UISnapBehavior</span>!</span><br><span class="line"><span class="comment">//一种弹簧状的行为，其初始运动随时间而衰减，使物体稳定在某一特定点。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> backView: <span class="type">UIView</span>!</span><br><span class="line"><span class="comment">//处在原地的圆形视图</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> shapeLayer: <span class="type">CAShapeLayer</span>!</span><br><span class="line"><span class="comment">//用于显示曲线的图层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> r1: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> r2: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> x1: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> y1: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> x2: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> y2: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> centerDistance: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="comment">//圆心距</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> cosDigree: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="comment">//圆心的连线与y轴夹角的cos值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> sinDigree: <span class="type">CGFloat</span> = <span class="number">0.0</span></span><br><span class="line"><span class="comment">//圆心的连线与y轴夹角的sin值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> pointA = <span class="type">CGPoint</span>.zero</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> pointB = <span class="type">CGPoint</span>.zero</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> pointC = <span class="type">CGPoint</span>.zero</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> pointD = <span class="type">CGPoint</span>.zero</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> pointO = <span class="type">CGPoint</span>.zero</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> pointP = <span class="type">CGPoint</span>.zero</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> oldBackViewFrame: <span class="type">CGRect</span> = <span class="type">CGRect</span>.zero</span><br><span class="line"><span class="comment">//记录初始状态下BackView的尺寸</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> oldBackViewCenter: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>.zero</span><br><span class="line"><span class="comment">//记录初始状态下BackView的位置</span></span><br></pre></td></tr></table></figure>
<p>随后声明方法setUp()：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来一步步完成这个方法：</p>
<ol>
<li>视图层</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">shapeLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line"><span class="comment">//实例图层</span></span><br><span class="line">backgroundColor = <span class="type">UIColor</span>.clear</span><br><span class="line"><span class="comment">//将CuteView的背景颜色设置为透明</span></span><br><span class="line">frontView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: initialPoint.x, y: initialPoint.y, width: bubbleOptions.bubbleWidth, height: bubbleOptions.bubbleWidth))</span><br><span class="line"><span class="comment">//实例frontView</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> frontView = frontView <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"frontView is nil"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断frontView是否存在</span></span><br><span class="line">r2 = frontView.bounds.size.width / <span class="number">2.0</span></span><br><span class="line"><span class="comment">//计算r2</span></span><br><span class="line">frontView.layer.cornerRadius = r2</span><br><span class="line"><span class="comment">//设置frontView的圆角</span></span><br><span class="line">frontView.backgroundColor = bubbleOptions.bubbleColor</span><br><span class="line"><span class="comment">//设置frontView的背景颜色</span></span><br><span class="line"></span><br><span class="line">backView = <span class="type">UIView</span>(frame: frontView.frame)</span><br><span class="line"><span class="comment">//实例backView，和frontView一样大小位置</span></span><br><span class="line">r1 = backView.bounds.size.width / <span class="number">2</span></span><br><span class="line"><span class="comment">//计算r1</span></span><br><span class="line">backView.layer.cornerRadius = r1</span><br><span class="line"><span class="comment">//设置backView的圆角</span></span><br><span class="line">backView.backgroundColor = bubbleOptions.bubbleColor</span><br><span class="line"><span class="comment">//设置backView的背景颜色</span></span><br><span class="line"></span><br><span class="line">bubbleLabel = <span class="type">UILabel</span>()</span><br><span class="line"><span class="comment">//实例label</span></span><br><span class="line">bubbleLabel.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: frontView.bounds.width, height: frontView.bounds.height)</span><br><span class="line"><span class="comment">//设置label的大小位置</span></span><br><span class="line">bubbleLabel.textColor = <span class="type">UIColor</span>.white</span><br><span class="line"><span class="comment">//设置label的字体颜色</span></span><br><span class="line">bubbleLabel.textAlignment = .center</span><br><span class="line"><span class="comment">//设置label的字体居中</span></span><br><span class="line">bubbleLabel.text = bubbleOptions.text</span><br><span class="line"><span class="comment">//这只label的字体内容</span></span><br><span class="line"></span><br><span class="line">frontView.insertSubview(bubbleLabel, at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">//在frontview中插入label</span></span><br><span class="line">containerView.addSubview(backView)</span><br><span class="line"><span class="comment">//添加backView</span></span><br><span class="line">containerView.addSubview(frontView)</span><br><span class="line"><span class="comment">//添加frontView</span></span><br></pre></td></tr></table></figure>
<ol>
<li>计算其余的属性</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">x1 = backView.center.x</span><br><span class="line">y1 = backView.center.y</span><br><span class="line">x2 = frontView.center.x</span><br><span class="line">y2 = frontView.center.y</span><br><span class="line"></span><br><span class="line">pointA = <span class="type">CGPoint</span>(x:x1-r1,y:y1)   <span class="comment">// A</span></span><br><span class="line">pointB = <span class="type">CGPoint</span>(x:x1+r1, y:y1)  <span class="comment">// B</span></span><br><span class="line">pointD = <span class="type">CGPoint</span>(x:x2-r2, y:y2)  <span class="comment">// D</span></span><br><span class="line">pointC = <span class="type">CGPoint</span>(x:x2+r2, y:y2)  <span class="comment">// C</span></span><br><span class="line">pointO = <span class="type">CGPoint</span>(x:x1-r1,y:y1)   <span class="comment">// O</span></span><br><span class="line">pointP = <span class="type">CGPoint</span>(x:x2+r2, y:y2)  <span class="comment">// P</span></span><br></pre></td></tr></table></figure>
<ol>
<li>记录backView的旧参数并为frontView添加手势</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">oldBackViewFrame = backView.frame</span><br><span class="line">oldBackViewCenter = backView.center</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> panGesture = <span class="type">UIPanGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(handleDragGesture(ges:)))</span><br><span class="line">frontView.addGestureRecognizer(panGesture)</span><br></pre></td></tr></table></figure>
<p>接下来完成拖拽手势：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">handleDragGesture</span><span class="params">(ges: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> dragPoint = ges.location(<span class="keyword">in</span>: containerView)</span><br><span class="line"><span class="comment">//记录拖拽手势的位置</span></span><br><span class="line"><span class="keyword">if</span> ges.state == .began &#123;</span><br><span class="line"><span class="comment">// 不给r1赋初始值的话，如果第一次拖动使得r1少于6，第二次拖动就直接隐藏绘制路径了</span></span><br><span class="line">r1 = oldBackViewFrame.width / <span class="number">2</span></span><br><span class="line"><span class="comment">//设置r1</span></span><br><span class="line">backView.isHidden = <span class="literal">false</span></span><br><span class="line"><span class="comment">//隐藏backView</span></span><br><span class="line">fillColorForCute = bubbleOptions.bubbleColor</span><br><span class="line"><span class="comment">//设置曲线填充的颜色</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ges.state == .changed &#123;</span><br><span class="line">frontView?.center = dragPoint</span><br><span class="line"><span class="comment">//使frontView发生位移，跟随拖拽点</span></span><br><span class="line"><span class="keyword">if</span> r1 &lt;= <span class="number">6</span> &#123;</span><br><span class="line"><span class="comment">//如果r1过小就使得粘连部分消失</span></span><br><span class="line">fillColorForCute = <span class="type">UIColor</span>.clear</span><br><span class="line">backView.isHidden = <span class="literal">true</span></span><br><span class="line">shapeLayer.removeFromSuperlayer()</span><br><span class="line">&#125;</span><br><span class="line">drawRect()</span><br><span class="line"><span class="comment">//绘制曲线</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ges.state == .ended || ges.state == .cancelled || ges.state == .failed &#123;</span><br><span class="line"><span class="comment">//当拖拽手势结束时，消除粘连部分并将frontView弹回原来的位置</span></span><br><span class="line">backView.isHidden = <span class="literal">true</span></span><br><span class="line">fillColorForCute = <span class="type">UIColor</span>.clear</span><br><span class="line">shapeLayer.removeFromSuperlayer()</span><br><span class="line"><span class="comment">//使用带有类似弹簧效果的UIView.animate使得移动动画富有弹性</span></span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.4</span>, initialSpringVelocity: <span class="number">0.0</span>, options: .curveEaseInOut, animations: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> strongsSelf = <span class="keyword">self</span> &#123;</span><br><span class="line">strongsSelf.frontView?.center = strongsSelf.oldBackViewCenter</span><br><span class="line"><span class="comment">//设置位移</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, completion: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (finished) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> strongsSelf = <span class="keyword">self</span> &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后完成drawRect()：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">drawRect</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断frontView是否存在</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> frontView = frontView <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>计算在frontView位移后的绘制相关的属性</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">x1 = backView.center.x</span><br><span class="line">y1 = backView.center.y</span><br><span class="line">x2 = frontView.center.x</span><br><span class="line">y2 = frontView.center.y</span><br><span class="line"></span><br><span class="line">centerDistance = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))</span><br><span class="line"><span class="comment">//两点间距离公式</span></span><br><span class="line"><span class="comment">//分别计算有无位移时的正弦和余弦</span></span><br><span class="line"><span class="keyword">if</span> centerDistance == <span class="number">0</span> &#123;</span><br><span class="line">cosDigree = <span class="number">1</span></span><br><span class="line">sinDigree = <span class="number">0</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cosDigree = (y2-y1)/centerDistance</span><br><span class="line">sinDigree = (x2-x1)/centerDistance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r1 = oldBackViewFrame.size.width / <span class="number">2</span> - centerDistance/bubbleOptions.viscosity</span><br><span class="line"><span class="comment">//计算backView的大小（半径）</span></span><br><span class="line"></span><br><span class="line">pointA = <span class="type">CGPoint</span>(x:x1-r1*cosDigree, y:y1+r1*sinDigree) <span class="comment">// A</span></span><br><span class="line">pointB = <span class="type">CGPoint</span>(x:x1+r1*cosDigree, y:y1-r1*sinDigree) <span class="comment">// B</span></span><br><span class="line">pointD = <span class="type">CGPoint</span>(x:x2-r2*cosDigree, y:y2+r2*sinDigree) <span class="comment">// D</span></span><br><span class="line">pointC = <span class="type">CGPoint</span>(x:x2+r2*cosDigree, y:y2-r2*sinDigree) <span class="comment">// C</span></span><br><span class="line">pointO = <span class="type">CGPoint</span>(x:pointA.x + (centerDistance / <span class="number">2</span>)*sinDigree, y:pointA.y + (centerDistance / <span class="number">2</span>)*cosDigree)</span><br><span class="line">pointP = <span class="type">CGPoint</span>(x:pointB.x + (centerDistance / <span class="number">2</span>)*sinDigree, y:pointB.y + (centerDistance / <span class="number">2</span>)*cosDigree)</span><br></pre></td></tr></table></figure>
<ol>
<li>设置backView</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">backView.center = oldBackViewCenter;</span><br><span class="line">backView.bounds = <span class="type">CGRect</span>(x:<span class="number">0</span>, y:<span class="number">0</span>, width:r1*<span class="number">2</span>, height:r1*<span class="number">2</span>);</span><br><span class="line">backView.layer.cornerRadius = r1;</span><br></pre></td></tr></table></figure>
<ol>
<li>绘制曲线</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">cutePath = <span class="type">UIBezierPath</span>()</span><br><span class="line">cutePath.move(to: pointA)</span><br><span class="line">cutePath.addQuadCurve(to: pointD, controlPoint: pointO)</span><br><span class="line">cutePath.addLine(to: pointC)</span><br><span class="line">cutePath.addQuadCurve(to: pointB, controlPoint: pointP)</span><br><span class="line">cutePath.move(to: pointA)</span><br></pre></td></tr></table></figure>
<ol>
<li>添加曲线</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> backView.isHidden == <span class="literal">false</span> &#123;</span><br><span class="line">shapeLayer.path = cutePath.cgPath</span><br><span class="line">shapeLayer.fillColor = fillColorForCute.cgColor</span><br><span class="line">containerView.layer.insertSublayer(shapeLayer, below: frontView.layer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，仿照QQ未读气泡的拖拽效果就完成了</p>
<p>在ViewController中写入一下内容就可以查看效果了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> option = <span class="type">BubbleOptions</span>()</span><br><span class="line">option.viscosity = <span class="number">20.0</span></span><br><span class="line">option.bubbleWidth = <span class="number">35.0</span></span><br><span class="line">option.bubbleColor = <span class="type">UIColor</span>(red: <span class="number">0.0</span>, green: <span class="number">0.722</span>, blue: <span class="number">1.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cuteView = <span class="type">CuteView</span>(point: <span class="type">CGPoint</span>(x:<span class="number">25</span>, y:<span class="type">UIScreen</span>.main.bounds.size.height - <span class="number">65</span>), superView: view, options: option)</span><br><span class="line">option.text = <span class="string">"20"</span></span><br><span class="line">cuteView.bubbleOptions = option</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h3><p>放大看看未拖拽时的气泡：</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/buling.gif" alt="buling"></p>
<p>你是否发现它在晃动！</p>
<p>那么这个效果是怎么实现的呢！</p>
<p>为CuteView加上扩展就可以了！</p>
<p>这个晃动分为两个部分：</p>
<ul>
<li>气泡的位移</li>
<li>气泡的变形</li>
</ul>
<p>细节如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CuteView</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">addAniamtionLikeGameCenterBubble</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//设置位移</span></span><br><span class="line"><span class="keyword">let</span> pathAnimation = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line"><span class="comment">//为层对象提供关键帧动画功能的对象</span></span><br><span class="line">pathAnimation.calculationMode = <span class="type">CAAnimationCalculationMode</span>.paced</span><br><span class="line"><span class="comment">//线性关键帧值插值，以产生一个均匀的速度在整个动画</span></span><br><span class="line"></span><br><span class="line">pathAnimation.fillMode = <span class="type">CAMediaTimingFillMode</span>.forwards</span><br><span class="line"><span class="comment">//当动画完成时，接收器保持可见的最终状态</span></span><br><span class="line">pathAnimation.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line"><span class="comment">//确定动画完成后是否从目标层的动画中删除。</span></span><br><span class="line">pathAnimation.repeatCount = <span class="type">Float</span>.infinity</span><br><span class="line"><span class="comment">//确定动画将重复的次数</span></span><br><span class="line">pathAnimation.timingFunction = <span class="type">CAMediaTimingFunction</span>(name: <span class="type">CAMediaTimingFunctionName</span>.linear)</span><br><span class="line"><span class="comment">//一种函数，它将动画的节奏定义为时间曲线</span></span><br><span class="line"><span class="comment">//线性节奏，使动画在其持续时间内均匀地发生</span></span><br><span class="line">pathAnimation.duration = <span class="number">5.0</span></span><br><span class="line"><span class="comment">//设置动画的单次执行时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curvedPath = <span class="type">CGMutablePath</span>()</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> frontView = frontView <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"frontView is nil!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> circleContainer = frontView.frame.insetBy(dx: frontView.bounds.width / <span class="number">2</span> - <span class="number">3</span>, dy: frontView.bounds.size.width / <span class="number">2</span> - <span class="number">3</span>)</span><br><span class="line"><span class="comment">//获取frontView的尺寸并计算运动范围</span></span><br><span class="line"></span><br><span class="line">curvedPath.addEllipse(<span class="keyword">in</span>: circleContainer)</span><br><span class="line"><span class="comment">//添加一个适合于指定矩形的椭圆</span></span><br><span class="line">pathAnimation.path = curvedPath</span><br><span class="line"><span class="comment">//设置动画的路径</span></span><br><span class="line">frontView.layer.add(pathAnimation, forKey: <span class="string">"circleAnimation"</span>)</span><br><span class="line"><span class="comment">//添加动画</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scaleX = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">"transform.scale.x"</span>)</span><br><span class="line">scaleX.duration = <span class="number">1.0</span></span><br><span class="line">scaleX.values = [<span class="type">NSNumber</span>(value: <span class="number">1.0</span>),<span class="type">NSNumber</span>(value: <span class="number">1.1</span>),<span class="type">NSNumber</span>(value: <span class="number">1.0</span>)]</span><br><span class="line"><span class="comment">//指定动画使用的关键帧值的对象数组</span></span><br><span class="line"><span class="comment">//关键帧值表示动画必须通过的值。给定关键帧值应用于该层的时间取决于动画计时，动画计时由calculationMode、keyTimes和timingFunctions属性控制。关键帧之间的值是使用插值创建的，除非计算模式设置为离散的。</span></span><br><span class="line">根据属性的类型，您可能需要使用<span class="type">NSValue</span>对象的<span class="type">NSNumber</span>包装此数组中的值。对于某些核心图形数据类型，可能还需要在将其添加到数组之前将其转换为id。</span><br><span class="line">仅当path属性中的值为<span class="literal">nil</span>时才使用此属性中的值。</span><br><span class="line">scaleX.keyTimes = [<span class="type">NSNumber</span>(value: <span class="number">0.0</span>), <span class="type">NSNumber</span>(value: <span class="number">0.5</span>), <span class="type">NSNumber</span>(value: <span class="number">1.0</span>)]</span><br><span class="line"><span class="comment">//NSNumber对象的可选数组，定义应用给定关键帧段的时间</span></span><br><span class="line"><span class="comment">//数组中的每个值都是一个介于0.0和1.0之间的浮点数，它定义了应用相应关键帧值的时间点(指定为动画总持续时间的一部分)。数组中的每个连续值必须大于或等于前一个值。通常，数组中的元素数量应该与values属性中的元素数量或path属性中的控制点数量匹配。如果他们没有，你的动画的时间可能不是你所期望的</span></span><br><span class="line">scaleX.repeatCount = <span class="type">Float</span>.infinity</span><br><span class="line">scaleX.autoreverses = <span class="literal">true</span></span><br><span class="line"><span class="comment">//确定完成后接收器是否反向播放</span></span><br><span class="line"></span><br><span class="line">scaleX.timingFunction = <span class="type">CAMediaTimingFunction</span>(name: <span class="type">CAMediaTimingFunctionName</span>.easeInEaseOut)</span><br><span class="line"><span class="comment">//一个可选的CAMediaTimingFunction对象数组，用于定义每个关键帧段的速度</span></span><br><span class="line"><span class="comment">//可以使用此数组将易入、易出或自定义时间曲线应用于位于两个关键帧值之间的点。如果values属性中的关键帧数为n，那么该属性应该包含n-1个对象。</span></span><br><span class="line"><span class="comment">//如果在keyTimes属性中提供计时信息，则使用此属性指定的计时函数将进一步修改这些值之间的计时。如果没有给keyTimes属性赋值，计时函数将修改动画对象提供的默认计时。</span></span><br><span class="line"><span class="comment">//如果还在动画对象的timingFunction属性中指定了一个计时函数，则首先应用该函数，然后是特定关键帧段的计时函数。</span></span><br><span class="line">frontView.layer.add(scaleX, forKey: <span class="string">"scaleXAnimation"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scaleY = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">"transform.scale.y"</span>)</span><br><span class="line">scaleY.duration = <span class="number">1.5</span></span><br><span class="line">scaleY.values = [<span class="type">NSNumber</span>(value: <span class="number">1.0</span>),<span class="type">NSNumber</span>(value: <span class="number">1.1</span>),<span class="type">NSNumber</span>(value: <span class="number">1.0</span>)]</span><br><span class="line">scaleY.keyTimes = [<span class="type">NSNumber</span>(value: <span class="number">0.0</span>), <span class="type">NSNumber</span>(value: <span class="number">0.5</span>), <span class="type">NSNumber</span>(value: <span class="number">1.0</span>)]</span><br><span class="line">scaleY.repeatCount = <span class="type">Float</span>.infinity</span><br><span class="line">scaleY.autoreverses = <span class="literal">true</span></span><br><span class="line">scaleY.timingFunction = <span class="type">CAMediaTimingFunction</span>(name: <span class="type">CAMediaTimingFunctionName</span>.easeInEaseOut)</span><br><span class="line">frontView.layer.add(scaleY, forKey: <span class="string">"scaleYAnimation"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAniamtionLikeGameCenterBubble</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> frontView = frontView &#123;</span><br><span class="line">frontView.layer.removeAllAnimations()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后在setUp()中添加：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">addAniamtionLikeGameCenterBubble()</span><br></pre></td></tr></table></figure>
<p>在handleDragGesture()中的UIView.animate的completion中添加成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> strongsSelf = <span class="keyword">self</span> &#123;</span><br><span class="line">strongsSelf.addAniamtionLikeGameCenterBubble()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在handleDragGesture()中的<code>if ges.state == .began {}</code>里添加</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">removeAniamtionLikeGameCenterBubble()</span><br></pre></td></tr></table></figure>
<p>以上就是所有的内容。</p>
<hr>
<h2 id="ch-5-实例：LiquidLoader"><a href="#ch-5-实例：LiquidLoader" class="headerlink" title="ch-5 实例：LiquidLoader"></a>ch-5 实例：LiquidLoader</h2><hr>
<h1 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h1><h2 id="前导-1"><a href="#前导-1" class="headerlink" title="前导"></a>前导</h2><p>Core Animation是一个可以在iOS和OS X上使用的图形渲染和动画基础架构，你可以使用它为你的应用程序的视图和其他视觉元素添加动画。你所要做的就是配置一些动画参数(如起点和终点)并告诉Core animation开始。Core Animation就会完成剩下的工作，将大部分实际绘制工作交给板载图形硬件来加速渲染。这种自动图形加速的结果是高帧率和平滑的动画，而不增加CPU负担和减慢您的应用程序。</p>
<p>Core Animation位于AppKit和UIKit之下，并被紧密集成到Cocoa和Cocoa Touch的视图工作流中。当然，Core Animation也有一些接口，可以扩展应用程序视图所公开的功能，并对应用程序的动画进行更细粒度的控制。</p>
<p><img src="/2019/01/15/UIAnmations-with-Swift/ca_architecture_2x.png" alt="../Art/ca_architecture_2x.png"></p>
<hr>
<h1 id="Animation-and-Haptics-UIKit"><a href="#Animation-and-Haptics-UIKit" class="headerlink" title="Animation and Haptics(UIKit)"></a>Animation and Haptics(UIKit)</h1><hr>
<h1 id="Animating-Views-with-Block-Objects-UIView"><a href="#Animating-Views-with-Block-Objects-UIView" class="headerlink" title="Animating Views with Block Objects(UIView)"></a>Animating Views with Block Objects(UIView)</h1><hr>
]]></content>
      <categories>
        <category>Swift</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 注释文档方法</title>
    <url>/2020/02/18/howToMarkupInXcode/</url>
    <content><![CDATA[<h1 id="Xcode-注释文档方法"><a href="#Xcode-注释文档方法" class="headerlink" title="Xcode 注释文档方法"></a>Xcode 注释文档方法</h1><p>今天，我知道我写了什么代码，</p>
<p>明天，我知道为什么写这代码，</p>
<p>后天，我知道这是我写的代码，</p>
<p>一周后，我知道我看不懂代码，</p>
<p>论代码注释的重要性。</p>
<a id="more"></a>
<hr>
<h2 id="普通的注释"><a href="#普通的注释" class="headerlink" title="普通的注释"></a>普通的注释</h2><ol>
<li><p>单行注释</p>
<p>插入 <code>//</code> 会使后续内容成为注释。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"这是代码"</span></span><br><span class="line"><span class="comment">// 这是注释</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行注释</p>
<p>输入 <code>/*</code>  和 <code>*/</code> 在其间输入内容，那么整体就会成为注释。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"这是代码"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这是注释的第一行</span></span><br><span class="line"><span class="comment">    这是注释的第二行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Xcode 可以同时按下 command 和 / （⌘+/）将光标停留或选中的行注释，注释的结果为：在每一行的最开始添加 <code>//</code> 。</p>
</blockquote>
</li>
</ol>
<h2 id="MARK、TODO、FIXME"><a href="#MARK、TODO、FIXME" class="headerlink" title="MARK、TODO、FIXME"></a>MARK、TODO、FIXME</h2><p>这三种都是对代码结构进行注释，会在文件代码结构视图（⌃+6）中显示出来。</p>
<ol>
<li><p>MARK:  代码结构标记。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Properties</span></span><br><span class="line"><span class="comment">// MARK: - Initialization</span></span><br><span class="line"><span class="comment">// MARK: - IBAction Method</span></span><br><span class="line"><span class="comment">// MARK: - XXXDelegate</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TODO： 待完成标记。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> - 待完成的功能</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> - Need to finish</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FIXME:  检查标记。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> - 这里可能发生崩溃</span></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> - There is a waring</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注释后效果如图：</p>
<p><img src="/2020/02/18/howToMarkupInXcode/image-20200217231210027.png" alt="image-20200217231210027" style="zoom:50%;"></p>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><p>文档注释用于输出代码文档和阅读方便，规范的文档可以在 Quick Help 中看到或者 option + 左击 （⌥ + 左击）快速查看相关说明。</p>
<p>单行文档注释的快捷键：command + option + / （⌘+⌃+/）</p>
<p>文档注释的对象： 自定义类型、变量、方法等，重点就是对方法进行说明。</p>
<ol>
<li><p>单行注释</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 这是注释</span></span><br><span class="line"><span class="keyword">var</span> code:<span class="type">String</span> = <span class="string">"这是代码"</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/18/howToMarkupInXcode/image-20200218210030737.png" alt="image-20200218210030737" style="zoom:50%;"></p>
<blockquote>
<p>注意，Xcode 不识别行尾的单行文档注释</p>
</blockquote>
</li>
<li><p>多行注释</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">///     测试</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     # 支持markdown</span></span><br><span class="line"><span class="comment">///     # 一级标题</span></span><br><span class="line"><span class="comment">///     ## 二级标题也可以的</span></span><br><span class="line"><span class="comment">///     注释参考2</span></span><br><span class="line"><span class="comment">///     隔一行表示换行d</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     三个”***"代表一条分割线</span></span><br><span class="line"><span class="comment">///     ***</span></span><br><span class="line"><span class="comment">///     ## 使用示例</span></span><br><span class="line"><span class="comment">///</span></span><br></pre></td></tr></table></figure>
<p>///     let result = testComment2(pram: “参数1”, param2: true))<br>///     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///</span><br><span class="line">///     ****</span><br><span class="line">///     - important:这个很重要</span><br><span class="line">///     - returns: 有返回值</span><br><span class="line">///     - parameter pram: The cubes available for allocation</span><br><span class="line">///     - parameter param2: The people that require cubes</span><br><span class="line"></span><br><span class="line">func exampleFunc(firstPram:String, secondParam:Bool) -&gt; Bool &#123;</span><br><span class="line">        print(&quot;markdown支持&quot;)</span><br><span class="line">        return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2020/02/18/howToMarkupInXcode/image-20200218211303874.png" alt="image-20200218211303874" style="zoom: 33%;"></p>
</li>
<li><p>另一种多行注释的方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 测试</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> # 支持markdown</span></span><br><span class="line"><span class="comment"> # 一级标题</span></span><br><span class="line"><span class="comment"> ## 二级标题也可以的</span></span><br><span class="line"><span class="comment"> 注释参考</span></span><br><span class="line"><span class="comment"> 隔一行表示换行</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 三个”***"代表一条分割线</span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> ## 使用示例</span></span><br></pre></td></tr></table></figure>
<p> let result = exampleFunc(firstPram: “1”, secondParam: true)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> ****</span><br><span class="line"> - important:这个很重要</span><br><span class="line"> - returns: 有返回值</span><br><span class="line"> - parameter firstPram: String</span><br><span class="line"> - parameter secondParam: Bool</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">func exampleFunc(firstPram:String, secondParam:Bool) -&gt; Bool &#123;</span><br><span class="line">    print(&quot;markdown支持&quot;)</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/18/howToMarkupInXcode/image-20200218211543197.png" alt="image-20200218211543197" style="zoom:33%;"></p>
</li>
<li><p>另一种风格</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 通过姓名、年龄、性别创建一个视图并返回</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - firstParam: String</span></span><br><span class="line"><span class="comment">///   - secondParam: Double</span></span><br><span class="line"><span class="comment">/// - Returns: Int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">(firstParam:String,secondParam:Double)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/18/howToMarkupInXcode/image-20200218211946725.png" alt="image-20200218211946725" style="zoom: 33%;"></p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Swift</category>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Xcode</tag>
        <tag>注释</tag>
      </tags>
  </entry>
  <entry>
    <title>如何书写一份 PlaygroundBook (1)</title>
    <url>/2020/05/14/howToWriteAPlaygroundBook-1/</url>
    <content><![CDATA[<blockquote>
<p>本文以Apple Developer 官网资料以及笔者的实践和经历，归纳笔者所知道的“书写”一份 Playground Book 所能用到的技巧。</p>
<p>本文：</p>
<p>创建于： 2020/02/24</p>
<p>更新于：2020/02/24</p>
<p>当前版本：</p>
<p>Swift: version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)</p>
<p>Xcode: version 11.3.1 (11C504)</p>
<p>Playgrounds (on Mac) : Version 3.2 (1137.33.1)</p>
<p>Playgrounds (on iPad) : Version 3.2 (1084.31)</p>
<p>注意：本文的绝大部份涉及例子和代码的内容笔者只会在 Playgrounds (on Mac) 上进行测试，笔者认为两个平台在 Playground Book 本身的技术上并无差异。</p>
</blockquote>
<a id="more"></a>
<h1 id="Playground-的相关设置"><a href="#Playground-的相关设置" class="headerlink" title="Playground 的相关设置"></a>Playground 的相关设置</h1><h2 id="创建-Playground-Book"><a href="#创建-Playground-Book" class="headerlink" title="创建 Playground Book"></a>创建 Playground Book</h2><blockquote>
<p>在过去（如2017年）开发者仍只能使用创建好的空白 Playground Book 来进行创作。这样的形式给开发者带来了诸多不便（由于诸多Xcode 的先进功能无法使用）。</p>
<p>而在后来，Apple 提交了一份用于创建 Playground Book 的工程项目，大大降低了开发和调试的难度和步骤。</p>
</blockquote>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>同时使用运行 Xcode 的 Mac 和 iPad 创建 Playground Book。 下载 Swift Playgrounds 作者模板（<a href="https://developer.apple.com/download/more/?=Swift Playgrounds Author Template" target="_blank" rel="noopener">Swift Playgrounds Author Template</a>），并在Mac上的Xcode中将其打开。 然后，为其编写页面，并将其所有资源打包到与 iPad 共享的 <code>.playgroundbook</code> 文件中。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>该模板包含开始为 Swift Playgrounds 编写内容所需的所有初始文件和资源。 选择“Product”=&gt;“Build”，将这些资源编译成 <code>.playgroundbook</code> 文件，就可以与 iPad 共享该文件。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><h4 id="在-iPad-上运行"><a href="#在-iPad-上运行" class="headerlink" title="在 iPad 上运行"></a>在 iPad 上运行</h4><ol>
<li>找到 Xcode 编译出的 <code>.playgroundbook</code> 文件（通常在固定的目录或者使用“show in finder”功能）。</li>
<li>通过隔空投送（airdrop）将文件传输到 iPad 上。</li>
<li>当传输完成时，iPad会自动使用“Swift Playgrounds”来打开该文件（如果iPad上有“Swift Playgrounds”）。</li>
</ol>
<h4 id="在-Mac-上运行"><a href="#在-Mac-上运行" class="headerlink" title="在 Mac 上运行"></a>在 Mac 上运行</h4><ol>
<li>在 App Store 上下载“Playgrounds”。</li>
<li>双击你的 <code>.playground</code> 文件。</li>
</ol>
<hr>
<h2 id="Playground-Book-的文件结构"><a href="#Playground-Book-的文件结构" class="headerlink" title="Playground Book 的文件结构"></a>Playground Book 的文件结构</h2><blockquote>
<p>Playground Book 是一种特殊的“包”，它以一定的结构和文件组织自身（通常为有特定后缀的文件夹和许多 <code>Manifest.plist</code> 文件）</p>
<p>在本文中会大量出现表示诸如：<code>Swift Playground Book</code> 、<code>Swift Playground Page</code> 等概念的名词，笔者认为将这些名词翻译出来（如：书、书页、章节）会使阅读十分不顺且难以理解，但直接使用英文全称有些冗长且同样不好理解。因此，笔者作出以下约定：</p>
<ul>
<li>将 <code>Swift playground Book(s)</code> 表示为 “book”</li>
<li>将 <code>Swift playground Chapter(s)</code> 表示为 “Chapter”</li>
<li>将 <code>Swift playground Page(s)</code> 表示为 “page”</li>
<li>将 <code>Swift module(s)</code> 或 <code>UserModule</code> 表示为 “module”</li>
<li>将 <code>Introduction</code> 或 <code>引导页</code> 表示为 ”cutscene“ </li>
</ul>
<p>以上概念不仅表示相对应的 Swift Playground Book 结构，还会表示对应结构的根目录。</p>
</blockquote>
<h3 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h3><p>结合 Playground 中的 “book”、“chapter”、“page”、“Swift module”、“cutscene”来为需要呈现的内容作叙述和结构说明。比如，可以：</p>
<ul>
<li>使用“book”来“包裹”（打包）根目录级别的 Swift Playgrounds 内容。</li>
<li>使用“chapter”来将“book”中的内容（“page”和“cutscene”）分组。</li>
<li>使用“page”来写“book”的主要教学内容和探索性内容。</li>
<li>使用“module”来实现实时视图，并提供学习者针对其编写代码的API。</li>
<li>提供用户可编辑的模块，为学习者提供存储和重用代码的空间。</li>
<li>在“page”之间穿插“cutscene”来介绍或者总结概念。</li>
</ul>
<p>Playground Book 的每一部分都必须包含 <code>Manifest.plist</code> 文件（属性列表）。这个列表包含了该部分的元数据（主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。）以及对共享资源的引用。</p>
<blockquote>
<p>注意：</p>
<p>可从Swift Playgrounds 3 和 Swift Playgrounds book 格式的版本 6 开始使用“module”。 对于以前的版本，将代码放置在“book”、“chapter”或“page”的 <code>Sources</code> 文件夹中。</p>
</blockquote>
<h3 id="“book”的属性列表"><a href="#“book”的属性列表" class="headerlink" title="“book”的属性列表"></a>“book”的属性列表</h3><p>在其 <code>Manifest.plist</code> 文件中写入有关 playground Book 的主要详细信息。 Swift Playgrounds 作者模板带有默认的文件，可以在其中更新有关书的特定详细信息，例如书名和封面图像的文件路径。</p>
<blockquote>
<p>一个“book”基本的文件结构至少应如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">&gt; └── example.playgroundbook</span><br><span class="line">&gt;  └── Contents</span><br><span class="line">&gt;      ├── Chapters</span><br><span class="line">&gt;      ├── Manifest.plist</span><br><span class="line">&gt;      └── UserModules</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以在这个文件中配置以下内容：</p>
<ul>
<li><code>Chapters</code><ul>
<li>必须</li>
<li>一个字符串数组，来对“book”中的每一个“chapter”进行排序。每一个字符串代表一个以 <code>.playgroundchapter</code> 结尾的目录的名称，这个目录应包含该“chapter”的内容和资源。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224191753759.png" alt="image-20200224191753759"></li>
</ul>
</li>
<li><code>ContentIdentifier</code><ul>
<li>必须</li>
<li>一个字符串，作为能够从其他“book”之中识别作者的所有的标记。标识符必须是反向 DNS （reverse-DNS）的形式，并且应该使用自己或者组织的域（domain）。例如，如果拥有 example.com ，则可以将一本书的ContentIdentifier属性设置为 com.example.mybook 。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224193022705.png" alt="image-20200224193022705"></li>
</ul>
</li>
<li><code>ContentVersion</code><ul>
<li>必须</li>
<li>一个字符串，包含作为“book”的版本号的信息。该字符串只能是包含数字和英文句号（点）的序列，例如 <code>2.1.1</code> ，当更新“book”时，应该增加版本号。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224195104611.png" alt="image-20200224195104611"></li>
</ul>
</li>
<li><code>DeploymentTarget</code><ul>
<li>必须</li>
<li>一个字符串，包含运行“book”所需要的最低 iOS 的版本的信息（10.0或更高版本）。使用字符串 <code>ios</code> 作为版本号的前缀。例如，iOS 11.3 的版本字符串是 <code>ios11.3</code> 。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224195027794.png" alt="image-20200224195027794"></li>
</ul>
</li>
<li><code>DevelopmentRegion</code><ul>
<li>必须</li>
<li>一个语言标识符（Language ID），表示“book”的默认语言和地区。有关更多信息，请参见 <code>Language ID</code> 和 <code>CFBundleDevelopmentRegion</code> 。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224195130839.png" alt="image-20200224195130839"></li>
</ul>
</li>
<li><code>ImageReference</code><ul>
<li>可选</li>
<li>一个字符串，包含对 <code>.png</code> 文件的引用地址，该文件储存在“book”的名为 <code>Resources</code> 的文件夹中（该文件夹与 <code>Manifest.plist</code> 文件同级），被用作“book”的封面图标。图标的尺寸必须是长宽比为 4:3 的图像。推荐的图像尺寸为 400×300 像素。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224194909561.png" alt="image-20200224194909561"></li>
</ul>
</li>
<li><code>Name</code><ul>
<li>必须</li>
<li>一个字符串，用于提供“book”的名称。该名称在 Swift Playgrounds 中作为“book”的名称呈现给用户。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224195640649.png" alt="image-20200224195640649"></li>
</ul>
</li>
<li><code>Version</code><ul>
<li>必须</li>
<li>一个字符串，包含用于编写该“book”的 Swift Playground 书本格式 （<code>Swift Playground book format</code> ）。填写 <code>6.0</code>。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224200029982.png" alt="image-20200224200029982">（来自空白模板）</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224200056115.png" alt="image-20200224200056115">（来自学习编程1）</li>
</ul>
</li>
<li><code>SwiftVersion</code><ul>
<li>可选</li>
<li>一个字符串，包含该“book”使用的 Swift 语言的版本。默认是 Swift 5.0 。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224200351527.png" alt="image-20200224200351527"></li>
</ul>
</li>
<li><code>MinimumSwiftPlaygroundsVersion</code><ul>
<li>可选</li>
<li>一个字符串，包含该“book”使用的最低的 Swift Playgrounds （软件）的版本。默认是 1.2 。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224200607769.png" alt="image-20200224200607769"></li>
</ul>
</li>
<li><code>UserModuleMode</code><ul>
<li>必须</li>
<li>一个字符串，用于确定用户对“book”中用户可编辑模块（“module”）的控制程度。<ul>
<li><code>Full</code><ul>
<li>用户可编辑模块，用户可以根据需要添加和删除。</li>
</ul>
</li>
<li><code>Limited</code><ul>
<li>不可移除模块（笔者认为就是不可删除，但文档中使用的是“nonremovable”）</li>
</ul>
</li>
<li><code>Disabled</code><ul>
<li>没有可用的用户可编辑模块。</li>
</ul>
</li>
</ul>
</li>
<li>这个属性从 Swift Playgrounds 3 开始使用。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224201417598.png" alt="image-20200224201417598">（来自空白模板）</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200224201356805.png" alt="image-20200224201356805">（来自学习编程1）</li>
</ul>
</li>
</ul>
<h3 id="添加“chapter”"><a href="#添加“chapter”" class="headerlink" title="添加“chapter”"></a>添加“chapter”</h3><p>创建一个带有 <code>Manifest.plist</code> 文件的文件夹，该文件描述“chapter”的名称和该“chapter”顺序。</p>
<p>使用“chapter”来按照主题来对“page”进行分组。</p>
<h4 id="创建一个“chapter”"><a href="#创建一个“chapter”" class="headerlink" title="创建一个“chapter”"></a>创建一个“chapter”</h4><p>在“book”下名为 <code>Contents</code> 的文件里，应该有一个名为 <code>Chapters</code> 的文件夹，如果没有，请创建一个。</p>
<blockquote>
<p>文件结构至少应如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">&gt; └── blank.playgroundbook</span><br><span class="line">&gt;  └── Contents</span><br><span class="line">&gt;      └── Chapters</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 <code>Chapters</code> 这个文件夹内，创建一个新的文件夹，这个文件夹必须以 <code>.playgroundchapter</code> 作为后缀结尾。这个就是我们的新的“chapter”。</p>
<p>在 Xcode 中，在这个新的“chapter”文件夹中，添加一个名为 <code>Manifest.plist</code> 的文件作为该“chapter”的属性列表。具体步骤如下：</p>
<ol>
<li>选择 （File &gt; New &gt; File…）。</li>
<li>在弹出框中找到 <code>Property List</code> 选项（在 iOS &gt; Resource 中），然后下一步。</li>
<li>将名字改为 Manifest ，创建文件。</li>
</ol>
<p>使用属性列表（<code>Manifest.plist</code>）列出“chapter”名称及其“内容”的顺序，该“内容”可以是“page”也可以是“cutscene”。</p>
<blockquote>
<p>创建完成后，文件结构应类似如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">&gt; └── example.playgroundbook</span><br><span class="line">&gt;  └── Contents</span><br><span class="line">&gt;      └── Chapters</span><br><span class="line">&gt;           └── Chapter1.playgroundchapter</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="“chapter”的属性列表"><a href="#“chapter”的属性列表" class="headerlink" title="“chapter”的属性列表"></a>“chapter”的属性列表</h4><ul>
<li>name<ul>
<li>必须</li>
<li>一个字符串，用于提供“chapter”的名称。</li>
</ul>
</li>
<li>Pages<ul>
<li>必须</li>
<li>一个字符串数组，来对“chapter”中的每一个“page”进行排序。每一个字符串代表一个以 <code>.playgroundpage</code> 结尾的目录（“page”）或者 <code>.cutscenepage</code> 结尾的目录（“cutscene”）的名称，这个目录应包含该“page”或者“cutscene”的内容和资源。</li>
</ul>
</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200225000307569.png" alt="image-20200225000307569"></li>
</ul>
<h3 id="添加“page”"><a href="#添加“page”" class="headerlink" title="添加“page”"></a>添加“page”</h3><p>创建一个子文件夹，里面包含至少两个文件：一个属性列表、一个包含“page”内容的代码文件。</p>
<p>“page”是“book”的主要内容。“page”包含了代码、散文（？笔者认为这个指的是每一个“page”的描述部分）、可能存在的实时视图，这些内容构成了打开一个“page”时 Swift Playground 呈现的界面。</p>
<h4 id="创建一个“page”"><a href="#创建一个“page”" class="headerlink" title="创建一个“page”"></a>创建一个“page”</h4><p>在想要为其创建“page”的“chapter”的目录（以 <code>.playgroundchapter</code> 为后缀的文件夹）下，创建一个子文件夹，它的名字必须以 <code>.playgroundpage</code> 结尾。</p>
<p>在 Xcode 中，在这个新的“page”文件夹中，添加一个名为 <code>Manifest.plist</code> 的文件作为该“page”的属性列表。具体步骤如下：</p>
<ol>
<li><p>选择 （File &gt; New &gt; File…）。</p>
</li>
<li><p>在弹出框中找到 <code>Property List</code> 选项（在 iOS &gt; Resource 中），然后下一步。</p>
</li>
<li><p>将名字改为 Manifest ，创建文件。</p>
<p>使用属性列表（<code>Manifest.plist</code>）列出“page”的名称和配置元数据。</p>
</li>
</ol>
<blockquote>
<p>创建完成后，文件结构应类似如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">&gt; └── example.playgroundbook</span><br><span class="line">&gt;  └── Contents</span><br><span class="line">&gt;      └── Chapters</span><br><span class="line">&gt;             └── Chapter1.playgroundchapter</span><br><span class="line">&gt;                 ├── Manifest.plist</span><br><span class="line">&gt;                 └── Pages</span><br><span class="line">&gt;                     ├── Intro.cutscenepage</span><br><span class="line">&gt;                     └── Page1.playgroundpage</span><br><span class="line">&gt;                         └── Manifest.plist</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="添加代码和散文（描述）"><a href="#添加代码和散文（描述）" class="headerlink" title="添加代码和散文（描述）"></a>添加代码和散文（描述）</h4><p>为每一个“page”创建一个 <code>main.swift</code> 的代码文件（在<code>.playgroundpage</code> 目录下）。在这个文件中，编写用户看到的一个“page”的大部分内容（代码和散文）。在这个文件中编写的代码和散文会在 Swift Playgrounds 打开这个“page”后，显示在界面的左侧。</p>
<blockquote>
<p>注意：</p>
<p>如果使用的 Swift Playground 书本格式 （<code>Swift Playground book format</code> ）在 6.0 以下下（即在“book”的属性列表（<code>Manifest.plist</code>）中的 <code>Version</code> 属性），应当使用 <code>Contents.swift</code> 而不是 <code>main.swift</code> 。</p>
</blockquote>
<p>在默认的情况下，在 <code>main.swift</code> 文件中写的所有内容都会被认为是普通的 Swift 代码，当用户点击“Run”按钮时，代码就会运行。“page”支持丰富的注释手段以便编写散文和添加功能。</p>
<h4 id="添加一个始终存在的实时视图"><a href="#添加一个始终存在的实时视图" class="headerlink" title="添加一个始终存在的实时视图"></a>添加一个始终存在的实时视图</h4><p>要在“page”上显示运行代码的结果，需要添加一个始终存在的实时视图。为了使视图显示在界面上，必须在 <code>LiveView.swift</code> 中设置当前“page”的 <code>liveView</code> 属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">PlaygroundPage</span>.current.liveView = &lt;# <span class="type">An</span> instance of <span class="type">UIView</span> or <span class="type">UIViewController</span> #&gt;</span><br></pre></td></tr></table></figure>
<h4 id="“page”的属性列表"><a href="#“page”的属性列表" class="headerlink" title="“page”的属性列表"></a>“page”的属性列表</h4><p>“Page”的属性列表（<code>Manifest.plist</code>）决定“page”的名称和用于在 Swift Playgrounds 中显示“page”的元数据。</p>
<ul>
<li>CodeCopySetup<ul>
<li>可选</li>
<li>一个字典，用于指定用户在“page”之间复制内容时阅读的说明。</li>
</ul>
</li>
<li><code>LiveViewEdgeToEdge</code><ul>
<li>必须</li>
<li>一个布尔值，用于控制实时视图的初始大小。设置为 <code>true(YES)</code> 可以填充整个实时视图区域，其中包括覆盖实时视图的“运行”和“提示”按钮。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200225000957189.png" alt="image-20200225000957189"></li>
</ul>
</li>
<li><code>LiveViewMode</code><ul>
<li>必须</li>
<li>一个字符串，当实时视图不运行时，用于控制实时视图区域是否显示。设置为 <code>VisibleByDefault</code> 可在“page”打开时显示实时视图。否则，设置为 <code>HiddenByDefault</code> 隐藏实时视图，直到用户运行“page”为止。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200225001420066.png" alt="image-20200225001420066"></li>
</ul>
</li>
<li><code>Name</code><ul>
<li>必须</li>
<li>一个字符串，用于制定在 Swift Playgrounds 中显示给用户的“page”的名称。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200225001553835.png" alt="image-20200225001553835"></li>
</ul>
</li>
<li><code>PlaygroundLoggingMode</code><ul>
<li>可选</li>
<li>一个字符串，用于指定是否在每个语句旁边显示在页面上运行的 Swift 语句的结果。设置为 <code>Normal</code> 以显示结果；否则，设置为 <code>Off</code> 。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200225001817675.png" alt="image-20200225001817675"></li>
</ul>
</li>
<li><code>PosterReference</code><ul>
<li>可选</li>
<li>一个字符串，用于引用图像文件，该文件在实时视图运行之前在实时视图区域中居中显示且不缩放。该图像文件可以位于“book”的任何“Resources”文件夹中。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200225002100391.png" alt="image-20200225002100391"></li>
</ul>
</li>
<li><code>UserModuleCodeCompletionDirectives</code><ul>
<li>可选</li>
<li>一个字符串数组，用来控制显示在输入法快捷栏中的来自“module”的代码补全或提示。每个补全的语法与在 <code>main.swift</code> 文件的代码补全定界符（code-completion delimiter）中使用的语法相同。</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200225002850984.png" alt="image-20200225002850984"></li>
</ul>
</li>
<li><code>UserModuleSourceFileToActivate</code><ul>
<li>可选</li>
<li>一个字符串，用户打开此页面时用于指定活动Swift文件。设置为一个 Swift 文件相对于“book”中Contents文件夹的路径。例如：<code>UserModules/MyModule.playgroundmodule/Sources/MyModule.swift</code> 。</li>
</ul>
</li>
<li><code>UserModuleSourceFilesToOpen</code><ul>
<li>可选</li>
<li>一个字符串数组，用户打开此页面时，用于指定应打开哪些 Swift 文件。数组元素的顺序决定了 Swift Playgrounds 界面中文件的显示顺序。</li>
</ul>
</li>
</ul>
<h3 id="添加“cutscene”"><a href="#添加“cutscene”" class="headerlink" title="添加“cutscene”"></a>添加“cutscene”</h3><p>创建一个子文件夹，里面包含两样文件：一个属性列表和“cutscene”的元数据。</p>
<p>使用“cutscene”以动画的方式解释或者介绍概念或者提要。应当将“cutscene”和“page”一同放置在“chapter”中。</p>
<h4 id="创建一个“cutscene”的文件夹"><a href="#创建一个“cutscene”的文件夹" class="headerlink" title="创建一个“cutscene”的文件夹"></a>创建一个“cutscene”的文件夹</h4><p>在想要为其创建“cutscene”的“chapter”的目录（以 <code>.playgroundchapter</code> 为后缀的文件夹）下，创建一个子文件夹，它的名字必须以 <code>cutscenepage</code> 结尾。“cutscene”文件夹需要两个部分：名为 <code>Manifest.plist</code> 的清属性列表和包含“cutscene”的 HTML 内容的 PrivateResources 文件夹。</p>
<p>在 Xcode 中，在这个新的“cutscene”文件夹中，添加一个名为 <code>Manifest.plist</code> 的文件作为该“page”的属性列表。具体步骤如下：</p>
<ol>
<li><p>选择 （File &gt; New &gt; File…）。</p>
</li>
<li><p>在弹出框中找到 <code>Property List</code> 选项（在 iOS &gt; Resource 中），然后下一步。</p>
</li>
<li><p>将名字改为 Manifest ，创建文件。</p>
<p>使用属性列表（<code>Manifest.plist</code>）列出“page”的名称和配置元数据。</p>
</li>
</ol>
<blockquote>
<p>创建完成后，文件结构应类似如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">&gt; └── Pages</span><br><span class="line">&gt;  ├── Intro.cutscenepage</span><br><span class="line">&gt;  │   ├── Manifest.plist</span><br><span class="line">&gt;  │   └── PrivateResources</span><br><span class="line">&gt;  └── Page1.playgroundpage</span><br><span class="line">&gt;      ├── Manifest.plist</span><br><span class="line">&gt;      └── main.swift</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="添加“cutscene”的资源"><a href="#添加“cutscene”的资源" class="headerlink" title="添加“cutscene”的资源"></a>添加“cutscene”的资源</h4><p>通过使用 HTML 和在 HTML 中引用的任何资源，在 Swift Playgrounds 中创建“cutscene”。 为“cutscene”编写的 HTML 可以包括 CSS ， JavaScript 和 SVG （用于动画）。 “cutscene”还可以包括图像，声音和视频等媒体。<br>将“cutscene”中使用的所有资源放在其 PrivateResources 文件夹中。</p>
<blockquote>
<p>注意：</p>
<p>如果要对“cutscene”进行本地化处理，那么就需要将“cutscene”的文件用本地化文件夹（比如：<code>en.lproj</code>）封装在 PrivateResources 文件夹中。</p>
<p>类似如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">&gt; └── Pages</span><br><span class="line">&gt;  ├── Intro.cutscenepage</span><br><span class="line">&gt;  │   ├── Manifest.plist</span><br><span class="line">&gt;  │   └── PrivateResources</span><br><span class="line">&gt;  │       ├── de.lproj</span><br><span class="line">&gt;  │       ├── en.lproj</span><br><span class="line">&gt;  │       ├── fr.lproj</span><br><span class="line">&gt;  │       ├── it.lproj</span><br><span class="line">&gt;  │       ├── ja.lproj</span><br><span class="line">&gt;  │       └── zh_CN.lproj</span><br><span class="line">&gt;  └── Page1.playgroundpage</span><br><span class="line">&gt;      ├── Manifest.plist</span><br><span class="line">&gt;      └── main.swift</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="“cutscene”的属性列表"><a href="#“cutscene”的属性列表" class="headerlink" title="“cutscene”的属性列表"></a>“cutscene”的属性列表</h4><ul>
<li><code>CutsceneReference</code><ul>
<li>必须</li>
<li>一个字符串，包含“cutscene”的动画的 HTML 文件的路径。 该路径相对于“cutscene”的 PrivateResources 文件夹。</li>
</ul>
</li>
<li><code>Name</code><ul>
<li>必须</li>
<li>一个字符串，决定“cutscene”的名称。 选择一个对在 Swift Playgrounds 中阅读的用户有意义的名称。</li>
</ul>
</li>
<li><img src="/2020/05/14/howToWriteAPlaygroundBook-1/image-20200225012514919.png" alt="image-20200225012514919"></li>
</ul>
<h3 id="添加“module”"><a href="#添加“module”" class="headerlink" title="添加“module”"></a>添加“module”</h3><p>使代码能够在多个“chapter”中使用，以此教授可复用代码的价值。（Make code available across multiple chapters to teach the value of reusable code.）</p>
<p>代码文件在整个“book”文件结构中的位置，决定了“book”中的资源能否访问到此代码文件。例如“book”中的每一个“page”的 <code>main.swift</code> 文件是互相独立的。如果一个“book”中有多个访问共享代码资源的“page”或者“chapter”，就应当将这样的代码放置在“module”中。</p>
<p>通过在“book”中共享代码，可以提供一致的 APIs 来教授统一的接口。（By sharing code throughout your book, you provide consistent APIs that teach a common interface.）</p>
<h4 id="通过“module”来共享代码"><a href="#通过“module”来共享代码" class="headerlink" title="通过“module”来共享代码"></a>通过“module”来共享代码</h4><p>“module”是 Swift 代码的文件夹，可用于定义供用户使用的API，同时还可实现页面实时视图的功能。有两种模块：</p>
<ul>
<li><p>专用模块（Private Modules）：用户无需检查或编辑的代码。在这些“module”中定义的公共 API 和文档仍然可供用户使用。将这些“module”放在 <code>.playgroundbook/Contents/Modules</code> 目录中。</p>
</li>
<li><p>用户可编辑模块（User-Editable Modules）：当代码是“book”的说明性内容的一部分时使用。例如，可以通过让用户利用前几章中的代码来解决下一章中的问题，从而教会代码重用的价值。将这些“module”放在 <code>.playgroundbook/Contents/UserModules</code> 目录中。</p>
</li>
</ul>
<p>在 Modules 或 UserModules 目录下，将每个“module”放置在以后缀 <code>.playgroundmodule</code> 结尾的新目录中。将“module”的源代码放在 <code>.playgroundmodule</code> 目录下名为 Sources 的目录下。例如，要定义一个名为“Statistics”的用户可编辑模块，请将代码放在诸如  <code>UserModules/Statistics.playgroundmodule/Sources/MyStatisticsAPIs.swift</code> 之类的路径中。<br>“module”的名称必须是有效的 Swift 标识符，因此 <code>.playgroundmodule</code> 目录名称不能包含无效的字符序列，例如空格。</p>
<blockquote>
<p>创建完成后，文件结构应类似如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; .</span><br><span class="line">&gt; └── Contents</span><br><span class="line">&gt;  ├── Chapters</span><br><span class="line">&gt;  │   └── Chapter1.playgroundchapter</span><br><span class="line">&gt;  │       ├── Manifest.plist</span><br><span class="line">&gt;  │       └── Pages</span><br><span class="line">&gt;  │           ├── Intro.cutscenepage</span><br><span class="line">&gt;  │           └── Page1.playgroundpage</span><br><span class="line">&gt;  ├── Manifest.plist</span><br><span class="line">&gt;  ├── Modules</span><br><span class="line">&gt;  │   └── Cutscenes.playgroundmodule</span><br><span class="line">&gt;  │       └── Sources</span><br><span class="line">&gt;  │           ├── SPCCutSceneItem.swift</span><br><span class="line">&gt;  │           └── SPCHypeCutSceneController.swift</span><br><span class="line">&gt;  ├── PrivateResources</span><br><span class="line">&gt;  └── UserModules</span><br><span class="line">&gt;      └── UserModule.playgroundmodule</span><br><span class="line">&gt;          └── Sources</span><br><span class="line">&gt;              └── SharedCode.swift</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>如果使用的 Swift Playground 书本格式 （<code>Swift Playground book format</code> ）在 6.0 以下下（即在“book”的属性列表（<code>Manifest.plist</code>）中的 <code>Version</code> 属性），则说明“module”不可用。 应当在与“book”，“chapter”或“page”中的 PublicResources 或 PrivateResources 目录相邻的名为 Sources 的目录下添加代码。</p>
</blockquote>
<h3 id="在“book”中共享资源"><a href="#在“book”中共享资源" class="headerlink" title="在“book”中共享资源"></a>在“book”中共享资源</h3><p>通过重复使用“book”中的素材（assets）来减少“book”的大小（储存占用）。</p>
<p>将素材（assets）放置在“book”中的位置决定了它对“book”其他部分的可见性。 如果多个“page”或“chapter”需要访问一个共享的资源，请将这样的资源放置在更靠近“book”目录结构根目录的位置。 例如，“book”的其余部分看不到“page”的 PublicResources 目录中的图像。</p>
<h4 id="创建共享资源"><a href="#创建共享资源" class="headerlink" title="创建共享资源"></a>创建共享资源</h4><p>共享资源的方式在很大程度上取决于打算在哪里使用该资源：</p>
<ul>
<li>在单个“page”或“cutscene”上共享时，请将资源放在 <code>.playgroundpage</code> 目录或 <code>.cutscenepage</code> 目录的 PublicResources 或 PrivateResources 目录中。</li>
<li>在“chapter”的“page”之间共享资源时，请将资源放在 <code>.playgroundchapter</code> 目录的 PublicResources 或 PrivateResources 目录中。</li>
<li>在整个“book”中共享资源时，请将资源放在“book”的 Contens文件夹目录中的 PublicResources 或 PrivateResources 目录中。</li>
</ul>
<p>用户可以看到并使用公共资源。 例如，如果希望用户从代码中选择几个图像之一，则将资源放置在 PublicResources 目录中； 否则，将其放在 PrivateResources 目录中。</p>
<h4 id="共享本地化资源"><a href="#共享本地化资源" class="headerlink" title="共享本地化资源"></a>共享本地化资源</h4><p>如果“book”中内容支持多个本地化，请将本地化资源放在 PublicResources 或 PrivateResources 目录中的本地化项目目录中来共享资源。 根据本地化的 Language ID 命名本地化项目的目录，后跟 <code>.lproj</code> 后缀。 例如，本地化为英语和法语的“book”可能在两个位置共享章节资源：</p>
<ul>
<li><code>mybook.playgroundbook/Contents/Chapters/ch1.playgroundchapter/PublicResources/en.lproj</code> (for the English localization).</li>
<li><code>mybook.playgroundbook/Contents/Chapters/ch1.playgroundchapter/PublicResources/fr.lproj</code> (for the French localization).</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Swift</category>
        <category>PlaygroundBook</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>PlaygroundBook</tag>
      </tags>
  </entry>
  <entry>
    <title>形式逻辑-第五版-华东师范大学出版社（1～4章）</title>
    <url>/2018/12/06/%E5%BD%A2%E5%BC%8F%E9%80%BB%E8%BE%91-%E7%AC%AC%E4%BA%94%E7%89%88-%E5%8D%8E%E4%B8%9C%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6%E5%87%BA%E7%89%88%E7%A4%BE/</url>
    <content><![CDATA[<h1 id="形式逻辑的对象和意义"><a href="#形式逻辑的对象和意义" class="headerlink" title="形式逻辑的对象和意义"></a>形式逻辑的对象和意义</h1><h2 id="形式逻辑的对象和性质"><a href="#形式逻辑的对象和性质" class="headerlink" title="形式逻辑的对象和性质"></a>形式逻辑的对象和性质</h2><h3 id="形式逻辑的对象"><a href="#形式逻辑的对象" class="headerlink" title="形式逻辑的对象"></a>形式逻辑的对象</h3><p>形式逻辑有传统和现代（即数理逻辑）之分。本书提及的是前者，也就是一门以系统介绍传统逻辑的基础知识为主的逻辑科学，也就是现在常说的普通逻辑。</p>
<p>思维的过程是对客观世界的一种概括性的间接反映过程，它具有概括性和间接性的特点。<br><a id="more"></a></p>
<ul>
<li>所有的金属都是导体</li>
<li>所有的商品都是劳动产品</li>
</ul>
<p>这些都是由一个反映判断对象的概念（主项）和一个反映判断对象属性的概念（谓项），以及一个表示对主项概念所反映的所有对象都作了断定的概念（量项）通过联系词“是”（联项）而构成的。</p>
<p>如果用S表示主项的概念，用P表示谓项概念，那么：</p>
<ul>
<li>所有S都是P</li>
</ul>
<p>这是一种常见的判断（命题）形式：全称肯定的直言判断（或命题）的形式</p>
<p>如果，用S、P、M表示推理中的三个不同概念：</p>
<ul>
<li>M是P</li>
<li>S是M</li>
<li>S是P</li>
</ul>
<p>这是最常见的推理，即三段论推理的逻辑结构，也称为三段论推理的形式逻辑。</p>
<p><strong>形式逻辑所研究的逻辑形式中，推理形式是最主要的。</strong></p>
<h3 id="形式逻辑的性质"><a href="#形式逻辑的性质" class="headerlink" title="形式逻辑的性质"></a>形式逻辑的性质</h3><h3 id="形式逻辑同数理逻辑、辩证逻辑的关系"><a href="#形式逻辑同数理逻辑、辩证逻辑的关系" class="headerlink" title="形式逻辑同数理逻辑、辩证逻辑的关系"></a>形式逻辑同数理逻辑、辩证逻辑的关系</h3><hr>
<h2 id="学习形式逻辑的意义和方法"><a href="#学习形式逻辑的意义和方法" class="headerlink" title="学习形式逻辑的意义和方法"></a>学习形式逻辑的意义和方法</h2><h3 id="学习形式逻辑的意义"><a href="#学习形式逻辑的意义" class="headerlink" title="学习形式逻辑的意义"></a>学习形式逻辑的意义</h3><h3 id="学习形式逻辑的方法"><a href="#学习形式逻辑的方法" class="headerlink" title="学习形式逻辑的方法"></a>学习形式逻辑的方法</h3><hr>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="概念的概述"><a href="#概念的概述" class="headerlink" title="概念的概述"></a>概念的概述</h2><h3 id="什么是概念"><a href="#什么是概念" class="headerlink" title="什么是概念"></a>什么是概念</h3><p>概念是思维形式最基本的组成单位，是构成命题、推理的要素。</p>
<p><strong>概念是通过揭示对象的特性或本质来反映对象的一种思维形式。</strong></p>
<h3 id="概念和语词"><a href="#概念和语词" class="headerlink" title="概念和语词"></a>概念和语词</h3><p>思想是离不开语言的，任何一个思想的产生和形式都要借助于语言，任何一个思想的表达也要借助于语言。</p>
<p>概念作为一种思维形式，离不开语言中的语词。</p>
<p>概念和语词有密切的联系。</p>
<h3 id="概念要明确"><a href="#概念要明确" class="headerlink" title="概念要明确"></a>概念要明确</h3><p>人们的行动是受思想支配的。</p>
<hr>
<h2 id="概念的内涵和外延"><a href="#概念的内涵和外延" class="headerlink" title="概念的内涵和外延"></a>概念的内涵和外延</h2><h3 id="概念的内涵和外延-1"><a href="#概念的内涵和外延-1" class="headerlink" title="概念的内涵和外延"></a>概念的内涵和外延</h3><p>概念的内涵是指反映在概念中的事物的特性或本质，概念的外延是指反映在概念中的一个个、一类类的事物。</p>
<p>了解概念的内涵和外延，对概念明确来说是十分重要的。</p>
<h3 id="概念的内涵与外延的反变关系"><a href="#概念的内涵与外延的反变关系" class="headerlink" title="概念的内涵与外延的反变关系"></a>概念的内涵与外延的反变关系</h3><p>内涵和外延是概念的两个不同方面，概念的这两个不同的方面有密切的内在联系。在这种密切联系中，有一种互相制约的关系：一个概念的内涵越多，那么这个概念的外延就会越少。反过来，如果一个概念的内涵越少，那么这个概念的外延就会越多。这种关系被称为内涵与外延的反变关系。</p>
<hr>
<h2 id="概念的种类"><a href="#概念的种类" class="headerlink" title="概念的种类"></a>概念的种类</h2><p>形式逻辑关于概念的分类，是根据概念的最一般的特征进行的。</p>
<h3 id="单独概念和普遍概念"><a href="#单独概念和普遍概念" class="headerlink" title="单独概念和普遍概念"></a>单独概念和普遍概念</h3><h4 id="单独概念"><a href="#单独概念" class="headerlink" title="单独概念"></a>单独概念</h4><p>单独概念是反映某一单独对象的概念。</p>
<ul>
<li>北京</li>
<li>华东师大</li>
<li>鲁迅</li>
</ul>
<p>这些都是单独概念，其外延都是一个独一无二的对象。</p>
<p>语言中有两种语词表达单概念：</p>
<ul>
<li>专有名词：上海、黄河</li>
<li>摹状词：通过对某一特定事物某方面特征的描述而指称该事物的一种词组。（例如：世界第一大河）</li>
</ul>
<h4 id="普遍概念"><a href="#普遍概念" class="headerlink" title="普遍概念"></a>普遍概念</h4><p>普遍概念是反映某一类对象的概念。</p>
<ul>
<li>人</li>
<li>共产党宣言的作者</li>
<li>小说</li>
<li>诗歌</li>
</ul>
<h3 id="集合概念和非集合概念"><a href="#集合概念和非集合概念" class="headerlink" title="集合概念和非集合概念"></a>集合概念和非集合概念</h3><h4 id="集合概念"><a href="#集合概念" class="headerlink" title="集合概念"></a>集合概念</h4><p>一定数量同类事物的个体可以构成一个集合体，反映这种由同类个体事物构成的不可分割的整体的概念就是集合概念。</p>
<ul>
<li>舟山群岛</li>
<li>中国工人阶级</li>
</ul>
<h4 id="非集合概念"><a href="#非集合概念" class="headerlink" title="非集合概念"></a>非集合概念</h4><p>不以这种由同类个体事物构成的集合体为反映对象的概念就是非集合概念。</p>
<ul>
<li>岛屿</li>
<li>工人</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>集合体所具有的属性，其构成分子（个体）未必具有，而分子所具有的属性，集合体也不必然具有。</p>
<p>有的语词可以在集合意义下使用，也可以在一般的分别的意义下使用。</p>
<h3 id="正概念和副概念"><a href="#正概念和副概念" class="headerlink" title="正概念和副概念"></a>正概念和副概念</h3><p>根据概念所反映的事物具有某种属性还是不具有某种属性，可分为正概念和副概念。</p>
<p>在思维中反映具有某种属性的事物的概念叫做正概念（肯定概念）</p>
<ul>
<li>金属</li>
<li>理性</li>
</ul>
<p>在思维中反映不具有某种属性的事物的概念叫做负概念（否定概念）</p>
<ul>
<li>非金属</li>
<li>非理性</li>
</ul>
<hr>
<h2 id="概念外延间的关系"><a href="#概念外延间的关系" class="headerlink" title="概念外延间的关系"></a>概念外延间的关系</h2><p>客观事物是互相联系的，因而反映事物的概念之间也是互相联系的，这就形成了概念之间的各种不同关系。</p>
<p>从外延考虑，两个概念所反映的两类事物可能是重合的，也可能是毫无重合之处的。</p>
<h3 id="概念间的相容关系"><a href="#概念间的相容关系" class="headerlink" title="概念间的相容关系"></a>概念间的相容关系</h3><h4 id="同一关系"><a href="#同一关系" class="headerlink" title="同一关系"></a>同一关系</h4><p><em>同一关系</em>是指外延完成重合的两个概念之间的关系，又称<em>全同关系</em></p>
<p>概念可定义为：“凡A是B，并且凡B是A”</p>
<p>当且仅当凡A都是B，并且凡B都是</p>
<p>同一关系的概念虽然在外延上是相同的，但内涵却有些不同，例如：“《阿Q正传》的作者”和“鲁迅”这两个概念，它们都反映鲁迅先生这个客观对象。正因为这两个概念的外延相同但内涵不同，才称为两个概念。否则，若外延和内涵都相同，那就是表达统一概念的不同词汇，例如：“马铃薯”和“土豆”</p>
<h4 id="从属关系"><a href="#从属关系" class="headerlink" title="从属关系"></a>从属关系</h4><p><em>从属关系</em>是指一个概念的外延包含着另一个概念的全部外延的这样两个概念之间的关系。例如：“学生”和“大学生”</p>
<p>在具有从属关系的两个概念中，外延大的概念称为<em>属概念</em>，外延小的概念称为<em>种概念</em>。</p>
<p>概念间的从属关系实际上表现为以下两种不同的关系（A为种概念，B为属概念）：一是A对B的关系，称为真包含与关系；一是B对A的关系，称之为真包含关系。</p>
<ul>
<li>真包含于关系<ul>
<li>一个概念，如果它的全部外延包含在另一个概念之中，并仅仅作为这另一概念的外延的一部分，那么，前一概念对后一概念之间的关系即为真包含于关系，亦称种属关系。</li>
<li>可定义为：凡A是B，有B不是A。A真包含于B可表示为，A⊂B</li>
</ul>
</li>
<li>真包含关系<ul>
<li>一个概念，如其外延包含着另一个概念的全部外延，并且，这另一概念的外延仅仅是前一概念外延的一部分，那么前一概念对后一概念之间的关系即为真包含关系，亦称属种关系。</li>
<li>可定义为：凡A是B，有B不是A。B真包含A可表示为，B⊃A</li>
</ul>
</li>
</ul>
<p>具有从属关系的两个概念，必然具有内涵于外延的反变关系，例如：“大学生”都是“学生”，“学生”不都是“大学生”</p>
<p>“车刀”和“车床”没有从属关系，因为语句“车刀是车床”不成立（大学生是学生，成立）</p>
<h4 id="交叉关系"><a href="#交叉关系" class="headerlink" title="交叉关系"></a>交叉关系</h4><p><em>交叉关系</em>就是外延有且只有一部分是重合的这样两个概念之间的关系。</p>
<p>交叉关系又称部分<em>重合关系</em></p>
<p>可定义为：有的A是B，有的A不是B，有的B不是A</p>
<p>例如：“大学生”和“共青团员”；“作家”和“教师”</p>
<p>由于交叉关系的两个概念是有互相重合的部分，因此不可在逻辑上等同于互斥关系。</p>
<p>例如：语句“鲁迅是作家，不是教师”是错误的，之中，就将“作家”和“教师”看作了互斥关系来使用。</p>
<h3 id="概念间的不相容关系"><a href="#概念间的不相容关系" class="headerlink" title="概念间的不相容关系"></a>概念间的不相容关系</h3><p>所谓概念间的不相容关系，是指外延间互相排斥，没有任何重合部分的两个概念之间的关系，因此也称全异关系。</p>
<p>所谓A、B两个概念不相容，就是所有A都不是B，所有B都不是A。</p>
<h4 id="矛盾关系"><a href="#矛盾关系" class="headerlink" title="矛盾关系"></a>矛盾关系</h4><p><em>矛盾关系</em>是指这样两个概念之间的关系，即两个概念的外延是互相排斥的，而且两个概念的外延之和穷尽了它们属概念的全部外延。</p>
<p>例如：“金属”和“非金属”</p>
<p>具有矛盾关系的两个概念往往一个是正概念，一个是负概念，但也有两个都是正概念的，例如：“阳极”和“阴极”；“男运动员”和“女运动员”</p>
<h4 id="反对关系"><a href="#反对关系" class="headerlink" title="反对关系"></a>反对关系</h4><p><em>反对关系</em>是这样两个概念之间的关系，即两个概念的外延是相互排斥的，而且这两个概念的外延之和没有穷尽它们属概念的全部外延。</p>
<p>例如：“社会主义国家”和“资本主义国家”，属概念是“国家”</p>
<h4 id="并列关系"><a href="#并列关系" class="headerlink" title="#并列关系"></a>#并列关系</h4><p>所谓概念之间的并列关系是指属于同一属概念的各个同层次的种属概念之间分关系。</p>
<p>概念间的并列关系，分为<em>相容的并列关系</em>和<em>不相容的并列关系</em></p>
<p>同一个属概念包含着的几个同层次的种概念，如果其外延是相互交叉的，那么这几个概念之间的关系就叫做相容的并列关系。</p>
<p>例如：属关系为“科学家”，那么“农学家”、“生物学家”、“化学家”就是几个相容的并列关系。</p>
<p>不相容的并列关系是指同一个属概念包含着的几个同层次的种概念，其外延彼此互相排斥，没有重合之处。</p>
<p>例如：“奴隶社会”、“资本主义社会”、“社会主义社会”</p>
<hr>
<h2 id="概念的限制和概括"><a href="#概念的限制和概括" class="headerlink" title="概念的限制和概括"></a>概念的限制和概括</h2><p>概念要明确，这是形式逻辑的基本要求之一，所谓确切地阐明各个概念，就是要阐明各个概念的确切的内涵和外延。</p>
<p>概念的内涵和外延有着相互制约的关系。当我们的思维有种概念过渡到属概念，或者由属概念过渡到种概念的时候，概念的内涵和外延在量上表现出的一种规律性的变化，这就是内涵同外延的反变关系。概念的限制和概括就是根据内涵同外延的这种反变关系，通过增加或减少概念内涵以缩小或扩大概念的外延来明确概念的一种逻辑方法。</p>
<h3 id="概念的限制"><a href="#概念的限制" class="headerlink" title="概念的限制"></a>概念的限制</h3><p>概念的限制是通过增加概念的内涵以缩小概念的外延，即由属概念过渡到种概念来明确概念的一种逻辑方法。</p>
<p>对一个外延较大的概念，可以进行多次限制，但究竟限制到哪一个较小的概念才算达到了明确概念的目的，这要看人们在表达和交流思想时的具体论域。</p>
<p>对概念进行必要的限制有助于使人们的认识具体化。</p>
<p>限制的方法只适用于普遍概念，或者说只适用于包含有种概念的属概念。由于单独概念只反映一个独一无二的对象，所以对单独概念不必也不能加以限制。</p>
<p>为了使对概念的限制真正能起到明确概念的作用，必须根据概念本身的逻辑特性和具体论域来对概念加以限制，否则就有可能犯“限制不当”的逻辑错误。例如：“对错误的谬论必须坚决予以驳斥”，其中谬论本身就包含“错误的”的含义。</p>
<h3 id="概念的概括"><a href="#概念的概括" class="headerlink" title="概念的概括"></a>概念的概括</h3><p>概念的概括是通过减少概念的内涵以扩大概念的外延，即种概念过渡到属概念以明确概念的一种逻辑方法。</p>
<p>在表达和交流思想的过程中，如果我们对某些概念作必要的概括，就可以进一步加深人们对这些概念的理解。</p>
<p>在一定范围内，对一个外延较小的概念可以连续进行概括。</p>
<p>为了使概念的概括能够真正起到明确概念的作用，同样必须根据概念本身的逻辑特性和具体论域来对概念进行概括，否则就有可能犯“概括不当”的逻辑错误。</p>
<p>例如：“不随地吐痰”是“良好的个人习惯”，是人人应该遵守的“社会公德”。这样的概括是恰当的，但将“不随地吐痰”概括为“高尚的共产主义品德”，就过分了。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="什么是定义"><a href="#什么是定义" class="headerlink" title="什么是定义"></a>什么是定义</h3><p>明确一个概念就是明确这个概念的内涵和外延。明确一个概念的内涵，就是明确这个概念所反映的对象的特点和本质。定义就是这种明确概念内涵的逻辑方法。</p>
<p>具体地说，定义揭示概念所反映的对象的特点或本质的一种逻辑方法。</p>
<p>例如：</p>
<ol>
<li>商品就是用来交换的劳动产品</li>
<li>人们在生产过程中发生的社会关系叫做生产关系。</li>
</ol>
<p>人们的认识是发展的，概念不是一成不变的，因此定义也是发展的。</p>
<p>事物有许多方面，一个定义不可能把事物的多方面本质都揭露出来。</p>
<h3 id="下定义的方法"><a href="#下定义的方法" class="headerlink" title="下定义的方法"></a>下定义的方法</h3><p>最常见的一种下定义的方法是<strong>属加种差</strong>的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">被定义项=种差+邻近的属概念</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是，揭示被定义项的种差有不同的情况。比如，前述关于“商品”、“生产关系”这两个概念的定义是通过直接揭示被定义概念所反映的客观事物所具有的本质属性来作出的。</p>
<p>另一种情况是，其种差是通过揭示事物或产生现象产生的原因来揭示事物的本质的。例如：“当地球运行到月球和太阳中间时，太阳的光正好被地球挡住，不能照射到月球上去，因此，月球上就出现黑影，这种现象叫月食。”这种定义叫<strong>发生定义</strong>。</p>
<p>还有一种情况是，种差是通过揭示被定义概念所反映的对象与对象之间关系，或它与另一个对象对第三者的关系来揭示事物本质的，这种定义叫<strong>关系定义</strong>。例如：“偶数就是能被2整除的数”，就是一种关系定义，因为它揭示了偶数与2的关系。</p>
<p>属加种差定义的方法不是任何概念都是适用的。例如：哲学范畴是对客观事物的最高概括，因而是外延最大的概念，所以就不能用属加种差的方法来下定义。但这并不是说对哲学范畴不能下定义。事实上，每一个哲学范畴都有其科学的定义。</p>
<p>上述各种定义都是通过揭示反映在概念中的对象的特质或本质来明确概念的，所以称为本质定义，亦称为真实定义。</p>
<p>另外一种定义叫<strong>词语定义</strong>。词语定义是表明某一词语表达什么概念的定义，因而是明确概念的一种辅助手段。</p>
<p>词语定义又分为<strong>说明的词语定义</strong>和<strong>规定的词语定义</strong>两种</p>
<p>所谓说明的词语定义是对某一词语已被确认的意义加以说明。</p>
<p>例如：有人不了解“乌托邦”这一词语，我们可以引用列宁的话：“乌托邦是一个希腊词语。乌托邦的意思是没有的地方，是空想、虚构和神话”。列宁的话从字源和意义上对“乌托邦”这一词语作了说明，所以是一个说明的词语定义。</p>
<p>规定的词语定义是对某一词语（或符号）规定某种意义。</p>
<p>例如：“五讲四美是指讲道德、讲文明、讲礼貌、讲秩序、讲卫生，做到心灵美、语言美、行为美、环境美”</p>
<p>又如：质能关系式“E = mc^2^”，其中“E”表示能量，“m”表示质量，“c”表示光速</p>
<h3 id="下定义应当遵守的逻辑规则"><a href="#下定义应当遵守的逻辑规则" class="headerlink" title="下定义应当遵守的逻辑规则"></a>下定义应当遵守的逻辑规则</h3><p>下定义的规则有以下四条：</p>
<ol>
<li><p>定义项与被定义项的外延必须重合</p>
<p>也就是说，定义项与被定义项必须在外延上具有全同关系，必须在外延上完全相等。</p>
<p>如果违反这条规则，定义项的外延就会比被定义项的外延多或者少。在这两种情况下，定义都不能正确揭示被定义项的内涵。</p>
<p>如：在“形式逻辑是关于直言推理的科学”这个定义中，“关于直言推理的科学”这个定义项的外延，比“形式逻辑”这个被定义的外延少，因为形式逻辑除了研究直言推理外，还研究概念、命题及一些推理。这种错误称之为<strong>“定义过窄”</strong>。</p>
<p>反之，如果把形式逻辑定义为“关于正确思维的科学”，这也不正确。因为“关于正确思维的科学”这个定义项的外延比“形式逻辑”中这个被定义项的外延多，“关于正确思维的科学”除了形式逻辑外，还有辩证逻辑等等。这种错误，逻辑上称之为<strong>“定义过宽”</strong>。</p>
</li>
<li><p>定义项不应该直接或间接地包括被定义项</p>
<p>所谓下定义就是用定义项去明确被定义项。事实上，正是因为被定义项不明确，才需要用定义项去加以明确。因此定义项本身必须是一个明确的概念。若定义项直接或间接包括被定义项，则定义项本身就不明确，因而被定义项也就无法得到明确。</p>
<p>违反这条规则的错误称为“循环定义”的错误。</p>
<p>如：“主观主义着是主观主义地观察和处理问题的人”，这就是一个循环定义，是同语反复。这是定义项直接包括被定义项的例子。</p>
<p>又如：“太阳就是白昼时发光星球(在白昼时发光的星球)”，这也是循环定义。“白昼发光的星球”这个定义间接暗含着“太阳”这个被定义项，因为“白昼”就是太阳照射在地球上的那段时间。</p>
<p>这种循环定义，在逻辑上又称为“无限循环”</p>
</li>
<li><p>定义不应包括含混的概念，不能用隐喻</p>
<p>下定义必须以简洁的语句，确切地揭示被定义项的内涵，而含混的概念和隐喻都不能明确揭示被定义项的内涵。</p>
<p>如：杜林曾给“生命”下过这样一个定义，“生命时通过塑造出来的模式化而进行的新陈代谢。”。这不仅是一个内容错误的定义，而且，从逻辑上说也是一个表述含混、模糊，而让人难明所以的概念，因而也是违反下定义的这条规则的。</p>
<p>又如：“建筑是凝固的音乐”、“儿童是祖国的花朵”，虽然很形象，意义也很深刻，但作为定义使用则不行。因为，它没有明确地、直接地揭示出被定义项的内涵。</p>
</li>
<li><p>定义不应当是否定的</p>
<p>给概念下定义就是为了明确揭示概念的内涵，因此，必须正面揭示它是什么，它具有什么性质。而如果定义是否定的，则只能说明被定义项不是什么。</p>
<p>如：“有机物不是无机物”、“经济基础不是上层建筑”，这些都是否定了它是什么，否定了它具有什么性质，而没有揭示固有的特性和本质。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我认为，若A和C是明确且成立的概念，且A真包含于C，那么“B是不属于A的C中事物”这个定义是成立的</span><br><span class="line">&quot;不属于A的C中事物&quot;这个概念本身作为定义项，对于被定义项是”是“的逻辑关系，是肯定的</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上四条规则是下定义时必须遵守的。</p>
<p>但是，仅靠这些规则对于作出一个正确的定义只是必要条件，而非充要条件。</p>
<p>要作出一个正确的定义，还必须具有有关事物的具体知识。</p>
<p>形式逻辑不能提供关于事物的具体知识，不能告诉我们事物的特点或本质是什么。要获得具体知识，掌握事物的特点或本质，就需要学习相关的科学知识，对事物进行认真的、周密的研究调查。不能认为只要掌握了几条定义规则就足以对概念作出正确的定义。</p>
<hr>
<h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><h3 id="什么是划分"><a href="#什么是划分" class="headerlink" title="什么是划分"></a>什么是划分</h3><p>要明确概念，除了依靠定义来揭示概念的内涵，揭示这个概念所反映的事物的特性和本质以外，还需要了解概念的外延，了解一个概念究竟反映哪些事物。</p>
<p><strong>划分</strong>就是帮助我们明确概念外延，从而明确概念的另一种方法。</p>
<p>要揭示一个概念的外延，往往只需将这个概念所反映的一类事物按照一定性质分为若干个小类就可以了，而不必一个一个列举这类事物所包含的个别对象。</p>
<p>如：按照矛盾性质的不同，将“社会矛盾”分为“人民内部矛盾”和“敌我矛盾”</p>
<p>又如：根据生产方式的不同，将“社会形态”分为“原始社会”、“奴隶社会”、“封建社会”、“资本主义社会”、“社会主义社会与共产主义社会”。</p>
<p>将一个概念所反映的一类事物，按照某个或某些性质分为若干个小类，这就叫<strong>划分</strong>。划分是明确概念的另一种逻辑方法。</p>
<p>划分是由三个要素组成的。被划分的概念称为划分的母项，划分后所得的概念称为划分的子项，划分时所依据的对象的属性或特征叫做划分的根据。</p>
<p>上述例子中：“社会矛盾”和“社会形态”就是母项；“人民内部矛盾”和“敌我矛盾”，以及“原始社会”、“奴隶社会”、“封建社会”、“资本主义社会”、“社会主义社会与共产主义社会”，分别是划分的子项；前一例以社会矛盾的性质作为划分的根据，后一例以社会生产方式作为划分的根据。</p>
<p>由于客观对象的属性的多样性，因此划分的根据不是唯一的。</p>
<p>划分的方法只适用于普遍概念，而不适用于单独概念。因为划分是在思维中把一个普遍概念所反映的一类对象分成若干个小类的方法，而单独概念所反映的是独一无二的对象，外延已经是明确的。所以，对单独概念没有必要，也不可能进行划分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如：“鲁迅”这个概念</span><br></pre></td></tr></table></figure>
<p>注意：划分不同于分解。划分是把一个属概念分成若干个种概念，母项与子项之间具有属种关系。而分解是在思维中把整体的对象分成若干组成部分。而就概念来说，反映整体的概念同反映部分的概念并不具有属种关系，就对象本身来说，部分不具有整体的属性。</p>
<p>如：“地球分为南半球和北半球”，这是分解。因为，“地球”这个概念与“南半球”、“北半球”这两个概念之间不具有属种关系。</p>
<h3 id="划分的种类和方法"><a href="#划分的种类和方法" class="headerlink" title="划分的种类和方法"></a>划分的种类和方法</h3><p>划分既可以是一次划分，也可以是连续划分。</p>
<p>所谓一次划分就是将一个需要明确其外延的概念只划分一次，划分的结果只有母项和子项两个层次。上面所举的例子都是一次划分。</p>
<p>连续划分就是在第一次划分之后，又根据一定的标准对第一次划分所得到的子项再进行划分，以此类推，一直到满足需求，即明确概念的外延为止。</p>
<p>此外，还有一种特殊的划分：<strong>二分法</strong>。</p>
<p>二分法是根据对象有无某种属性或特征对概念所作的划分。</p>
<p>例如：根据“战争”属否具有“正义性”，分为“正义战争”和“非正义战争”</p>
<p>二分法所得的结果只有两个项，而且是一对具有<strong>*矛盾关系</strong>的概念。而具有矛盾关系的两个概念中，往往有一个是负概念。由于负概念只表示对象不具有某种属性，因此就这个负概念本身来说其外延仍然是不明确的。</p>
<p>如：把“全厂职工”分为“党员”和“非党员”，但是“非党员”这个概念，究竟是“团员”还是“一般民众”是不明确的。但我们只需要知道党员所占比例时，用二分法就可以达到明确概念的目的。</p>
<p>划分同科学分类有联系，又有区别。划分是分类的基础，分类是划分得以进行的特殊形式。任何分类都是划分，但不是所有划分都是分类。</p>
<p>两者的区别只要是：</p>
<ol>
<li>根据不同。可以把事物互相区别开来的一切属性或特征都可以作为划分的根据，但分类必须以对象的本质属性和显著特征为根据。</li>
<li>作用不同。划分既可用于科学分类，也可用于日常实践的需要，而分类主要用于科学研究，使科学知识系统化，因而分类的结果具有长远的意义。</li>
</ol>
<h3 id="划分的规则"><a href="#划分的规则" class="headerlink" title="划分的规则"></a>划分的规则</h3><ol>
<li><p>划分应当相应相称</p>
<p>所谓划分应当相应相称是指划分所得的各子项的外延之和应该等于母项的外延。</p>
<p>违反这一条规则就会犯<strong>“划分不全”</strong>或<strong>“多出子项”</strong>的逻辑错误。</p>
</li>
<li><p>划分所得的各子项，其外延必须互相排斥</p>
<p>这就是说诸子项之间的关系必须是不相容关系。这是因为，如果诸子项之间是相容的，那就会使一些分子既属于这个子项，又属于另一子项，这就达不到明确概念外延的目的。</p>
<p>违反这一条规则就要犯<strong>“子项相容”</strong>的逻辑错误。</p>
</li>
<li><p>每次划分必须按同一标准进行</p>
<p>这就是说，每次划分的根据必须同一。这是因为，划分的根据是划分的决定因素。对于同一母项，划分根据不同，所得子项也就必然不同。因此，同一次划分只能采用同一个划分根据。</p>
<p>违反这一条规则就要犯<strong>“混淆根据”</strong>的逻辑错误。</p>
</li>
</ol>
<p>以上三条规则是相互联系的。如果违反了其中的某一条规则，就有可能同时违反另一条规则。</p>
<p>遵守划分的逻辑规则是明确概念外延的必要条件。要真正对概念作出正确的划分，还必须具备相应的具体科学知识。</p>
<hr>
<h1 id="简单命题及其推理（上）"><a href="#简单命题及其推理（上）" class="headerlink" title="简单命题及其推理（上）"></a>简单命题及其推理（上）</h1><h2 id="命题和推理的概述"><a href="#命题和推理的概述" class="headerlink" title="命题和推理的概述"></a>命题和推理的概述</h2><h3 id="命题和判断"><a href="#命题和判断" class="headerlink" title="命题和判断"></a>命题和判断</h3><p>在这里，<strong>命题</strong>是<strong>判断</strong>的语言表达，即是表达判断的语句。</p>
<p>人们是用概念这种思维形式来反映和表示事物的。</p>
<p>孤立的概念是不能说明事物的。人们为了对事物进行说明，表达一个完整的思想，就必须运用概念作出判断。</p>
<p>判断就是对事物情况有所断定的一种思维形式。</p>
<p>如：</p>
<ul>
<li>辩证唯物主义和历史唯物主义是无产阶级的世界观。</li>
<li>历史绝不是少数帝王将相的历史。</li>
</ul>
<p>这些都是判断。尽管断定的具体对象是不同的，但总是对不同的对象作出了相应的断定，即，肯定了某种对象的情况，或，否定了某种对象的情况。</p>
<p>因此，可以说，判断就是思维对象有所肯定或否定的一种思维形式。</p>
<p>这种对思维对象有所肯定或否定，乃是判断的一个基本逻辑特征。</p>
<p>正因为判断总是对思维对象有所断定的，因此，就有一个断定是否正确的问题。</p>
<p>检验判断是否正确的唯一标准是人们的社会实践。如果断定的情况被实践证明是符合客观实际的，那么这个判断就是真的；否则，就是假的。</p>
<p>任何判断都是或真或假的，这是判断的又一逻辑特征。</p>
<p>一个语句，只有当它所表达的是对事物情况有所肯定或否定、并从而是或真或假的思想时，才说这个语句表达了判断，是命题。否则，它没有表达判断，就不是命题。</p>
<p>判断是一种思想，而任何思想都必须以某种物质材料为依托。不管哪一种物质材料，只要它在思想的存在与交流中起着物质承担者的作用，都可以广义地叫做语言。</p>
<p>每一个命题都表达了一个判断，亦即都表达了对客体情况的一个断定，从这个意义上讲，命题就是判断。而由于判断是通过可见可闻的命题表现出来的，所以，判断的内容实际上也就是相应命题所表达的内容，判断的形式也就是相应的命题形式。</p>
<p>因此，以思维形式的逻辑结构为对象的形式逻辑，不是以判断，而是以判断的语言表达，即命题的形式作为直接研究对象。</p>
<h3 id="命题和语句"><a href="#命题和语句" class="headerlink" title="命题和语句"></a>命题和语句</h3><p>就命题和语言材料的关系而言，虽然任何命题都具有一定的语言形式，但，并非任何语言形式都是命题。</p>
<p>因而，任何语言形式，如果它表达的是判断，亦即如果它是命题，那么它的陈述就一定能区分为真或假，否则就不是命题。因此，就语句而言，只有或真或假的句子才是命题。</p>
<p>在各种语句中，陈述句一般是能分真假的；其他句子，如疑问句、祈使句和感叹句，除了在特定的语言环境中，一般是不能区分真假。</p>
<p>语句中相当于命题的主要是陈述句。</p>
<p>如：</p>
<ol>
<li>今天多云。</li>
<li>明天会下雨。</li>
</ol>
<p>以上陈述句都是命题，因为它们都有真假。</p>
<p>作为命题的语句，往往除了表达对于对象情况的某个断定以外，还有各种不同的语法和修饰成分，倾注着表达者个人的情感、意愿、想象等主观感受，这是自然语言特有的光彩。但是，这些语句成分是语言学而不是逻辑学的研究对象。</p>
<p>如：她那款款的、椭圆的、刻满了皱纹并且有点浮肿的脸上露出了笑容。</p>
<p>这句话所要表达的判断无非是：</p>
<ol>
<li>她的脸上露出了笑容</li>
<li>她笑了</li>
</ol>
<p>因此，这三个在逻辑学看来，表达了同一个命题。</p>
<p>命题与判断、语句并不完全相同，它们分别属于不同的科学范畴。命题是逻辑学研究的对象，判断和语句分别是认识学和语言学研究的对象。命题实质上是判断内容和语言形式的统一。</p>
<p>命题的种类很多：</p>
<ul>
<li>简单命题<ul>
<li>性质命题</li>
<li>关系命题</li>
</ul>
</li>
<li>复合命题<ul>
<li>联言命题</li>
<li>选言命题</li>
<li>假言命题</li>
<li>负命题</li>
<li>等</li>
</ul>
</li>
<li>模态命题</li>
</ul>
<h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h3><p>推理和概念、判断(命题)一样，也是一种思维形式。</p>
<p>例（1）：</p>
<p>小说是文艺作品；</p>
<p>所以有的文艺作品是小说。</p>
<p>例（2）：</p>
<p>一切文艺作品都是社会作用；</p>
<p>小说是文艺作品；</p>
<p>所以，小说有社会作用。</p>
<p>例（3）：</p>
<p>金是能够导电的；</p>
<p>银是能够导电的；</p>
<p>铜是能够导电的；</p>
<p>铁是能够导电的；</p>
<p>所以，凡金属都是能够导电的。</p>
<p>上述三个都是推理。虽然所表达的具体思想内容各不相同，但是结构上却有一个共同特点：推理都是由命题构成的，命题是推理的组成要素。</p>
<p>由此就可以给推理下这样一个简短的定义：所谓推理就是从一个或几个已知的命题出发推出另一个新命题的思维形式。</p>
<p>在推理中，把由其出发进行推理的已知命题称为前提，把由已知命题所推出的命题称为结论。任何推理，都是由一定前提推理出一定结论的过程，即由一些命题推出另一命题的过程。</p>
<p>一个正确的、能保证结论真实的推理必须具备两个条件：</p>
<ol>
<li>前提是真实的，即应当是正确反映客观事物情况的真实命题。</li>
<li>推理的前提和结论间的关系是符合思维规律的要求的，也就是说，它们之间的关系不应当是偶然的凑合，而应当是具有一定的必然联系。</li>
</ol>
<p>形式逻辑所能解决的只是：哪些推理形式是符合逻辑规则的，因而是形式正确的；哪些推理形式是不符合逻辑规则的，因而是形式不正确的。</p>
<h3 id="推理的种类与演绎推理的特征"><a href="#推理的种类与演绎推理的特征" class="headerlink" title="推理的种类与演绎推理的特征"></a>推理的种类与演绎推理的特征</h3><p>按照划分根据不同，可以将推理进行各种不同的分类。</p>
<p>在本书中，首先根据推理的思维进程方向的不同，把推理分为演绎推理、归纳推理和关系推理。</p>
<ul>
<li>演绎推理<ul>
<li>从一般性知识的前提到特殊性知识的结论的推理。</li>
</ul>
</li>
<li>归纳推理<ul>
<li>从特殊性知识的前提到一般性知识的结论的推理</li>
</ul>
</li>
<li>类比推理<ul>
<li>从特殊性知识的前提到特殊性知识的结论的推理</li>
</ul>
</li>
</ul>
<p>把命题和推理结合起来介绍：</p>
<ul>
<li>演绎推理：<ul>
<li>简单命题及其推理<ul>
<li>性质命题的直接推理</li>
<li>三段论推理</li>
<li>关系推理</li>
</ul>
</li>
<li>复合命题及其推理<ul>
<li>联言推理</li>
<li>选言推理</li>
<li>假言推理</li>
<li>负命题的等值推理</li>
<li>假言选言推理即二难推理</li>
</ul>
</li>
<li>模拟命题及其推理</li>
</ul>
</li>
<li>归纳推理：非必然性推理<ul>
<li>完全归纳推理</li>
<li>简单枚举归纳推理</li>
<li>科学归纳推理</li>
<li>类比推理</li>
</ul>
</li>
</ul>
<h4 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h4><p>人们在实际思维过程中，常常运用自己过去所获得的关于某种事物的一般性认识，去指导自己认识这类事物中某些新的个别事物，这时所运用的就是演绎推理。</p>
<p>比如，通过对上层建筑进行马克思主义的分析，可以得出某种结论：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上层建筑都是为经济基础服务的；</span><br><span class="line">文学艺术是上层建筑；</span><br><span class="line">所以，文学艺术是为经济基础服务的。</span><br></pre></td></tr></table></figure>
<p>这就是一个演绎推理。就是说，演绎推理是由反映一般性知识的前提得出有关特殊性知识的结论的一种推理。</p>
<p>由于演绎推理的前提反映的是一般性知识，而结论反映的是特殊性知识，即起结论的断定的知识范围没有超出前提所断定的知识范围，也就是说，前提的知识蕴含着结论的知识，这就决定了演绎推理的结论具有必然性，因此，演绎推理也可称为必然性推理。</p>
<p>这要在演绎推理的过程中，遵循了正确推理的两个基本要求（前提是真的，前提和结论的联系是合乎逻辑规则的），它的结论就必然是真实的。</p>
<hr>
<h2 id="性质命题"><a href="#性质命题" class="headerlink" title="性质命题"></a>性质命题</h2><h3 id="什么是性质命题"><a href="#什么是性质命题" class="headerlink" title="什么是性质命题"></a>什么是性质命题</h3><p>性质命题是简单命题（即本身不包含其他命题的命题）的一种，它是断定事物具有（或不具有）某种性质的命题。也称之为直言命题。</p>
<p>如：</p>
<ol>
<li>一切文艺作品都是有倾向性的。</li>
<li>有的国家不是社会主义国家。</li>
</ol>
<p>这两个命题都是性质命题。前者是断定文艺作品具有“有倾向性的”性质；后者断定有的国家不具有“社会主义国家”的性质。</p>
<p>通过分析这两个命题，尽管它们断定的具体内容各有不同，但都是由下述几个部分组成的：</p>
<ul>
<li><p>它们都有一个表示命题对象的概念。如上述两个命题中的“文艺作品”、“国家”。这个在命题中表示命题对象的概念，称之为命题的主项(subject)。逻辑学上通常用大写字母“S”来表示。</p>
</li>
<li><p>它们都有一个表示命题对象所具有或不具有某种性质的概念。如上述两个命题中的“有倾向性的”、“社会主义国家”。这个在命题中表示命题对象所具有或不具有的某种性质的概念，我们称之为命题的谓项(predicate)。逻辑学上通常用大写的英文字母“P”来表示。</p>
</li>
<li><p>它们都有一个用来联系主项与谓项的概念。如上述前一个命题中的“是”，后一个命题中的“不是”。这个联系主、谓项的概念我们就称之为命题的联项，通常也称之为命题的“质”。</p>
</li>
<li><p>在它们的主项前面都有一个表示命题对象数量的概念，我们称之为命题的量项(quantifier)。量项又有两种：一是例（1）中的“一切”，它表示在这个命题中对主项的全部外延作了断定，称之为“全称量项”；另一是例（2）中的“有的”，它表示在这个命题中没有对主项的全部外延作出断定，我们称之为“特称量项”。</p>
<ul>
<li>在日常讲话以及写作中，表示全称量项的词语还有“所有”、“任何”、“每一”、“凡”等等；表示，特称量项的词语还有“有些”、“有”、“某些”等等。在判断的语言表达中，全称量项的语言标志（如“所有”）可以省略，而特称量项的语言标志不能省略。</li>
</ul>
<p>据此，性质命题的逻辑结果可以表示为：所有（有的）S是（不是）P。</p>
<p>在这一逻辑结构中，量项“所有（有的）”和联项“是（不是）”是逻辑常项，主项S和谓项P是逻辑变项。</p>
<p>根据逻辑常项的不同，性质命题可以区分为不同的类型。</p>
</li>
</ul>
<h3 id="性质命题的种类"><a href="#性质命题的种类" class="headerlink" title="性质命题的种类"></a>性质命题的种类</h3><p>按照命题联项的不同，可将性质命题分为肯定命题和否定命题两类。</p>
<ul>
<li>肯定命题是断定对象具有某种性质的命题<ul>
<li>马克思列宁主义是科学真理</li>
<li>雷锋是我们学习的好榜样</li>
</ul>
</li>
<li>否定命题是断定对象不具有某种性质的命题<ul>
<li>自然科学不是上层建筑</li>
<li>有的战争不是正义的战争</li>
</ul>
</li>
</ul>
<p>按性质命题量项的不同，可以把性质命题分为：单称命题、特称命题和全称命题。</p>
<ul>
<li>单称命题是断定某一个别对象具有（或不具有）某种性质的命题。<ul>
<li>北京是中华人民共和国的首都</li>
<li>李时珍不是现代医生</li>
</ul>
</li>
<li>特称命题是断定某类事物中有对象具有（或不具有）某种性质的命题。<ul>
<li>有的农民是科学家</li>
<li>有的工人不是共产党</li>
</ul>
</li>
<li>全称命题是断定某类事物中的每一个对象都具有（或不具有）某种性质的命题<ul>
<li>所有正义的事业都是不可战胜的</li>
<li>所有被子植物都不是裸子植物</li>
</ul>
</li>
</ul>
<p>按性质命题的质和量（即逻辑常项）的不同结合，可将性质命题分为下述六种基本形式。</p>
<ul>
<li>单称肯定命题：是断定某一个别事物具有某种性质的命题。<ul>
<li>中华人名共和国是社会主义国家</li>
</ul>
</li>
<li>单称否定命题：是断定某一个别事物不具有某种性质的命题<ul>
<li>黄河不是我国最长的河流</li>
</ul>
</li>
<li>全称肯定命题：是断定一类事物的全部对象都不具有某种性质的命题<ul>
<li>所有学校都是教育机构</li>
</ul>
</li>
<li>全称否定命题：是判定一类事物的全部对象都不具有某种性质的命题<ul>
<li>一切知识都不是先天获得的</li>
</ul>
</li>
<li>特称肯定命题：是断定一类事物中有的对象具有某种性质的命题<ul>
<li>有些解放军战士是战斗英雄</li>
</ul>
</li>
<li>特称否定命题：是断定一类事物中有的对象不具有某种性质的命题<ul>
<li>有些学校不是师范学校</li>
</ul>
</li>
</ul>
<p>这里需要注意的是，在特称命题中，特称量项“有些”，在使用时，仅包含“有些……”，并不能推理出“有些不……”。同时特称命题中，特称量项所指的“有些”是一个笼统的数量。它只断定某一类事物中的有的对象具有或者不具有某种性质，并不断定或能够推理出这一类事物未被断定的对象的情况。因此，特称量项“有些”至少表示有一个。</p>
<p>由于单称命题是对某一个别对象的断定，就外延情况说，对该对象作了断定，也就是对某一概念的全部外延作了断定。因此，在一般情况下可以把单称命题当作一种全称命题来对待。</p>
<p>性质命题就可以归结为四种基本形式：</p>
<ul>
<li>全称肯定命题，逻辑形式为“所有S是P”（通常用大写的英文字母“A”来表示），可缩写为：“SAP”</li>
<li>全称否定命题，逻辑形式为“所有S不是P”（通常用大写的英文字母“E”来表示），可缩写为：“SEP”</li>
<li>特称否定命题，逻辑形式为“有的S是P”（通常用大写的英文字母“I”来表示），可缩写为：“SIP”</li>
<li>特称否定命题，逻辑形式为“有的S不是P”（通常用大写的英文字母“O”来表示），可缩写为：“SOP”</li>
</ul>
<p>英国数学家凡恩提出一种用来直观地表示概念外延间的各种不同关系的图解，通称“凡恩图解”。</p>
<p>图中的“+”号表示存在，虚线组成的阴影部分表示不存在，两个圆圈之外的长方形表示主、谓项概念的论域（全域）。那么，A、E、I、O的凡恩图表示如下：</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224010250900-5584570.png" alt="image-20181224010250900"></p>
<p>如图，运算公式可以表示为：S∩“非P” = 0 ；表示为：既属于S又属于非P的类是不存在的</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224010648700-5584808.png" alt="image-20181224010648700"></p>
<p>如图，运算公式可以表示为：S∩P = 0 ；表示为：既属于S又属于P的类是不存在的</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224014810569-5587290.png" alt="image-20181224014810569"></p>
<p>如图，运算公式可以表示为：S∩P ≠ 0 ；表示为：既属于S又属于P的类是存在的</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224015000218-5587400.png" alt="image-20181224015000218"></p>
<p>如图，运算公式可以表示为：S∩“非P” ≠ 0 ；表示为：既属于S又不属于P的类是存在的</p>
<h3 id="A、E、I、O四种性质命题的项的周延性"><a href="#A、E、I、O四种性质命题的项的周延性" class="headerlink" title="A、E、I、O四种性质命题的项的周延性"></a>A、E、I、O四种性质命题的项的周延性</h3><p>例（1）：</p>
<ul>
<li>唯心主义者不是马克思主义者</li>
<li>马克思主义者不是唯心主义者</li>
</ul>
<p>例（2）：</p>
<ul>
<li>师范大学都是高等学校</li>
<li>高等学校都是师范大学</li>
</ul>
<p>因为性质命题的周延性不同，所以例（1）中的两个命题都是正确的，而例（2）中的第二个命题显然是错误的。</p>
<h4 id="什么是性质命题的周延性？"><a href="#什么是性质命题的周延性？" class="headerlink" title="什么是性质命题的周延性？"></a>什么是性质命题的周延性？</h4><p>所谓性质命题中项的周延性是指在性质命题中，对主项、谓项外延数量的判定情况。如果在一个命题中，它的主项（或谓项）的全部外延都被作了断定，那么这个命题的主项（或谓项）就是周延的。如果没有对它的主项（或谓项）的全部外延作出断定，那么这个命题的主项（或谓项）就是不周延的。</p>
<p>接下来是特称命题的主、谓项的周延情况。</p>
<ul>
<li>特称肯定命题：周延情况正好和全称否定命题相反，其主、谓项的外延在命题中都未被全部断定，即都不周延。比如：“有的粮食作物是水田作物。”</li>
<li>特称否定命题：周延情况正好与全称肯定命题相反，即它的主项在命题中没有被断定全部外延，而谓项却被断定了全部外延。比如：“有的粮食作物不是水田作物。”</li>
</ul>
<p>据此，可以归纳为：</p>
<ul>
<li>全称肯定命题：主项周延，谓项不周延</li>
<li>全称否定命题：主项周延，谓项周延</li>
<li>特称肯定命题：主项不周延，谓项不周延</li>
<li>特称否定命题：主项不周延，谓项周延</li>
</ul>
<h3 id="主、谓项相同的A、E、I、O四种命题间的真假关系"><a href="#主、谓项相同的A、E、I、O四种命题间的真假关系" class="headerlink" title="主、谓项相同的A、E、I、O四种命题间的真假关系"></a>主、谓项相同的A、E、I、O四种命题间的真假关系</h3><p>性质命题中的主项S和谓项P实质上反映了类与类的关系。而类与类的关系有：全同关系、真包含关系、真包含于关系、交叉关系和全异关系等五种。</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224021732160-5589052.png" alt="image-20181224021732160"></p>
<p>如图：</p>
<p>SAP的真假情况是：当S与P反映了类与类之间的全同关系和真包含于关系时，SAP是真的；当S与P反映了类与类之间的真包含关系、交叉关系和全异关系时，SAP是假的。</p>
<p>SEP的真假情况是：当S与P反映了类与类之间的全同全异关系时，SEP是真的；当S与P反映了类与类之间的全同关系、真包含于关系、真包含关系和交叉关系，SEP是假的。</p>
<p>SIP的真假情况是：当S与P反映了类与类之间的全同全异关系、真包含于关系、真包含关系和交叉关系时，SIP是真的；当S与P反映了类与类之间的全异关系时，SIP是假的。</p>
<p>SOP的真假情况是：当S与P反映了类与类之间的真包含关系、交叉关系和全异关系时，SOP是真的；当S与P反映了类与类之间的全同关系和真包含于关系时，SOP是假的。</p>
<p>根据A、E、I、O的真假情况，可以确定同一素材的A、E、I、O之间的真假关系：</p>
<ol>
<li><p>反对关系：反对关系指全称肯定命题（A）与全称否定命题（B）的关系</p>
<p>可以由真推假，而不能由假推真</p>
</li>
<li><p>矛盾关系：矛盾关系是指全称肯定命题（A）与特称否定命题（O）、全称否定命题（E）与特称肯定命题（I）的关系。</p>
<p>两者可以由真推假，也可以由假推真</p>
</li>
<li><p>差等关系：差等关系是指全称肯定命题（A）与特称肯定命题（I）、全称否定命题（E）与特称否定命题（O）之间的关系。</p>
<p>如果全称命题真，特称命题必真，如果全称命题假，则特称命题真假不定；如果特称命题假，则全称命题必假，如果特称命题真，全称命题真假不定。总的来说即可同真也可同假。</p>
</li>
<li><p>下反对关系：下反对关系是指特称肯定命题（I）与特称否定命题（O）之间的关系。</p>
<p>总的来说，可以同真，但不能同假。</p>
</li>
</ol>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224023659571-5590219.png" alt="image-20181224023659571"></p>
<hr>
<h2 id="性质命题的直接推理"><a href="#性质命题的直接推理" class="headerlink" title="性质命题的直接推理"></a>性质命题的直接推理</h2><p>直接推理时最简单的演绎推理，是以一个命题为前提而推出结论的推理。</p>
<h3 id="运用命题变形法的直接推理"><a href="#运用命题变形法的直接推理" class="headerlink" title="运用命题变形法的直接推理"></a>运用命题变形法的直接推理</h3><h4 id="换质法"><a href="#换质法" class="headerlink" title="换质法"></a>换质法</h4><p>改变命题的质（命题的联项）的方法，亦即把肯定命题改变成否定命题，或者把否定命题改变成肯定命题、并将原命题的谓项概念改为其矛盾概念的方法。</p>
<ul>
<li><p>A→E</p>
<ul>
<li>所有新生事物都是有生命力的</li>
<li>所有新生事物都不是没有生命力的</li>
</ul>
</li>
<li><p>E如果A是真，则E是假，I是真，O是假；如果A是假，则E不定，I不定，O是真A</p>
<ul>
<li>教条主义者不是马克思主义者</li>
<li>教条主义者是非马克思主义者</li>
</ul>
</li>
<li>I→O<ul>
<li>有些战争是正义战争</li>
<li>有些战争不是非正义战争</li>
</ul>
</li>
<li>O→I<ul>
<li>有些干部不是称职的</li>
<li>有些干部是称职的</li>
</ul>
</li>
</ul>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224024954468-5590994.png" alt="image-20181224024954468"></p>
<h4 id="换位法"><a href="#换位法" class="headerlink" title="换位法"></a>换位法</h4><p>改变命题主词与宾词的位置的方法，亦即把命题主项与谓项的位置加以更换的方法。</p>
<ol>
<li>换位只是更换主项和谓项的位置，命题的质不变</li>
<li>换位的主项与谓项在原命题中不周延的，换位后也不得周延。</li>
</ol>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224025412552-5591252.png" alt="image-20181224025412552"></p>
<h4 id="换质位法"><a href="#换质位法" class="headerlink" title="换质位法"></a>换质位法</h4><p>把换质法和换位法结合起来连续交互运用的命题的变形法。即先进行命题换质、接着进行换位，或者接着换质、再换位，从而由原命题推出新命题。</p>
<p>换质位法不仅可以先换质后换位，也可以先换位后换质。</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224030333029-5591813.png" alt="image-20181224030333029"></p>
<h3 id="依据“逻辑方阵”的命题之间的直接关系"><a href="#依据“逻辑方阵”的命题之间的直接关系" class="headerlink" title="依据“逻辑方阵”的命题之间的直接关系"></a>依据“逻辑方阵”的命题之间的直接关系</h3><ol>
<li>如果A是真，则E是假，I是真，O是假；如果A是假，则E不定，I不定，O是真</li>
<li>如果E是真，则A是假，I是假，O是真；如果E是假，则A不定，I真，O是不定</li>
<li>如果I是真，则A不定，E是假，O不定；如果I是假，则A是假，E是真，O是真</li>
<li>如果O是真，则A是假，E不定，I不定；如果O是假，则A是真，E是假，I是真</li>
</ol>
<p>推理分为如下：</p>
<ol>
<li>真→真</li>
<li>假→假</li>
<li>真→假</li>
<li>假→真</li>
</ol>
<hr>
<h1 id="简单命题及其推理（下）"><a href="#简单命题及其推理（下）" class="headerlink" title="简单命题及其推理（下）"></a>简单命题及其推理（下）</h1><h2 id="三段论"><a href="#三段论" class="headerlink" title="三段论"></a>三段论</h2><h3 id="三段论及其结构"><a href="#三段论及其结构" class="headerlink" title="三段论及其结构"></a>三段论及其结构</h3><p>三段论是演绎推理的一种。</p>
<p>三段论是由三个简单性质命题即直言命题所组成的。前两个命题是推理的前提，后一个命题是推理的结论。并且三段论是由而且仅有三个项（概念）所组成的。</p>
<p>在三段论中，在结论中作为主项的概念称为“小项”，用S来表示；在结论中作为谓项的概念称为“大项”，用P来表示；在前提中出现而在结论中没有出现的概念称为“中项”，用M来表示。在两个前提中，有大项的前提称为“大前提”，有小项的前提称为“小前提”。</p>
<p>由此可以看出，三段论是由两个包含共同项的性质命题作为前提推理出一个性质命题作为结论的推理。</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224125907833-5627547.png" alt="image-20181224125907833"></p>
<h3 id="三段论的公理与规则"><a href="#三段论的公理与规则" class="headerlink" title="三段论的公理与规则"></a>三段论的公理与规则</h3><p>三段论的公理表述如下：一类对象的全部是什么或不是什么，那么这类对象中的部分对象也是什么或不是什么。也就是说，凡是肯定（或否定）了一类对象的全部，也就肯定（或否定）了这类对象的任何部分对象或个别对象。简单来说：凡肯定或否定了全部，也就肯定或否定了部分和个别。</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224130454264-5627894.png" alt="image-20181224130454264"></p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224130808994-5628089.png" alt="image-20181224130808994"></p>
<p>这个公理反映了客观事物中的一般和个别的关系，即属和种的包含关系。是三段论推理的逻辑根据。</p>
<p>三段论的规则概括起来共有五条：</p>
<ol>
<li><p>在三段论中，必须有而且只能有三个不同的概念（或“词项”）</p>
<p>三段论的三个概念在其重复出现的两次中，必须反映同一个对象（同一），具有相同的外延。否则就会犯四概念的错误。</p>
<p>如：</p>
<ul>
<li>我国的大学是分布于全国各地的</li>
<li>华东师范大学是我国的大学</li>
<li>所以，华东师范大学是分布于全国各地的</li>
</ul>
<p>显然这是错误的，在大前提中，我国的大学是一个集合的概念，包揽众多个体；而小前提中，我国的大学表示一种性质，即“我国的大学之一”的概念，不是集合概念。</p>
</li>
<li><p>中项在前提中必须至少周延一次</p>
<p>大、小项之所以能联系起来，组成新命题，是因为中项在前提中发挥了媒介的作用的结果。因此，如果中项在前提中一次也没有被断定过它的全部外延（周延），那么就无法起到媒介的作用，无法确定大、小项之间的必然的确定的联系，无法得出确定的结论。</p>
</li>
<li><p>大项或小项在前提中不周延，那么在结论中也不得周延</p>
<ul>
<li>大项不当扩大</li>
<li>小项不当扩大</li>
</ul>
</li>
<li><p>两个否定前提不能推出结论；前提之一否定，结论也应当是否定；结论是否定的，前提之一必须是否定的</p>
</li>
<li><p>两个特称前提不能得出结论；前提之一是特称的，结论必然是特称的</p>
</li>
</ol>
<h3 id="三段论的格与式"><a href="#三段论的格与式" class="headerlink" title="三段论的格与式"></a>三段论的格与式</h3><p>如果中项在前提中的位置确定了，那么，大项、小项的位置随之也可以确定。</p>
<p>三段论共有一下四种格：</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224134124383-5630084.png" alt="image-20181224134124383"></p>
<p>四个格的规则和有效式列举如下：（带有括号的即不存在——不符合三段论的规则）</p>
<ol>
<li><p>大前提必须全称、小前提必须肯定</p>
<p>有效式：AAA、（AAI）、AII、EAE、（EAO）、EIO</p>
</li>
<li><p>两个前提中必须有一个是否定命题、大前提必须是全称命题</p>
<p>有效式：AEE、（AEO）、AOO、EAE、（EAO）、EIO</p>
</li>
<li><p>小前提必须为肯定命题、结论必须为特称命题</p>
<p>有效式：AAI、AII、EAO、EIO、IAI、OAO</p>
</li>
<li><p>如果前提有一个是否定命题，那么大前提必须是全称命题、如果大前提是肯定命题，那么小前提必须是全称命题、如果小前提是肯定命题，那么结论必须是特称命题</p>
<p>有效式：AAI、AEE、IAI、EAO、EIO、（AEO）</p>
</li>
</ol>
<h3 id="复合三段论和省略三段论"><a href="#复合三段论和省略三段论" class="headerlink" title="复合三段论和省略三段论"></a>复合三段论和省略三段论</h3><p>在日常实际思维中，有时会将几个三段论连续运用，即进行一连串推理，又有时为了思维表达的明了简洁，省略三段论中的某个部分。因此，又有了复合三段论和省略三段论等形式。</p>
<h4 id="复合三段论"><a href="#复合三段论" class="headerlink" title="复合三段论"></a>复合三段论</h4><p>是由两个或两个以上的三段论构成的特殊的三段论形式，其中前一个三段论的结论组成后一个三段论的前提，形式有以下两种：</p>
<ol>
<li><p>前进式的复合三段论：它是以前一个三段论的结论作为后一个三段论的大前提的复合三段论。</p>
<p>在这个推理中，思维的进程是由范围较广的概念逐渐推移到范围较狭的概念，由较一般的知识推进到较特殊性的知识。</p>
<p>公式为：</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224141223184-5631943.png" alt="image-20181224141223184"></p>
</li>
<li><p>后退式的复合三段论：它是以前一个三段论的结论作为后一个三段论的小前提的复合三段论。</p>
<p>在这个推理中，思维的进程是由范围较狭的概念逐渐推移到范围较广的概念，由特殊性的知识推进到较一般性的知识，即思维推移的顺序正好和前进式相反。</p>
<p>公式为：</p>
<p><img src="/2018/12/06/形式逻辑-第五版-华东师范大学出版社/image-20181224141638676-5632198.png" alt="image-20181224141638676"></p>
</li>
</ol>
<h4 id="省略三段论"><a href="#省略三段论" class="headerlink" title="省略三段论"></a>省略三段论</h4><p>它是省略一个前提或结论的三段论。</p>
<p>一般被省略的部分带有不言而喻的性质。</p>
<p>在必要时就必须对省略三段论进行检查。而有效的检查方式就是把省略的部分补上，复原为完整的三段论。</p>
<p>复原的步骤有：</p>
<ol>
<li>先判明在省略三段论中哪一个命题是结论。</li>
<li>要找出大前提或小前提</li>
<li>依据一定的三段论格式，复原为完整的三段论。</li>
</ol>
<h3 id="用凡恩图解的方法检验三段论的有效性"><a href="#用凡恩图解的方法检验三段论的有效性" class="headerlink" title="用凡恩图解的方法检验三段论的有效性"></a>用凡恩图解的方法检验三段论的有效性</h3><hr>
<h2 id="关系命题及其推理"><a href="#关系命题及其推理" class="headerlink" title="关系命题及其推理"></a>关系命题及其推理</h2><h3 id="什么是关系命题"><a href="#什么是关系命题" class="headerlink" title="什么是关系命题"></a>什么是关系命题</h3><p>关系命题也是一种简单命题，它是断定事物与事物之间关系的命题。</p>
<p>例如：</p>
<ul>
<li>事实胜于雄辩</li>
<li>5大于3</li>
</ul>
<p>关系命题的主项有两个或两个以上。</p>
<p>因此有两项关系、三项关系，以此类推</p>
<p>任何关系命题都由三个部分组成，即：关系项、关系者项、量项。</p>
<p>例如：在教育实习中，（实习学校）有的老师表扬了（我们组的）全体同学。</p>
<p>在这里，“表扬了”是关系项，“老师”和“同学”是关系者项。“有的”和“全体”表明关系者项的外延的数量，称“量项”</p>
<p>因此可用公式表示为：</p>
<p>所有（有的）aR所有（有的）b</p>
<p>即：aRb</p>
<h3 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h3><h4 id="对称关系"><a href="#对称关系" class="headerlink" title="对称关系"></a>对称关系</h4><p>在两个事物之间，如果一个事物与另一个事物有着某种关系，另一个事物必然与这个事物有着同样的关系，那么这两个事物之间的关系称为对称关系。</p>
<p>即：aRb真，bRa真</p>
<p>“相等关系”、“相同关系”、“对立关系”、“矛盾关系”、“反对关系”、“交叉关系”等等都是对称关系</p>
<h5 id="反对称关系"><a href="#反对称关系" class="headerlink" title="反对称关系"></a>反对称关系</h5><p>在两个事物之间，如果一个事物与另一个事物有着某种关系，另一个事物必然与这个事物不具有同样的关系，那么这两个事物之间的关系称为反对称关系。</p>
<h5 id="非对称关系"><a href="#非对称关系" class="headerlink" title="非对称关系"></a>非对称关系</h5><p>在两个事物之间，如果一个事物与另一个事物有着某种关系，另一个事物必然与这个事物可能有着同样的关系，也可能没有，那么这两个事物之间的关系称为非对称关系。</p>
<h4 id="传递关系"><a href="#传递关系" class="headerlink" title="传递关系"></a>传递关系</h4><p>如果甲事物与乙事物有某种关系，乙事物与丙事物也有某种关系，因此甲事物与丙事物也具有这种关系。</p>
<p>即：aRb真、bRc真，aRc真</p>
<h5 id="反传递关系"><a href="#反传递关系" class="headerlink" title="反传递关系"></a>反传递关系</h5><p>如果甲事物与乙事物有某种关系，乙事物与丙事物也有某种关系，因此甲事物与丙事物肯定不具有这种关系。</p>
<p>即：aRb真、bRc真，aRc假</p>
<h5 id="非传递关系"><a href="#非传递关系" class="headerlink" title="非传递关系"></a>非传递关系</h5><p>如果甲事物与乙事物有某种关系，乙事物与丙事物也有某种关系，因此甲事物与丙事物可能具有这种关系，可能不具有。</p>
<p>即：aRb真、bRc真，aRc不定</p>
<h3 id="关系推理"><a href="#关系推理" class="headerlink" title="关系推理"></a>关系推理</h3><h4 id="直接的关系推理"><a href="#直接的关系推理" class="headerlink" title="直接的关系推理"></a>直接的关系推理</h4><ol>
<li><p>对称关系推理</p>
<p>根据对称性关系的逻辑性质进行推演的关系推理</p>
</li>
<li><p>反对称性关系推理</p>
<p>根据反对称性关系的逻辑性质进行推演的关系推理</p>
</li>
</ol>
<h4 id="间接的关系推理"><a href="#间接的关系推理" class="headerlink" title="间接的关系推理"></a>间接的关系推理</h4><ol>
<li><p>传递性关系推理</p>
<p>根据传递性关系的逻辑性质进行推演的关系推理</p>
</li>
<li><p>反传递性关系推理</p>
<p>根据反传递性关系的逻辑性质进行推演的关系推理</p>
</li>
</ol>
<h4 id="混合关系推理"><a href="#混合关系推理" class="headerlink" title="混合关系推理"></a>混合关系推理</h4><p>推理规则：</p>
<ol>
<li>混合关系三段论前提中的性质命题必须是肯定的。</li>
<li>媒介项的概念必须至少周延一次。因为在混合关系三段论中，有一个概念在两个前提中都出现。这个概念叫做媒介概念，与三段论的“中项”相类似。因此必须要在前提中至少周延一次</li>
<li>前提中不周延的概念在结论中不得周延</li>
<li>如果作为前提的关系命题是肯定的，则作为结论的关系命题也必须是肯定的；如果作为前提的关系命题是否定的，则作为结论的关系命题也必须是否定的。</li>
<li>如果关系R不是对称的，则在前提中作为关系者前项（或后项）的那个概念在结论中也必须相应地作为关系者前项（或后项）</li>
</ol>
]]></content>
      <categories>
        <category>哲学</category>
        <category>逻辑学</category>
        <category>形式逻辑</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>逻辑学</tag>
      </tags>
  </entry>
  <entry>
    <title>配置指南-Homebrew</title>
    <url>/2018/12/12/%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97-Homebrew/</url>
    <content><![CDATA[<h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><p>包管理工具可以让你安装和更新程序变得更方便，目前在 OS X 系统中最受欢迎的包管理工具是 Homebrew.</p>
<a id="more"></a>
<h1 id="Homebrew-1"><a href="#Homebrew-1" class="headerlink" title="Homebrew"></a>Homebrew</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装 Homebrew 之前，需要将 Xcode Command Line Tools 安装完成，这样你就可以使用基于 Xcode Command Line Tools 编译的 Homebrew。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<p>在 terminal 中复制以下命令（不包括 $），跟随指引，将完成 Hombrew 安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>紧接着，我们需要做一件事让通过 Hombrew 安装的程序的启动链接 (在 /usr/local/bin 中）可以直接运行，无需将完整路径写出。通过以下命令将 /usr/local/bin 添加至 $PATH 环境变量中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p><strong>Cmd+T</strong> 打开一个新的 terminal 标签页，运行以下命令，确保 brew 运行正常。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew doctor</span><br></pre></td></tr></table></figure>
<h2 id="安装完成后，Homwbrew-会将本地-usr-local-初始化为-git-的工作树，并将目录所有者变更为当前所操作的用户，将来-brew-的相关操作不需要-sudo-。"><a href="#安装完成后，Homwbrew-会将本地-usr-local-初始化为-git-的工作树，并将目录所有者变更为当前所操作的用户，将来-brew-的相关操作不需要-sudo-。" class="headerlink" title="安装完成后，Homwbrew 会将本地 /usr/local 初始化为 git 的工作树，并将目录所有者变更为当前所操作的用户，将来 brew 的相关操作不需要 sudo 。"></a>安装完成后，Homwbrew 会将本地 /usr/local 初始化为 git 的工作树，并将目录所有者变更为当前所操作的用户，将来 brew 的相关操作不需要 sudo 。</h2><h2 id="Homebrew-基本使用"><a href="#Homebrew-基本使用" class="headerlink" title="Homebrew 基本使用"></a>Homebrew 基本使用</h2><p>安装一个包，可以简单的运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install &lt;package_name&gt;</span><br></pre></td></tr></table></figure>
<p>更新 Homebrew 在服务器端上的包目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew update</span><br></pre></td></tr></table></figure>
<p>查看你的包是否需要更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew outdated</span><br></pre></td></tr></table></figure>
<p>更新包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew upgrade &lt;package_name&gt;</span><br></pre></td></tr></table></figure>
<p>Homebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew cleanup</span><br></pre></td></tr></table></figure>
<p>查看你安装过的包列表（包括版本号）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew list --versions</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew Cask"></a>Homebrew Cask</h2><p>你已经感受到了使用 Homebrew 安装命令行程序的便利。那么接下来，我们将通过 Homebrew Cask 优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>安装 Homebrew-cask 是如此的简单直接，运行以下命令即可完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew tap caskroom/cask  // 添加 Github 上的 caskroom/cask 库</span><br><span class="line">$ brew install brew-cask  // 安装 brew-cask</span><br><span class="line">$ brew cask install google-chrome // 安装 Google 浏览器</span><br><span class="line">$ brew update &amp;&amp; brew upgrade brew-cask &amp;&amp; brew cleanup // 更新</span><br></pre></td></tr></table></figure>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>如果你想查看 cask 上是否存在你需要的 app，可以到 <a href="http://caskroom.io/" target="_blank" rel="noopener">caskroom.io</a> 进行搜索。</p>
<h3 id="文件预览插件"><a href="#文件预览插件" class="headerlink" title="文件预览插件"></a>文件预览插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew cask install qlcolorcode</span><br><span class="line">$ brew cask install qlstephen</span><br><span class="line">$ brew cask install qlmarkdown</span><br><span class="line">$ brew cask install quicklook-json</span><br><span class="line">$ brew cask install qlprettypatch</span><br><span class="line">$ brew cask install quicklook-csv</span><br><span class="line">$ brew cask install betterzipql</span><br><span class="line">$ brew cask install webp-quicklook</span><br><span class="line">$ brew cask install suspicious-package</span><br></pre></td></tr></table></figure>
<h3 id="OS-X-图形界面程序Swift"><a href="#OS-X-图形界面程序Swift" class="headerlink" title="OS X 图形界面程序Swift"></a>OS X 图形界面程序Swift</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew cask install alfred</span><br><span class="line">$ brew cask install appcleaner</span><br><span class="line">$ brew cask install cheatsheet</span><br><span class="line">$ brew cask install dropbox</span><br><span class="line">$ brew cask install google-chrome</span><br><span class="line">$ brew cask install onepassword</span><br><span class="line">$ brew cask install sublime-text</span><br><span class="line">$ brew cask install totalfinder</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="如果你经常使用-Alfred-启动程序，那么你会想-Alfred-可以搜索-brew-cask-安装的程序，实现这些仅需运行："><a href="#如果你经常使用-Alfred-启动程序，那么你会想-Alfred-可以搜索-brew-cask-安装的程序，实现这些仅需运行：" class="headerlink" title="如果你经常使用 Alfred 启动程序，那么你会想 Alfred 可以搜索 brew cask 安装的程序，实现这些仅需运行："></a>如果你经常使用 Alfred 启动程序，那么你会想 Alfred 可以搜索 brew cask 安装的程序，实现这些仅需运行：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask alfred link</span><br></pre></td></tr></table></figure>
<h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install sublime-text</span><br><span class="line">brew cask install atom</span><br><span class="line">brew cask install google-chrome</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>配置</category>
        <category>macOS</category>
        <category>Homebrew</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>macOS</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
</search>
