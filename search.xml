<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RotationMatrix]]></title>
    <url>%2F2019%2F06%2F25%2FRotationMatrix%2F</url>
    <content type="text"><![CDATA[使用矩阵表示“旋转、平移、缩放”仿射变换仿射变换，又称仿射映射，是指在几何中，一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间。 仿射变换是在几何上定义为两个向量空间之间的一个仿射变换或者仿射映射（来自拉丁语，affine，“和…相关”）由一个非奇异的线性变换(运用一次函数进行的变换)接上一个平移变换组成。 在有限维的情况，每个仿射变换可以由一个矩阵A和一个向量b给出，它可以写作A和一个附加的列b。一个仿射变换对应于一个矩阵和一个向量的乘法，而仿射变换的复合对应于普通的矩阵乘法，只要加入一个额外的行到矩阵的底下，这一行全部是0除了最右边是一个1，而列向量的底下要加上一个1。 二维旋转变换原点首先要明白，在二维空间中，旋转指绕着某一个点旋转；而在三维空间中，旋转指绕着某一个轴。 那么最简单直观的就是绕着原点旋转： 如图所示点v 绕 原点旋转θ 角，得到点v’，假设 v点的坐标是(x, y) ，那么可以推导得到 v’点的坐标（x’, y’) \begin{array}{} 设原点到v的距离是r，原点到v点的向量与x轴的夹角是\phi \\ \because \begin{array}{} x = rcos\phi,\\ y = rsin\phi,\\ x' = rcos(\phi + \theta),\\ y' = rsin(\phi + \theta),\\ \end{array}\\ \\ \therefore \begin{array}{} 对x'和y'使用两角和公式展开：\\ x' = rcos\theta cos\phi − rsin\theta sin\phi \\ y' = rsin\theta cos\phi + rcos\theta sin\phi \\ \end{array}\\ \\ \therefore \begin{array}{} 对x和y的等式带入得：\\ x' = xcos\theta − ysin\theta \\ y' = xsin\theta + ycos\theta \\ \end{array}\\ \\令v = \left[ \begin{array}{} x\\ y \end{array} \right] 那么v'可以使用矩阵表示为：\\ v' = \left[ \begin{array}{} x'\\ y' \end{array} \right] = \left[ \begin{array}{cc} cos\theta & -sin\theta\\ sin\theta & cos\theta\\ \end{array} \right] * \left[ \begin{array}{} x\\ y \end{array} \right] \end{array}由于使用的是三角恒等式，因此将结论推广到钝角乃至更大的角度也依然成立。 任意点想象一下，一个向量（图形）在二维空间中旋转，实际上可以看作进行了相对于原点的旋转和相对于原点的平移两个行为。 那么，现在x’和y’的表达式就变成如下情况： \begin{array}{} x' = xcos\theta − ysin\theta +tx \\ y' = xsin\theta + ycos\theta +ty \\ \end{array}\\那么很明显，现在x’和y’是由三个量决定的，因此将矩阵从两列扩展到三列： \left[ \begin{array}{} x'\\ y'\\ 1 \end{array} \right] = \left[ \begin{array}{ccc} cos\theta & -sin\theta & tx\\ sin\theta & cos\theta & ty\\ 0&0&1 \end{array} \right] * \left[ \begin{array}{} x\\ y\\ 1 \end{array} \right]特别的，当没有发生变换时： \left[ \begin{array}{} x'\\ y'\\ 1 \end{array} \right] = \left[ \begin{array}{ccc} 1 & 0 & 0\\ 0 & 1 & 0\\ 0&0&1 \end{array} \right] * \left[ \begin{array}{} x\\ y\\ 1 \end{array} \right]三维旋转变换绕x轴旋转YOZ平面刚好发生二维旋转： \left[ \begin{array}{} x'\\ y'\\ z'\\ 1 \end{array} \right] = \left[ \begin{array}{c} 1 & 0 & 0 & 0\\ 0 & cos\theta & -sin\theta & 0\\ 0 & sin\theta & cos\theta & 0 \\ 0&0&0&1 \end{array} \right] * \left[ \begin{array}{} x\\ y\\ z\\ 1 \end{array} \right]绕y轴旋转XOZ平面刚好发生二维旋转： \left[ \begin{array}{} x'\\ y'\\ z'\\ 1 \end{array} \right] = \left[ \begin{array}{c} cos\theta & 0 & -sin\theta & 0\\ 0 & 1 & 0 & 0\\ sin\theta & 0 & cos\theta & 0 \\ 0&0&0&1 \end{array} \right] * \left[ \begin{array}{} x\\ y\\ z\\ 1 \end{array} \right]绕z轴旋转XOY平面刚好发生二维旋转： \left[ \begin{array}{} x'\\ y'\\ z'\\ 1 \end{array} \right] = \left[ \begin{array}{c} cos\theta & -sin\theta & 0 & 0\\ sin\theta & cos\theta & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0&0&0&1 \end{array} \right] * \left[ \begin{array}{} x\\ y\\ z\\ 1 \end{array} \right]旋转矩阵 in Swift在playground中键入并执行： 1234567import SceneKitvar node = SCNNode()node.position = SCNVector3(4, 3, 2)print("node.position")print(node.position)print("node.simdTransform")print(node.simdTransform) 你将会在终端看到： 12node.simdTransformsimd_float4x4([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [4.0, 3.0, 2.0, 1.0]]) 这里的simd_float4x4就是旋转矩阵，它描述了节点node在它的父节点空间里的位置信息。 将上述信息转换成矩阵的形式可得： \left[ \begin{array}{} 1.0 & 0.0 & 0.0 & 4.0\\ 0.0 & 1.0 & 0.0 & 3.0\\ 0.0 & 0.0 & 1.0 & 2.0\\ 0.0 & 0.0 & 0.0 & 1.0\\ \end{array} \right]三维信息 in swift对于如下一个节点： 123import SceneKitvar node = SCNNode()node.position = SCNVector3(4, 3, 2) 在终端获取它的位置(position)、旋转（rotation）： 1234print("node.position")print(node.position)print("node.rotation")print(node.rotation) 得到： 12345node.positionSCNVector3(x: 4.0, y: 3.0, z: 2.0)node.rotationSCNVector4(x: 0.0, y: 0.0, z: 0.0, w: 0.0)//四分量旋转矢量指定前三个分量中的旋转轴的方向和第四个中的旋转角度（以弧度表示）。 orientation节点的方向，表示为四元数。 四元数是用于描述三维空间中的旋转的数学构造。 虽然它的实现与4分量矢量的实现不同，但您可以使用与SCNVector4结构相同的字段指定四元数值。 SceneKit使用单位四元数（其组件满足方程x x + y y + z z + w w == 1）用于节点的方向属性。 eulerAngles节点的方向，以弧度表示为俯仰，偏航和滚转角度。 此向量中的组件顺序与旋转轴匹配： Pitch（x分量）是围绕节点x轴的旋转。 Yaw（y分量）是绕节点y轴的旋转。 Roll（z分量）是绕节点z轴的旋转。 SceneKit以与组件相反的顺序相对于节点的pivot属性应用这些旋转：首先滚动，然后是偏航，然后是俯仰。 rotation，eulerAngles和orientation属性都会影响节点转换属性的旋转方面。 对其中一个属性的任何更改都会反映在其他属性中。 scale用于选择形状的比例因子相对于包含它的节点的局部坐标空间的选项。 此键的值是包含SCNVector3结构的NSValue对象，其组件描述x轴，y轴和z轴方向中的每个方向的比例因子。 默认值为向量{1.0,1.0,1.0}，指定不更改比例。 在模拟碰撞时，SceneKit的物理模拟忽略包含物理实体的节点的比例属性。 相反，使用此选项可在创建自定义物理形状时提供比例因子。 （如果为节点创建物理主体而未指定自定义形状，则SceneKit会使用节点的scale属性在创建时推断此比例因子。） SIMD单指令流多数据流（英语：Single Instruction Multiple Data，缩写：SIMD）是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。 code12345678910func getUserVector(in frame: ARFrame?) -&gt; (direction: SCNVector3, position: SCNVector3) &#123; if let _ = frame &#123; let mat = SCNMatrix4(frame!.camera.transform) let direction = SCNVector3(-mat.m31, -mat.m32, -mat.m33) let position = SCNVector3(mat.m41, mat.m42, mat.m43) return (direction, position) &#125; else &#123; return (.zero, .zero) &#125;&#125;]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>线性代数</tag>
        <tag>SceneKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周二实验剧场：搭建个人Leanote云笔记本]]></title>
    <url>%2F2019%2F02%2F27%2FTuesday-lab-leanote%2F</url>
    <content type="text"><![CDATA[参数类型 操作计算机 服务器计算机 类型 MacBookPro 阿里云服务器ECS CPU Intel i5-8259U 1核 Memory 8192MiB 2 GB OS macOS Mojave 10.14.3 CentOS 7.3 64位 信息来源 neofetch 阿里云云服务器管理控制台 搭建个人Leanote云笔记本 文章内容来自腾讯云 开发者实验室——搭建个人Leanote云笔记本 准备MongoDBLeanote依赖MongoDB作为数据储存。 安装首先应该查看使用的服务器的操作系统是否是MongoDB支持的平台。 然后选择相应的方式安装MongoDB至你的服务器。 笔者由于是CentOS的操作系统，因此没什么兼容问题。 笔者选择上传MongoDB的源文件。 具体操作： 123graph LRA[下载] --&gt; B[解压]B --&gt; C((上传)) 启动1$ mongod --bind_ip localhost --port 27017 --dbpath /data/db/ --logpath=/var/log/mongod.log --fork 这里笔者在/home路径下新建了一个data文件夹，然后在/data/home路径下新建了db文件夹。 安装LeanoteLeanote在Github上开源，相关内容可以点击查看。 那么开始安装： 由于笔者已经在服务器上配置过ftp了，那么这里选择手动上传安装包的方式。 亦可以从Github)上找到使用源的安装方式。 具体操作： 123graph LRA[下载] --&gt; B[解压]B --&gt; C((上传)) 配置Leanote设置配置文件确保在Leanote安装目录下，键入： 1$ vim leanote/conf/appconf 修改app.secret=这一项，如： 1app.secret=qcloud666 根据Leanote官方的要求，这里需要自定义设置来保障安全。 初始化数据库确保在Leanote安装目录下，键入： 1$ mongorestore -h localhost -d leanote --dir /home/leanote/mongodb_backup/leanote_install_data/ 其中dir的位置必须对应绝对位置 启动Leanote启动在Leanote的bin目录下，键入： 1$ bash run.sh 出现： 1$ Listening on.. 0.0.0.0:9000 则启动成功。 只要在服务器安全组和防火墙开放9000端口就可以正常访问了。 外网连接购买域名并添加地址映射或者直接使用IP地址访问服务器，记得添加端口号。]]></content>
      <categories>
        <category>周二实验剧场</category>
        <category>APP</category>
      </categories>
      <tags>
        <tag>周二实验剧场</tag>
        <tag>APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome_plugin_configuration]]></title>
    <url>%2F2019%2F01%2F29%2Fchrome-plugin-configuration%2F</url>
    <content type="text"></content>
      <categories>
        <category>配置</category>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>chrome</tag>
        <tag>plug-in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 动画学习——《A GUIDE TO IOS ANIMATION 2.0》学习笔记]]></title>
    <url>%2F2019%2F01%2F15%2FUIAnmations-with-Swift%2F</url>
    <content type="text"><![CDATA[文章内容均来自于KittenYang 这是他的github主页https://github.com/KittenYang 由于书本本身是由object-c代码写的，同时正巧我正在学习iOS Animation部分来丰富UI界面的设计技术因此记录下自己的学习轨迹以及自己对于Swift的理解，希望能够帮助到以Swift为起点的iOSer。 UI设计，尤其是UI的动画设计十分有趣且富有创造性和挑战性。 它需要的不仅仅是纯coding方面的技能，因此还包含了一个人的艺术能力、设计能力、对代码的绝对熟悉程度(使用合适的代码来完成相应的功能，而Swift语言在UI方面有许多技术点)、以及想象力(将脑海中的或者视觉效果图转化成相应需要的功能甚至是技术点等) Bézier Curve前导本部分将以贝塞尔曲线为主体完成类似于以下gif的效果： ch-1 初识Bézier Curve起源和应用在数学的数值分析领域中，贝塞尔曲线（英语：Bézier curve，亦作“贝塞尔”）是计算机图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝兹曲面，其中贝兹三角是一种特殊的实例。 贝塞尔曲线于1962年，由法国工程师皮埃尔·贝兹（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由保尔·德·卡斯特里奥于1959年运用德卡斯特里奥算法开发，以稳定数值的方法求出贝塞尔曲线。 由于需要点阵化更精细的分辨率时，重新插值（补点）的计算量较小，贝塞尔曲线被广泛地在计算机图形中用来为平滑曲线建立模型。贝塞尔曲线是矢量图形文件和相应软件（如PostScript、PDF等）能够处理的唯一曲线，用于光滑地近似其他曲线。其中，二次和三次贝塞尔曲线最为常用。 实例线性贝塞尔曲线给定点P0、P1，线性贝塞尔曲线只是一条两点之间的直线。这条线由下式给出： 且其等同于线性插值。 二次方贝塞尔曲线二次方贝塞尔曲线的路径由给定点P0、P1、P2的函数B（t）追踪： TrueType字型就运用了以贝兹样条组成的二次贝塞尔曲线。 三次方贝塞尔曲线P0、P1、P2、P3四个点在平面或在三维空间中定义了三次方贝塞尔曲线。曲线起始于P0走向P1，并从P2的方向来到P3。一般不会经过P1或P2；这两个点只是在那里提供方向资讯。P0和P1之间的间距，决定了曲线在转而趋进P2之前，走向P1方向的“长度有多长”。 曲线的参数形式为： 现代的成象系统，如PostScript、Asymptote和Metafont，运用了以贝兹样条组成的三次贝塞尔曲线，用来描绘曲线轮廓。 构建线性曲线线性贝塞尔曲线函数中的t会经过由P0至P1的B（t）所描述的曲线。例如当t=0.25时，B（t）即一条由点P0至P1路径的四分之一处。就像由0至1的连续t，B（t）描述一条由P0至P1的直线。 二次曲线为建构二次贝塞尔曲线，可以中介点Q0和Q1作为由0至1的t： 由P0至P1的连续点Q0，描述一条线性贝塞尔曲线。 由P1至P2的连续点Q1，描述一条线性贝塞尔曲线。 由Q0至Q1的连续点B（t），描述一条二次贝塞尔曲线。 高阶曲线为建构高阶曲线，便需要相应更多的中介点。对于三次曲线，可由线性贝塞尔曲线描述的中介点Q0、Q1、Q2，和由二次曲线描述的点R0、R1所建构： 对于四次曲线，可由线性贝塞尔曲线描述的中介点Q0、Q1、Q2、Q3，由二次贝塞尔曲线描述的点R0、R1、R2，和由三次贝塞尔曲线描述的点S0、S1所建构： 还可参阅五阶贝塞尔曲线的构成： 这些运动轨迹使用de Casteljau算法计算出贝塞尔曲线。 引用 维基百科：贝塞尔曲线 ch-2 实例：MeliceraCircle预览 How首先，以贝塞尔曲线解析红色小球是如何构成的： 可以看到，小球由四个基准点与8个控制点(control point)组成：弧AB（cp：c1、c2）、弧BC（cp：c3、c4）、弧CD（cp：c5、c6）、弧DA（cp：c7、c8） 依据贝塞尔曲线的定义和绘制原理，通过改变这些点来改变弧的形状从而改变小球的形状 为了方便计算点的坐标，引入一个外接矩形以辅助 这里，将定义一个名为CircleLayer的类，它继承自CALayer 1class CircleLayer:CALayer&#123;&#125; 同时需要一些基准来约束和辅助 12345enum MovingPoint &#123;case POINT_Bcase POINT_D&#125;let outsideRectSize:CGFloat = 90 那么我们将采取绘制的手段将我们的小球绘制在UIView上(addSublayer)，当然这是之后的工作 依据CALayer这个类的特性，通过重写draw(in ctx: CGContext)和调用setNeedsDisplay()来达到更新我们的绘制 具体的代码如下：首先，声明一些变量作为储存属性记录需要的信息： 123private var outsideRect:CGRect! // 记录外接矩形的信息private var currentProgress:CGFloat = 0.5 // 记录当前的变形进度，以0.5为中值(圆形)private var movePoint:MovingPoint! // 记录当前移动的点(方向) 值得注意的是，这里的变量都被添加了private作为读取的权限约束 其次，声明一个名为progress的计算属性，以便于改变小球外形时只需要更新这个属性即可，而不是通过函数(不适合) 1234var progress:CGFloat = 0.0 &#123;didSet&#123;&#125;&#125; 接下来，将补充didSet{}中的内容 第一，计算外接矩形的尺寸 1234let buff = (progress - 0.5)*(frame.size.width - outsideRectSize)let origin_x = position.x - outsideRectSize/2 + bufflet origin_y = position.y - outsideRectSize/2;self.outsideRect = CGRect(x: origin_x, y: origin_y, width: outsideRectSize, height: outsideRectSize) 第二，判断变形的方向 1234567if progress &lt;= 0.5 &#123;movePoint = .POINT_Bprint("B点动")&#125;else&#123;movePoint = .POINT_Dprint("D点动")&#125; 现在，有了外接矩形，可以开始绘制工作了 先将CircleLayer补充完整(添加初始化) 1234567891011121314override init() &#123;super.init()&#125;override init(layer: Any) &#123;super.init(layer: layer)if let layer = layer as? CircleLayer &#123;progress = layer.progressoutsideRect = layer.outsideRectcurrentProgress = layer.currentProgress&#125;&#125; required init?(coder aDecoder: NSCoder) &#123;fatalError("init(code:) has not been implemented")&#125; 然后再添加draw(in ctx: CGContext)方法，并重写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495let offset = outsideRect.size.width / 3.6let movedDistance = (outsideRect.size.width * 1 / 6) * abs(self.progress - 0.5) * 2let rectCenter = CGPoint(x: outsideRect.origin.x + outsideRect.size.width / 2,y: outsideRect.origin.y + outsideRect.size.height / 2)let pointA = CGPoint(x: rectCenter.x,y: outsideRect.origin.y + movedDistance)let pointB = CGPoint(x: movePoint == .POINT_D ? rectCenter.x + outsideRect.size.width / 2:rectCenter.x + outsideRect.size.width / 2 + movedDistance * 2,y: rectCenter.y)let pointC = CGPoint(x: rectCenter.x,y: rectCenter.y + outsideRect.size.height / 2 - movedDistance)let pointD = CGPoint(x: movePoint == .POINT_D ? outsideRect.origin.x - movedDistance * 2 : outsideRect.origin.x,y: rectCenter.y)let cp1 = CGPoint(x: pointA.x + offset,y: pointA.y)let cp2 = CGPoint(x: pointB.x,y: self.movePoint == .POINT_D ? pointB.y - offset : pointB.y - offset + movedDistance)let cp3 = CGPoint(x: pointB.x,y: self.movePoint == .POINT_D ? pointB.y + offset : pointB.y + offset - movedDistance)let cp4 = CGPoint(x: pointC.x + offset,y: pointC.y)let cp5 = CGPoint(x: pointC.x - offset,y: pointC.y)let cp6 = CGPoint(x: pointD.x,y: self.movePoint == .POINT_D ? pointD.y + offset - movedDistance : pointD.y + offset)let cp7 = CGPoint(x: pointD.x,y: self.movePoint == .POINT_D ? pointD.y - offset + movedDistance : pointD.y - offset)let cp8 = CGPoint(x: pointA.x - offset,y: pointA.y)//外接虚线矩形let rectPath = UIBezierPath(rect: outsideRect)ctx.addPath(rectPath.cgPath)ctx.setStrokeColor(UIColor.black.cgColor)ctx.setLineWidth(1)let dash = [CGFloat(5.0), CGFloat(5.0)]ctx.setLineDash(phase: 0, lengths: dash)ctx.strokePath()//圆的边界let ovalPath = UIBezierPath()ovalPath.move(to: pointA)ovalPath.addCurve(to: pointB, controlPoint1: cp1, controlPoint2: cp2)ovalPath.addCurve(to: pointC, controlPoint1: cp3, controlPoint2: cp4)ovalPath.addCurve(to: pointD, controlPoint1: cp5, controlPoint2: cp6)ovalPath.addCurve(to: pointA, controlPoint1: cp7, controlPoint2: cp8)ovalPath.close()ctx.addPath(ovalPath.cgPath)ctx.setStrokeColor(UIColor.black.cgColor)ctx.setFillColor(UIColor.red.cgColor)ctx.setLineDash(phase: 0, lengths: [CGFloat]())ctx.drawPath(using: .fillStroke)//标记出每个点并连线，方便观察，给所有关键点染色 -- 白色,辅助线颜色 -- 白色ctx.setFillColor(UIColor.yellow.cgColor)ctx.setStrokeColor(UIColor.black.cgColor)let points = [NSValue(cgPoint: pointA),NSValue(cgPoint: pointB),NSValue(cgPoint: pointC),NSValue(cgPoint: pointD),NSValue(cgPoint: cp1),NSValue(cgPoint: cp2),NSValue(cgPoint: cp3),NSValue(cgPoint: cp4),NSValue(cgPoint: cp5),NSValue(cgPoint: cp6),NSValue(cgPoint: cp7),NSValue(cgPoint: cp8)]drawPoint(points: points, ctx: ctx)//连接辅助线let helperline = UIBezierPath()helperline.move(to: pointA)helperline.addLine(to: cp1)helperline.addLine(to: cp2)helperline.addLine(to: pointB)helperline.addLine(to: cp3)helperline.addLine(to: cp4)helperline.addLine(to: pointC)helperline.addLine(to: cp5)helperline.addLine(to: cp6)helperline.addLine(to: pointD)helperline.addLine(to: cp7)helperline.addLine(to: cp8)helperline.close()ctx.addPath(helperline.cgPath)let dash2 = [CGFloat(2.0), CGFloat(2.0)]ctx.setLineDash(phase: 0, lengths: dash2)ctx.strokePath() 其中，为了绘制圆点，需要使用drawPoint方法，将其添加至类中 1234567private func drawPoint(points: [NSValue], ctx: CGContext) &#123;for pointValue in points &#123;let point = pointValue.cgPointValuectx.fill(CGRect(x: point.x - 2, y: point.y - 2, width: 4, height: 4))&#125;&#125; 最后，在progress中的didSet内容的最后添加 1setNeedsDisplay() 为了能够更好地观察CircleLayer与progress之间的联动 在storyboard上添加一个UILabel和一个UISlider 添加一个名为CircleView的类 12345678910111213141516class CircleView: UIView &#123;var circleLayer = CircleLayer()override init(frame: CGRect) &#123;super.init(frame: frame)circleLayer.frame = CGRect(x: 0, y: 0, width: frame.size.width, height: frame.size.height)circleLayer.contentsScale = UIScreen.main.scalelayer.addSublayer(circleLayer)&#125;required init?(coder aDecoder: NSCoder) &#123;fatalError("init(coder:) has not been implemented")&#125;&#125; 并将ViewController改写为并连接对应的控件 1234567891011121314151617181920212223242526272829class ViewController: UIViewController &#123;@IBOutlet weak var progressLabel: UILabel!@IBOutlet weak var slider: UISlider!private var circleView: CircleView!override func viewDidLoad() &#123;super.viewDidLoad()circleView = CircleView(frame:CGRect(x: view.frame.size.width/2 - 320/2,y: view.frame.size.height/2 - 320/2,width: 320,height: 320))view.addSubview(circleView)circleView.circleLayer.progress = CGFloat(slider.value)&#125;override func didReceiveMemoryWarning() &#123;super.didReceiveMemoryWarning()&#125;@IBAction func valuechange(_ sender: UISlider) &#123;progressLabel.text = "Current: \(sender.value)"circleView.circleLayer.progress = CGFloat(sender.value)&#125;&#125; ch-3 实例：GooeySlideMenu预览 How就如同上一章节，首先要做的是拆解这个动画： 点击按钮，触发点击事件 有一个蓝色的UIView从左侧出现 这个UIView的右侧边界有一个用圆弧变成直线的动画 并且，发生了回弹 点击后返回上一页面 那么，和之前一样，构建一个名为GooeySlideMenu的类，继承自UIView 1class GooeySlideMenu: UIView &#123;&#125; 同时，如同其他的类一样GooeySlideMenu也需要初始化 但是它很特殊，因为它一直占据你的整个屏幕，因此不需要设定它的frame 尽管如此，依然需要一些额外的数据：菜单的颜色(menuColor)、模糊效果的类型(blurStyle)、菜单的宽度(menuBlankWidth) 将这些封装成一个结构体 12345struct MenuOptions &#123;var menuColor: UIColorvar blurStyle: UIBlurEffect.Stylevar menuBlankWidth: CGFloat&#125; 这个结构体将在初始化的时候用到 具体代码如下：首先，完成初始化的内容 这里需要自定义一个初始化方法，结构如下： 1init(options: MenuOptions) &#123;&#125; 这里需要用到两个属性：option、kWindow，将它们声明在类中 12private var option: MenuOptionsprivate var keyWindow: UIWindow? 那么现在开始补充init(options: MenuOptions) {} 1234567891011121314151617181920option = options// 初始化if let kWindow = UIApplication.shared.keyWindow&#123;// 判断所需的UIWindow是否存在keyWindow = kWindow// 初始化let frame = CGRect(x: -kWindow.frame.size.width/2 - options.menuBlankWidth,y: 0,width: kWindow.frame.size.width/2 + options.menuBlankWidth,height: kWindow.frame.size.height)// 计算尺寸super.init(frame:frame)// 完成父类的初始化&#125; else &#123;// 初始化无效super.init(frame:CGRect.zero)&#125;//设置其他的view，再接下来补充setUpViews() 为了让菜单能够总是在最上层不被遮挡，选择将它直接添加在UIWIndow上，也正因为如此，通过UIWindow计算frame属性 接下来，完成setUpViews()方法 1private func setUpViews() &#123;&#125; 将它写在扩展中 1extension GooeySlideMenu &#123;&#125; setUpViews()的内容如下： 这里需要额外的三个属性：blurView、helperSideView、helperCenterView 123private var blurView: UIVisualEffectView!private var helperSideView: UIView!private var helperCenterView: UIView! 接下来就是正题 123456789101112131415161718192021if let keyWindow = keyWindow &#123;blurView = UIVisualEffectView(effect: UIBlurEffect(style: option.blurStyle))blurView.frame = keyWindow.frameblurView.alpha = 0.0helperSideView = UIView(frame: CGRect(x: -40, y: 0, width: 40, height: 40))helperSideView.backgroundColor = UIColor.redhelperSideView.isHidden = truekeyWindow.addSubview(helperSideView)helperCenterView = UIView(frame: CGRect(x: -40,y: keyWindow.frame.height/2 - 20,width: 40,height: 40))helperCenterView.backgroundColor = UIColor.yellowhelperCenterView.isHidden = truekeyWindow.addSubview(helperCenterView)backgroundColor = UIColor.clearkeyWindow.insertSubview(self, belowSubview: helperSideView)&#125; 这里，使用两个被隐藏的视图来辅助完成右侧边界曲线在绘制时所需要的计算 接下来，在类中完成绘制(draw(_ rect: CGRect))的方法 和之前，在MeliceraCircle中一样，通过在适当的时候执行setNeedsDisplay()来更新视图 这里需要一个属性diff，具体的功能会在下文阐述 1private var diff: CGFloat = 0.0 具体如下 12345678910111213let path = UIBezierPath()path.move(to: CGPoint(x: 0, y: 0))path.addLine(to: CGPoint(x: frame.width-option.menuBlankWidth, y: 0))path.addQuadCurve(to: CGPoint(x: frame.width-option.menuBlankWidth,y: frame.height),controlPoint: CGPoint(x: frame.width-option.menuBlankWidth+diff,y: frame.height/2))path.addLine(to: CGPoint(x: 0, y: frame.height))path.close()let context = UIGraphicsGetCurrentContext()context?.addPath(path.cgPath)option.menuColor.set()context?.fillPath() 菜单画面的绘制由上边界、右边界、下边界组成，其中右边界是由贝塞尔曲线构成，其他都是直线 接下来，需要一个方法来计算diff 通过两个辅助视图(helperSideView helperCenterView)来计算，用以计算贝塞尔曲线中的控制点 123456789101112@objc private func handleDisplayLinkAction(displaylink: CADisplayLink) &#123;let sideHelperPresentationLayer = helperSideView.layer.presentation()!let centerHelperPresentationLayer = helperCenterView.layer.presentation()!// 捕捉实时的layer层let centerRect = centerHelperPresentationLayer.framelet sideRect = sideHelperPresentationLayer.frame// 获取捕捉到的layer层的frame数据diff = sideRect.origin.x - centerRect.origin.x// 计算setNeedsDisplay()// 绘制&#125; 现在，补充整个动画的逻辑：绘制方法受到通过两个辅助视图的位置计算而得的diff的影响，那么在辅助视图运动的时候，实时计算diff随后再重新绘制曲线，以1/60秒的速度刷新界面，完成动画 这里提到了1/60秒，也就是每秒60帧，是因为接下来要用到的重要技术：CADisplayLink 先在类中声明 1private var displayLink: CADisplayLink? 以及animationCount 1private var animationCount: Int = 0 然后在扩展中书写 123456789101112131415161718192021private func beforeAnimation() &#123;if displayLink == nil &#123;displayLink = CADisplayLink(target: self, selector: #selector(handleDisplayLinkAction(displaylink:)))// 为displayLink添加所需要刷新的内容displayLink?.add(to: RunLoop.main, forMode: RunLoop.Mode.default)// 添加至主线程&#125;animationCount+=1// 动画计数器自增&#125;private func finishAnimation() &#123;animationCount-=1// 动画计数器自减if animationCount == 0 &#123;displayLink?.invalidate()// 在合适的时候注销displayLink = nil// 并取消引用&#125;&#125; CADisplayLink能够以每秒60次的速度刷新界面，只需要把它加入主线程中即可 在我们需要的动画开始前开启CADisplayLink，然后在结束的时候判断动画是否都执行完，再根据结果注销(和timer如出一辙) 那么代码的最后一部分，完成出现(trigger())和消失(tapToUntrigger())动画的方法 由于每个方法的内容很多，这里会分成几部分讲解 首先是trigger() 123456789func trigger() &#123;if !triggered &#123;if let keyWindow = keyWindow &#123;// code&#125;&#125; else &#123;tapToUntrigger()&#125;&#125; 在将以下内容替换掉code 123456789keyWindow.insertSubview(blurView, belowSubview: self)UIView.animate(withDuration: 0.3, animations: &#123; [weak self] () -&gt; Void inself?.frame = CGRect(x: 0,y: 0,width: keyWindow.frame.size.width/2 + (self?.option.menuBlankWidth)!,height: keyWindow.frame.size.height)&#125;)// 改变使GooeySlideMenu放大至设定的尺寸 展现GooeySlideMenu 12345678beforeAnimation()// 开启刷新UIView.animate(withDuration: 0.7, delay: 0.0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.9, options:[.beginFromCurrentState,.allowUserInteraction],animations: &#123; [weak self] () -&gt; Void inself?.helperSideView.center = CGPoint(x: keyWindow.center.x, y: (self?.helperSideView.frame.size.height)!)&#125;,completion: &#123; [weak self] (finish) -&gt; Void inself?.finishAnimation()// 结束刷新&#125;) 第一步动画，调整helperSideView 其中： .beginFromCurrentState 如果这个动画 animates 了一个之前已经指定好或in-flight的动画 animated 过的属性, 那么不是取消之前的动画(立即完成所请求的变化), 如果它正常发生, 这个动画会使用显示层来决定从哪儿开始, 并且, 如果可能的话, 它会把它的动画和之前的动画混合在一块儿。 .allowUserInteraction 允许在动画执行时的用户交互 123UIView.animate(withDuration: 0.3, animations: &#123; [weak self] () -&gt; Void inself?.blurView.alpha = 1.0&#125;) 调整毛玻璃特效 12345678910beforeAnimation()UIView.animate(withDuration: 0.7, delay: 0.0, usingSpringWithDamping: 0.8, initialSpringVelocity: 2.0, options: [.beginFromCurrentState,.allowUserInteraction], animations: &#123; [weak self] () -&gt; Void inself?.helperCenterView.center = keyWindow.center&#125;, completion: &#123; [weak self] (finished) -&gt; Void inif finished &#123;let tapGesture = UITapGestureRecognizer(target: self, action: #selector(GooeySlideMenu.tapToUntrigger))self?.blurView.addGestureRecognizer(tapGesture)self?.finishAnimation()&#125;&#125;) 第二步动画，调整helperCenterView 1triggered = true 如上完成trigger()方法 接下来是tapToUntrigger()方法 1@objc private func tapToUntrigger() &#123;&#125; 填入 1234567UIView.animate(withDuration: 0.3) &#123; [weak self] () -&gt; Void inself?.frame = CGRect(x: -self!.keyWindow!.frame.size.width/2 - self!.option.menuBlankWidth,y: 0,width: self!.keyWindow!.frame.size.width/2 + self!.option.menuBlankWidth,height: self!.keyWindow!.frame.size.height)&#125; 1234567beforeAnimation()UIView.animate(withDuration: 0.7, delay: 0.0, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.9, options: [.beginFromCurrentState,.allowUserInteraction], animations: &#123; () -&gt; Void inself.helperSideView.center = CGPoint(x: -self.helperSideView.frame.height/2,y: self.helperSideView.frame.height/2)&#125;) &#123; [weak self] (finish) -&gt; Void inself?.finishAnimation()&#125; 123UIView.animate(withDuration: 0.3) &#123; () -&gt; Void inself.blurView.alpha = 0.0&#125; 1234567beforeAnimation()UIView.animate(withDuration: 0.7, delay: 0.0, usingSpringWithDamping: 0.7, initialSpringVelocity: 2.0, options: [.beginFromCurrentState,.allowUserInteraction], animations: &#123; () -&gt; Void inself.helperCenterView.center = CGPoint(x: -self.helperSideView.frame.size.height/2,y: self.frame.height/2)&#125;) &#123; (finish) -&gt; Void inself.finishAnimation()&#125; 1triggered = false 至此，GooeySlideMenu类就完成了 接下来是ViewController的内容，改写为 1234567891011121314151617181920212223242526272829303132333435363738let cellIdentifier = "demoCell"class ViewController: UIViewController &#123;var menu: GooeySlideMenu?override func viewDidLoad() &#123;super.viewDidLoad()title = "首页"let menuOptions = MenuOptions(menuColor: UIColor(red: 0.0, green: 0.722, blue: 1.0, alpha: 1.0),blurStyle: .dark,menuBlankWidth: 50.0)menu = GooeySlideMenu(options: menuOptions)&#125;@IBAction func didButtonTapped(_ sender: UIButton) &#123;menu?.trigger()&#125;override func didReceiveMemoryWarning() &#123;super.didReceiveMemoryWarning()&#125;&#125;extension ViewController: UITableViewDataSource &#123;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;let demoCell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath as IndexPath)demoCell.textLabel?.text = "NO.\(indexPath.row+1)"return demoCell&#125;func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;return 20&#125;&#125; storyboard补充成如图，并链接相应的插座函数 ch-4 实例：QQ 未读气泡的拖拽交互预览 How 首先在拖动的时候，会发现有一部分跟随拖动手势发生了位移，还有一部分依然待在原地 然后如果把首和尾两个部分想象成两个圆心在同一直线上的圆的话，不难发现： 尾部的圆在拖动时逐渐缩小至消失 首部的圆内有数字(UILabel) 以两个圆的切点在圆心的连线的同侧的切线为基准绘制粘性边界 粘性边界在拖动过程中会发生细小变化 最后可以看到在松手之后，气泡重新归位了 最后将上述几点结合，将内容分解为数学和绘制两个部分，分别用代码实现 来看一下这其中的数学问题： 其中，Tips: OA ⊥ AB, PB ⊥ AB ,且 OA=PB=d/2。 按照惯例，依然需要新建一个新工程并添加一个新文件：CuteView.swift，并引入UIKit 这次需要一个类和一个结构体： class CuteView: UIView，使用控件时调用的类 struct BubbleOptions，在初始化类时用于帮助我们设置部分必要参数 1class CuteView: UIView &#123;&#125; 1struct BubbleOptions &#123;&#125; 具体的代码如下：首先，补充结构体至： 12345678910struct BubbleOptions &#123;var text: String = ""//设置气泡内的文字内容var bubbleWidth: CGFloat = 0.0//设置气泡的直径var viscosity: CGFloat = 0.0//设置粘性边界的粘连程度var bubbleColor: UIColor = UIColor.white//设置气泡的颜色&#125; 因为是结构体，因此为了使用时安全，为所有的属性都设置了初始值。 接下来以初始化函数为起点开始coding： 1234567891011121314init(point: CGPoint, superView: UIView, options: BubbleOptions) &#123;super.init(frame: CGRect(x:point.x, y:point.y, width:options.bubbleWidth, height:options.bubbleWidth))//完成父类的初始化bubbleOptions = options//将结构体赋予类initialPoint = point//设置初始位置containerView = superView//记录父视图containerView.addSubview(self)//添加子视图setUp()//建立视图内容&#125; 由于已经将大小抽离到BubbleOptions这个结构体中，那么初始化函数的参数就变为point(视图位置) 、superView(父视图)、options(相关设置)。 那么相对应的父类的实现只需要计算对应参数即可，由于气泡是圆形的，因此用正方形的view承载即可，同时也可以看出BubbleOptions中的bubbleWidth属性是直径。 这里，构造函数中出现了几个新的属性，需要声明在类中： 1234567var bubbleOptions: BubbleOptions!&#123;didSet&#123;bubbleLabel.text = bubbleOptions.text&#125;&#125;private var initialPoint: CGPoint = CGPoint.zeroprivate var containerView: UIView! 别忘了加上必要初始化函数： 123required init?(coder aDecoder: NSCoder) &#123;fatalError("init(coder:) has not been implemented")&#125; 然后，来完成初始化函数中的setUp()函数： 在开始之前，分析一下具体的实现过程。事实上整个效果可以分为三部分： 一个随着拖动而移动的圆形视图 一个处在原地的圆形视图 一段根据两个圆形视图绘制出来的视图层(CAShapeLayer) 而这些都是直接加在父视图上的 先补充要使用到的属性，将这些写入类中： 123456789101112131415161718192021222324252627282930313233343536373839404142var frontView: UIView?//随着拖动而移动的圆形视图private var bubbleLabel: UILabel!//用来显示文字的Labelprivate var cutePath: UIBezierPath!//曲线private var fillColorForCute: UIColor!//曲线填充颜色private var animator: UIDynamicAnimator!//为其动态项提供物理相关功能和动画的对象，并为这些动画提供上下文。private var snap: UISnapBehavior!//一种弹簧状的行为，其初始运动随时间而衰减，使物体稳定在某一特定点。private var backView: UIView!//处在原地的圆形视图private var shapeLayer: CAShapeLayer!//用于显示曲线的图层private var r1: CGFloat = 0.0private var r2: CGFloat = 0.0private var x1: CGFloat = 0.0private var y1: CGFloat = 0.0private var x2: CGFloat = 0.0private var y2: CGFloat = 0.0private var centerDistance: CGFloat = 0.0//圆心距private var cosDigree: CGFloat = 0.0//圆心的连线与y轴夹角的cos值private var sinDigree: CGFloat = 0.0//圆心的连线与y轴夹角的sin值private var pointA = CGPoint.zeroprivate var pointB = CGPoint.zeroprivate var pointC = CGPoint.zeroprivate var pointD = CGPoint.zeroprivate var pointO = CGPoint.zeroprivate var pointP = CGPoint.zeroprivate var oldBackViewFrame: CGRect = CGRect.zero//记录初始状态下BackView的尺寸private var oldBackViewCenter: CGPoint = CGPoint.zero//记录初始状态下BackView的位置 随后声明方法setUp()： 1private func setUp() &#123;&#125; 接下来一步步完成这个方法： 视图层 1234567891011121314151617181920212223242526272829303132333435363738394041424344shapeLayer = CAShapeLayer()//实例图层backgroundColor = UIColor.clear//将CuteView的背景颜色设置为透明frontView = UIView(frame: CGRect(x: initialPoint.x, y: initialPoint.y, width: bubbleOptions.bubbleWidth, height: bubbleOptions.bubbleWidth))//实例frontViewguard let frontView = frontView else &#123;print("frontView is nil")return&#125;//判断frontView是否存在r2 = frontView.bounds.size.width / 2.0//计算r2frontView.layer.cornerRadius = r2//设置frontView的圆角frontView.backgroundColor = bubbleOptions.bubbleColor//设置frontView的背景颜色backView = UIView(frame: frontView.frame)//实例backView，和frontView一样大小位置r1 = backView.bounds.size.width / 2//计算r1backView.layer.cornerRadius = r1//设置backView的圆角backView.backgroundColor = bubbleOptions.bubbleColor//设置backView的背景颜色bubbleLabel = UILabel()//实例labelbubbleLabel.frame = CGRect(x: 0, y: 0, width: frontView.bounds.width, height: frontView.bounds.height)//设置label的大小位置bubbleLabel.textColor = UIColor.white//设置label的字体颜色bubbleLabel.textAlignment = .center//设置label的字体居中bubbleLabel.text = bubbleOptions.text//这只label的字体内容frontView.insertSubview(bubbleLabel, at: 0)//在frontview中插入labelcontainerView.addSubview(backView)//添加backViewcontainerView.addSubview(frontView)//添加frontView 计算其余的属性 1234567891011x1 = backView.center.xy1 = backView.center.yx2 = frontView.center.xy2 = frontView.center.ypointA = CGPoint(x:x1-r1,y:y1) // ApointB = CGPoint(x:x1+r1, y:y1) // BpointD = CGPoint(x:x2-r2, y:y2) // DpointC = CGPoint(x:x2+r2, y:y2) // CpointO = CGPoint(x:x1-r1,y:y1) // OpointP = CGPoint(x:x2+r2, y:y2) // P 记录backView的旧参数并为frontView添加手势 12345oldBackViewFrame = backView.frameoldBackViewCenter = backView.centerlet panGesture = UIPanGestureRecognizer(target: self, action: #selector(handleDragGesture(ges:)))frontView.addGestureRecognizer(panGesture) 接下来完成拖拽手势： 1234567891011121314151617181920212223242526272829303132333435363738@objc private func handleDragGesture(ges: UIPanGestureRecognizer) &#123;let dragPoint = ges.location(in: containerView)//记录拖拽手势的位置if ges.state == .began &#123;// 不给r1赋初始值的话，如果第一次拖动使得r1少于6，第二次拖动就直接隐藏绘制路径了r1 = oldBackViewFrame.width / 2//设置r1backView.isHidden = false//隐藏backViewfillColorForCute = bubbleOptions.bubbleColor//设置曲线填充的颜色&#125; else if ges.state == .changed &#123;frontView?.center = dragPoint//使frontView发生位移，跟随拖拽点if r1 &lt;= 6 &#123;//如果r1过小就使得粘连部分消失fillColorForCute = UIColor.clearbackView.isHidden = trueshapeLayer.removeFromSuperlayer()&#125;drawRect()//绘制曲线&#125; else if ges.state == .ended || ges.state == .cancelled || ges.state == .failed &#123;//当拖拽手势结束时，消除粘连部分并将frontView弹回原来的位置backView.isHidden = truefillColorForCute = UIColor.clearshapeLayer.removeFromSuperlayer()//使用带有类似弹簧效果的UIView.animate使得移动动画富有弹性UIView.animate(withDuration: 0.5, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 0.0, options: .curveEaseInOut, animations: &#123; [weak self] () -&gt; Void inif let strongsSelf = self &#123;strongsSelf.frontView?.center = strongsSelf.oldBackViewCenter//设置位移&#125;&#125;, completion: &#123; [weak self] (finished) -&gt; Void inif let strongsSelf = self &#123;&#125;&#125;)&#125;&#125; 然后完成drawRect()： 1private func drawRect() &#123;&#125; 判断frontView是否存在 123guard let frontView = frontView else&#123;return&#125; 计算在frontView位移后的绘制相关的属性 12345678910111213141516171819202122232425x1 = backView.center.xy1 = backView.center.yx2 = frontView.center.xy2 = frontView.center.ycenterDistance = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))//两点间距离公式//分别计算有无位移时的正弦和余弦if centerDistance == 0 &#123;cosDigree = 1sinDigree = 0&#125;else&#123;cosDigree = (y2-y1)/centerDistancesinDigree = (x2-x1)/centerDistance&#125;r1 = oldBackViewFrame.size.width / 2 - centerDistance/bubbleOptions.viscosity//计算backView的大小（半径）pointA = CGPoint(x:x1-r1*cosDigree, y:y1+r1*sinDigree) // ApointB = CGPoint(x:x1+r1*cosDigree, y:y1-r1*sinDigree) // BpointD = CGPoint(x:x2-r2*cosDigree, y:y2+r2*sinDigree) // DpointC = CGPoint(x:x2+r2*cosDigree, y:y2-r2*sinDigree) // CpointO = CGPoint(x:pointA.x + (centerDistance / 2)*sinDigree, y:pointA.y + (centerDistance / 2)*cosDigree)pointP = CGPoint(x:pointB.x + (centerDistance / 2)*sinDigree, y:pointB.y + (centerDistance / 2)*cosDigree) 设置backView 123backView.center = oldBackViewCenter;backView.bounds = CGRect(x:0, y:0, width:r1*2, height:r1*2);backView.layer.cornerRadius = r1; 绘制曲线 123456cutePath = UIBezierPath()cutePath.move(to: pointA)cutePath.addQuadCurve(to: pointD, controlPoint: pointO)cutePath.addLine(to: pointC)cutePath.addQuadCurve(to: pointB, controlPoint: pointP)cutePath.move(to: pointA) 添加曲线 12345if backView.isHidden == false &#123;shapeLayer.path = cutePath.cgPathshapeLayer.fillColor = fillColorForCute.cgColorcontainerView.layer.insertSublayer(shapeLayer, below: frontView.layer)&#125; 至此，仿照QQ未读气泡的拖拽效果就完成了 在ViewController中写入一下内容就可以查看效果了： 12345678910111213override func viewDidLoad() &#123;super.viewDidLoad()var option = BubbleOptions()option.viscosity = 20.0option.bubbleWidth = 35.0option.bubbleColor = UIColor(red: 0.0, green: 0.722, blue: 1.0, alpha: 1.0)let cuteView = CuteView(point: CGPoint(x:25, y:UIScreen.main.bounds.size.height - 65), superView: view, options: option)option.text = "20"cuteView.bubbleOptions = option&#125; One More Thing放大看看未拖拽时的气泡： 你是否发现它在晃动！ 那么这个效果是怎么实现的呢！ 为CuteView加上扩展就可以了！ 这个晃动分为两个部分： 气泡的位移 气泡的变形 细节如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374extension CuteView &#123;private func addAniamtionLikeGameCenterBubble() &#123;//设置位移let pathAnimation = CAKeyframeAnimation(keyPath: "position")//为层对象提供关键帧动画功能的对象pathAnimation.calculationMode = CAAnimationCalculationMode.paced//线性关键帧值插值，以产生一个均匀的速度在整个动画pathAnimation.fillMode = CAMediaTimingFillMode.forwards//当动画完成时，接收器保持可见的最终状态pathAnimation.isRemovedOnCompletion = false//确定动画完成后是否从目标层的动画中删除。pathAnimation.repeatCount = Float.infinity//确定动画将重复的次数pathAnimation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.linear)//一种函数，它将动画的节奏定义为时间曲线//线性节奏，使动画在其持续时间内均匀地发生pathAnimation.duration = 5.0//设置动画的单次执行时间let curvedPath = CGMutablePath()guard let frontView = frontView else &#123;print("frontView is nil!")return&#125;let circleContainer = frontView.frame.insetBy(dx: frontView.bounds.width / 2 - 3, dy: frontView.bounds.size.width / 2 - 3)//获取frontView的尺寸并计算运动范围curvedPath.addEllipse(in: circleContainer)//添加一个适合于指定矩形的椭圆pathAnimation.path = curvedPath//设置动画的路径frontView.layer.add(pathAnimation, forKey: "circleAnimation")//添加动画let scaleX = CAKeyframeAnimation(keyPath: "transform.scale.x")scaleX.duration = 1.0scaleX.values = [NSNumber(value: 1.0),NSNumber(value: 1.1),NSNumber(value: 1.0)]//指定动画使用的关键帧值的对象数组//关键帧值表示动画必须通过的值。给定关键帧值应用于该层的时间取决于动画计时，动画计时由calculationMode、keyTimes和timingFunctions属性控制。关键帧之间的值是使用插值创建的，除非计算模式设置为离散的。根据属性的类型，您可能需要使用NSValue对象的NSNumber包装此数组中的值。对于某些核心图形数据类型，可能还需要在将其添加到数组之前将其转换为id。仅当path属性中的值为nil时才使用此属性中的值。scaleX.keyTimes = [NSNumber(value: 0.0), NSNumber(value: 0.5), NSNumber(value: 1.0)]//NSNumber对象的可选数组，定义应用给定关键帧段的时间//数组中的每个值都是一个介于0.0和1.0之间的浮点数，它定义了应用相应关键帧值的时间点(指定为动画总持续时间的一部分)。数组中的每个连续值必须大于或等于前一个值。通常，数组中的元素数量应该与values属性中的元素数量或path属性中的控制点数量匹配。如果他们没有，你的动画的时间可能不是你所期望的scaleX.repeatCount = Float.infinityscaleX.autoreverses = true//确定完成后接收器是否反向播放scaleX.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)//一个可选的CAMediaTimingFunction对象数组，用于定义每个关键帧段的速度//可以使用此数组将易入、易出或自定义时间曲线应用于位于两个关键帧值之间的点。如果values属性中的关键帧数为n，那么该属性应该包含n-1个对象。//如果在keyTimes属性中提供计时信息，则使用此属性指定的计时函数将进一步修改这些值之间的计时。如果没有给keyTimes属性赋值，计时函数将修改动画对象提供的默认计时。//如果还在动画对象的timingFunction属性中指定了一个计时函数，则首先应用该函数，然后是特定关键帧段的计时函数。frontView.layer.add(scaleX, forKey: "scaleXAnimation")let scaleY = CAKeyframeAnimation(keyPath: "transform.scale.y")scaleY.duration = 1.5scaleY.values = [NSNumber(value: 1.0),NSNumber(value: 1.1),NSNumber(value: 1.0)]scaleY.keyTimes = [NSNumber(value: 0.0), NSNumber(value: 0.5), NSNumber(value: 1.0)]scaleY.repeatCount = Float.infinityscaleY.autoreverses = truescaleY.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)frontView.layer.add(scaleY, forKey: "scaleYAnimation")&#125;private func removeAniamtionLikeGameCenterBubble() &#123;if let frontView = frontView &#123;frontView.layer.removeAllAnimations()&#125;&#125;&#125; 随后在setUp()中添加： 1addAniamtionLikeGameCenterBubble() 在handleDragGesture()中的UIView.animate的completion中添加成： 123if let strongsSelf = self &#123;strongsSelf.addAniamtionLikeGameCenterBubble()&#125; 在handleDragGesture()中的if ges.state == .began {}里添加 1removeAniamtionLikeGameCenterBubble() 以上就是所有的内容。 ch-5 实例：LiquidLoader Core Animation前导Core Animation是一个可以在iOS和OS X上使用的图形渲染和动画基础架构，你可以使用它为你的应用程序的视图和其他视觉元素添加动画。你所要做的就是配置一些动画参数(如起点和终点)并告诉Core animation开始。Core Animation就会完成剩下的工作，将大部分实际绘制工作交给板载图形硬件来加速渲染。这种自动图形加速的结果是高帧率和平滑的动画，而不增加CPU负担和减慢您的应用程序。 Core Animation位于AppKit和UIKit之下，并被紧密集成到Cocoa和Cocoa Touch的视图工作流中。当然，Core Animation也有一些接口，可以扩展应用程序视图所公开的功能，并对应用程序的动画进行更细粒度的控制。 Animation and Haptics(UIKit) Animating Views with Block Objects(UIView)]]></content>
      <categories>
        <category>Swift</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置指南-Homebrew]]></title>
    <url>%2F2018%2F12%2F12%2F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97-Homebrew%2F</url>
    <content type="text"><![CDATA[Homebrew包管理工具可以让你安装和更新程序变得更方便，目前在 OS X 系统中最受欢迎的包管理工具是 Homebrew. Homebrew安装在安装 Homebrew 之前，需要将 Xcode Command Line Tools 安装完成，这样你就可以使用基于 Xcode Command Line Tools 编译的 Homebrew。 1xcode-select --install 在 terminal 中复制以下命令（不包括 $），跟随指引，将完成 Hombrew 安装。 1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 紧接着，我们需要做一件事让通过 Hombrew 安装的程序的启动链接 (在 /usr/local/bin 中）可以直接运行，无需将完整路径写出。通过以下命令将 /usr/local/bin 添加至 $PATH 环境变量中: 1$ echo 'export PATH="/usr/local/bin:$PATH"' &gt;&gt; ~/.bash_profile Cmd+T 打开一个新的 terminal 标签页，运行以下命令，确保 brew 运行正常。 1$ brew doctor 安装完成后，Homwbrew 会将本地 /usr/local 初始化为 git 的工作树，并将目录所有者变更为当前所操作的用户，将来 brew 的相关操作不需要 sudo 。Homebrew 基本使用安装一个包，可以简单的运行： 1$ brew install &lt;package_name&gt; 更新 Homebrew 在服务器端上的包目录： 1$ brew update 查看你的包是否需要更新： 1$ brew outdated 更新包： 1$ brew upgrade &lt;package_name&gt; Homebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行： 1$ brew cleanup 查看你安装过的包列表（包括版本号）： 1$ brew list --versions Homebrew Cask你已经感受到了使用 Homebrew 安装命令行程序的便利。那么接下来，我们将通过 Homebrew Cask 优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox。 安装安装 Homebrew-cask 是如此的简单直接，运行以下命令即可完成： 1234$ brew tap caskroom/cask // 添加 Github 上的 caskroom/cask 库$ brew install brew-cask // 安装 brew-cask$ brew cask install google-chrome // 安装 Google 浏览器$ brew update &amp;&amp; brew upgrade brew-cask &amp;&amp; brew cleanup // 更新 搜索如果你想查看 cask 上是否存在你需要的 app，可以到 caskroom.io 进行搜索。 文件预览插件123456789$ brew cask install qlcolorcode$ brew cask install qlstephen$ brew cask install qlmarkdown$ brew cask install quicklook-json$ brew cask install qlprettypatch$ brew cask install quicklook-csv$ brew cask install betterzipql$ brew cask install webp-quicklook$ brew cask install suspicious-package OS X 图形界面程序Swift123456789$ brew cask install alfred$ brew cask install appcleaner$ brew cask install cheatsheet$ brew cask install dropbox$ brew cask install google-chrome$ brew cask install onepassword$ brew cask install sublime-text$ brew cask install totalfinder... 如果你经常使用 Alfred 启动程序，那么你会想 Alfred 可以搜索 brew cask 安装的程序，实现这些仅需运行：1brew cask alfred link 常用123brew cask install sublime-textbrew cask install atombrew cask install google-chrome]]></content>
      <categories>
        <category>配置</category>
        <category>macOS</category>
        <category>Homebrew</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>macOS</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structures in Swift — Standard Library]]></title>
    <url>%2F2018%2F12%2F12%2FData-Structures-in-Swift%2F</url>
    <content type="text"><![CDATA[Standard Library在深入学习数据结构之前，首先将看到一些Swift中的基础数据结构。Swift标准库是指定义Swift语言核心组件的框架。在里面，你会发现各种各样的工具和类型，以帮助建立Swift应用程序。在本篇，将重点介绍标准库直接提供的两个数据结构:数组和字典。 内容源于：By Matthijs Hollemans. “Data Structures &amp; Algorithms in Swift”. Apple Books. Arrays创建(声明)一个数组123var Number = [Int]() // 声明一个空数组var fibonacci:[Int] = [] // 同，声明一个空数组var fibonacciNumber = [0,1,2,3,5,8,13,21,34] // 声明一个数组，元素类型是Int 注：数组的声明，必须包含两点——用以表示数组的标识和数组元素的类型，其中元素类型决定了所有元素的统一类型，同时swift可以自行推断数据类型 获取数组中的数据(内容)1234fibonacciNumber[4] // 获取数组的第五个元素，数组以0为第一个的标记fibonacciNumber[0] = 1 // 将第一个元素赋值为1fibonacciNumber[0...3] = [1,1,2,3] // 将首四个元素赋值fibonacciNumber // 获取数组本身 属性&amp;方法&amp;常用操作12345678910111213141516171819202122232425262728293031323334fibonacciNumber.count // 获取数组的元素个数fibonacci.isEmpty // 判断数组是否为空fibonacciNumber.isEmpty // 判断数组是否为空fibonacciNumber.contains(4) // 判断数组是否包含某个元素fibonacciNumber.first // 获取数组第一个元素fibonacciNumber.last // 获取数组最后一个元素fibonacciNumber.removeFirst() // 移除第一个元素，返回移除的元素fibonacciNumber.removeLast() // 移除最后一个元素，返回元素fibonacciNumber.min() // 求出数组中最小的元素fibonacciNumber.min(by: &gt;) // 求出数组中最小的元素，以'&gt;'规则fibonacciNumber.max() // 求出数组中最大的元素fibonacciNumber.max(by: &gt;) // 求出数组中最大的元素，以'&gt;'规则fibonacciNumber.dropFirst() // 移除第一个元素，返回结果数组fibonacciNumber.dropLast() // 移除最后一个元素，返回结果数组fibonacciNumber.dropLast(2) // 移除最后两个元素，返回结果数组fibonacciNumber.dropFirst(2) // 移除前两个元素，返回结果数组fibonacciNumber.forEach &#123; (word) in // 遍历数组，每次读取的结果以word指代print(word)&#125;fibonacciNumber.append(55) // 在数组尾添加元素55fibonacciNumber += [89] // 在数组尾添加元素89fibonacciNumber.insert(0, at: 0) // 在数组序列为0的位置插入0fibonacciNumber.remove(at: 0) // 移除数组序列为0的元素for item in fibonacciNumber &#123; // 遍历数组，每次读取的结果以item指代print(item)&#125;for (index,value) in fibonacciNumber.enumerated()&#123; // 元组遍历字典，字典由数组元素和其序列合成print("\(index+1) and \(value)")&#125;fibonacciNumber.sort(by : &gt;) // 原地排序数组，数组本身被更改，'&gt;'为规则 fibonacciNumber.sorted() // 为数组排序，返回结果，不更改自身fibonacciNumber.reversed() // 反转数组fibonacciNumber.distance(from: 1, to: 4) // 获取距离 Dictionary创建(声明)一个字典123456789var character = [Int:String]()var letter:[Int:String] = [:]var characters = [1:"R",2:"B",3:"C",4:"D",5:"E",] 注：字典的声明，必须包含三点——用以表示字典的标识以及key值和value值的类型，其中key值和value值的类型决定了相应部分的统一类型，同时swift可以自行推断数据类型 获取字典中的数据(内容)1234characters[3] // key为3的valuecharacters[1] = "A" // 将key为1的value赋值为Acharacters[0] = nil // 将key为0的value赋值为nil(即清除这个键值对)characters // 获取字典 属性&amp;方法&amp;常用操作1234567891011121314151617181920212223characters.keys // 获取所有key值，返回一个数组characters.keys.sorted() // 获取所有key值，返回一个排序后的数组characters.values // 获取所有value值，返回一个数组characters.index(forKey: 2) // 获取key的序列，返回Dictionary&lt;Key, Value&gt;.Indexcharacters.first // 获取字典的第一个键值对，返回元组characters.min(by: &gt;) // 获取字典key排序后的第一个键值对，返回元组characters.max(by: &gt;) // 获取字典key排序后的第一个键值对，返回元组characters.forEach &#123; // 遍历字典word inprint(word)&#125;characters.count // 获取字典元素个数characters.isEmpty // 判空characters.updateValue("F", forKey: 6) // 更新字典，如果有则替代，否则新增，并返回新的valuecharacters.removeValue(forKey: 6) // 移除key为6的键值对，如果有则返回移除的value，否则是nilvar dictionary = ["a": 1, "b": 2]dictionary.merge(["a": 3, "c": 4]) &#123; (current, _) in current &#125;// 更新字典，如果有重复的，保留原有的key和valuedictionary.merge(["a": 5, "d": 6]) &#123; (_, new) in new &#125;// 更新字典，如果有重复的，更新旧的valuefor (name,path) in characters &#123; // 遍历字典print("\(name) and \(path)")&#125; 面向对象12345678910let letters = "abracadabra"let letterCount = letters.reduce(into: [:]) &#123; counts, letter incounts[letter, default: 0] += 1&#125;// 统计字母频率let numbers = [1, 2, 3, 4]let numberSum = numbers.reduce(0, &#123; x, y inx + y&#125;)// 求数组元素和]]></content>
      <categories>
        <category>Data Structures</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Data Structures</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCNMaterialProperty]]></title>
    <url>%2F2018%2F12%2F11%2FSCNMaterialProperty%2F</url>
    <content type="text"><![CDATA[前言用于储存显示一种材料的视觉特性的颜色或纹理的容器 一种材料有几个视觉特性，共同决定了它在光照和阴影下的外观。SceneKit通过将来自材质属性的信息与灯光的位置、强度和颜色相结合来呈现场景中的每个像素。 材质属性的内容可以是一种颜色，它提供了横跨材质表面的统一效果；也可以是一种纹理，SceneKit使用材质所附的几何对象提供的纹理坐标，将其映射到材质表面。反过来，纹理可以来自任何的几个来源，如图像对象、一个图像文件的URL、一套专门格式的图像或图像作为一个立方体地图、甚至动画内容核心提供的动画、SpriteKit、或AVFoundation-for全部选项，请参阅contents属性。 内容均翻译自 apple developer documentation 概述 通常，在使用第三方创作工具创建3D资产时，您将纹理图像与材料相关联，而包含这些资产的场景文件引用外部图像文件。为了在应用程序包中传递资产时获得最好的结果，将场景文件放置在扩展名为.scnassets的文件夹中，并将作为这些场景纹理引用的图像文件放置在资产目录中。然后Xcode优化场景和纹理资源，以便在每个目标设备上获得最佳性能，并为交付特性(如应用程序细化和按需资源)准备纹理资源。 SceneKit以不同的方式为材质的每个可视属性使用材质属性的contents对象。例如: 当你为漫反射属性提供一种颜色时，它决定了材质的基本颜色几何图形，当材质被白光照射时，它会以这种颜色的渐变出现阴影。如果您提供一个图像，SceneKit将图像映射到几何图形的表面，而不是使用统一的底色进行着色。 当您为高光属性提供一种颜色时，它会影响从使用该材料的几何图形表面直接反射到查看器的光的颜色。如果你提供一个灰度图像，它决定了材料的趋势，以反射光直接向观众在图像中较亮的像素，使这些区域的材料显得更闪亮，和较暗的像素使材料显得更哑光。 法线属性指定表面在每个点的方向。默认情况下，材质是均匀光滑的，因此为这个属性指定颜色没有任何用处。相反，您可以为该属性指定一个描述曲面轮廓的图像。SceneKit在照明中使用了这张图像(称为法线贴图)，创建了一个复杂的、凹凸不平的表面的错觉，而不会增加几何图形的复杂性。 有关每个可视化属性及其内容如何影响材料外观的详细信息，请参见SCNMaterial。 SceneKit还在其他地方使用SCNMaterialProperty对象: 为了提供要在场景后呈现的内容，在SCNScene对象的后台属性中， 在SCNLight对象的gobo属性中，影响光源照明的颜色和形状。 在符合SCNShadable协议的类中，将纹理采样器绑定到自定义GLSL着色器源代码片段。 构造器1convenience init(contents: Any) 处理物理性质的信息 Working with Material Property Contents contents1var contents: Any? &#123; get set &#125; 对于每个可视化属性及其内容如何影响材料外观，请参见SCNMaterialcontents的内容可以是下列的任意一种： 颜色 (NSColor/UIColor or CGColor)，指定材料表面的统一颜色 数字 (NSNumber)，为材料的表面指定一个统一的标量值(用于基于物理的属性，如金属度-metalness) 图片 (NSImage/UIImage or CGImage)，指定要映射到材质表面的纹理 指定图像文件位置的NSString或NSURL对象 视频播放器(AVPlayer)或实时视频捕捉预览(AVCaptureDevice，仅限iOS) Core Animation 层 (CALayer) 纹理 (SKTexture, MDLTexture, MTLTexture, or GLKTextureInfo) SpriteKit场景(SKScene) 一种特殊格式的图像或由六个图像组成的数组，用于指定立方体映射的面 当您检查从文件中加载的场景元素时，这个值总是一个color对象(根据平台，是NSColor或UIColor类的)或一个image对象(根据平台，是NSImage或UIImage类的)。因此，您可以使用类型自省(Objective-C中的isKind(of:)方法，或者Swift中的is操作符或let-as匹配)来确定material属性内容的类型。 Using Animated Content在ios11中，你可以使用AVCaptureDevice对象作为一个材质属性来预览来自捕获设备的实时视频。在ios11、tvos11和macOS 10.13中，您可以使用AVPlayer对象作为视频播放的材料属性。 您可以指定任何核心动画层作为material属性的内容，例如具有动画子层层次结构的层。SceneKit不能使用已经在其他地方显示的层(例如，UIView对象的支持层)。 您可以使用SpriteKit框架为material属性提供静态或动画内容。SpriteKit提供了生成和修改纹理图像的选项，例如generatingNormalMap()方法。您还可以使用整个动画SpriteKit场景作为材质属性的内容。当您使用SKTexture对象作为材质属性的内容时，wrapS、wrapT、contentsTransform、minificationFilter、magniationfilter和mipFilter属性将自动更新，以匹配SpriteKit纹理的相应特性。 如果当前内容是纯色，则可以使用显式或隐式动画(请参见Animating SceneKit内容)更改为另一种颜色，从而创建在两种颜色之间淡入的效果。使用动画从其他内容类型转换到其他内容类型会导致瞬时转换——对于纹理内容类型(或者本身就是动画的类型)之间的动画转换，创建一个着色器修饰符(参见SCNShadable)。 Using Cube Map TexuresSceneKit仅支持用于材质的反射属性或场景背景或lightingEnvironment属性的立方体映射。您可以以下表中描述的任何一种方式提供多维数据集映射。在这些格式中，垂直条提供了最好的性能，因为它匹配SceneKit用于呈现立方体纹理的内存布局。 Description Image Size Requirements Example Vertical strip (single image) height == 6 * width Horizontal strip (single image) 6 * height == width Spherical projection (single image)(pixel x/y positions map to latitude/longitude coordinates on a sphere) 2 * height == width Array of six images(face order: +X, -X, +Y, -Y, +Z, -Z) height == widthsame size for all images [ \ \ \ \ \ ] intensity1var intensity: CGFloat &#123; get set &#125; 默认强度是1.0。降低强度会淡出材质属性的内容，根据所代表的SCNMaterial对象的视觉属性，会产生不同的效果: 对于法向特性，强度改变法向映射表面的表观粗糙度。降低强度使表面看起来更光滑。 对于倍增特性，降低强度将材料特性的颜色与白色混合，有效降低了颜色倍增效应的强度。 对于所有其他性能，降低强度会降低材料性能的含量。 您可以对该属性的值进行动画更改。参见Animating SceneKit Content 配置纹理映射属性 配置纹理映射属性 var contentsTransform: SCNMatrix4 The transformation applied to the material property’s visual contents. Animatable. 1var contentsTransform: SCNMatrix4 &#123; get set &#125; SceneKit将此转换应用于材质所附的几何对象提供的纹理坐标，然后使用得到的坐标映射材质属性在材质表面的内容。(如果material属性的contents对象是常量颜色，则此转换无效。) 例如，您可以使用此属性来增长、偏移或旋转相对于材质表面的纹理，如下所示。 您可以对该属性的值进行动画更改。参见Animating SceneKit Content var wrapS: SCNWrapMode The wrapping behavior for the S texture coordinate. 1var wrapS: SCNWrapMode &#123; get set &#125; 包装模式决定了材质纹理坐标超出0.0到1.0范围的情况下的纹理映射行为。例如，如果您使用contentsTransform属性来收缩相对于几何图形表面的纹理，那么您将使用wrap模式属性来确定纹理是否在表面上重复。 S纹理坐标测量纹理图像的水平轴，从图像左边缘的0.0增加到右边缘的1.0。 默认的包装模式是SCNWrapMode.clamp。请参阅SCNWrapMode了解可用模式及其效果。 var wrapT: SCNWrapMode The wrapping behavior for the T texture coordinate. 1var wrapT: SCNWrapMode &#123; get set &#125; 包装模式决定了材质纹理坐标超出0.0到1.0范围的情况下的纹理映射行为。例如，如果您使用contentsTransform属性来收缩相对于几何图形表面的纹理，那么您将使用wrap模式属性来确定纹理是否在表面上重复。 纹理坐标测量纹理图像的纵轴，从图像底部的0.0增加到顶部的1.0。 默认的包装模式是SCNWrapMode.clamp。请参阅SCNWrapMode了解可用模式及其效果。 enum SCNWrapMode Modes to apply to texture wrapping, used by the wrapT and wrapS properties. 1234567891011enum SCNWrapMode : Int'''case clamp//Texture coordinates are clamped to the range from 0.0 to 1.0, inclusive.case `repeat`//Texture sampling uses only the fractional part of texture coordinates, passing through the range from 0.0 to (but not including) 1.0.case clampToBorder//Texture sampling uses texture colors for coordinates in the range from 0.0 to 1.0 (inclusive) and the material property’s borderColor value otherwise.case mirror//Texture sampling of texture coordinates outside range from 0.0 to 1.0 should behave as if the range reverses before repeating.''' 包装模式决定了材质纹理坐标超出0.0到1.0范围的情况下的纹理映射行为。例如，如果您使用contentsTransform属性来收缩相对于几何图形表面的纹理，那么您将使用wrap模式属性来确定纹理是否在表面上重复。下图显示了每种包装模式对其他相同材料的影响。 var minificationFilter: SCNFilterMode Texture filtering for rendering the material property’s image contents at a size smaller than that of the original image. 1var minificationFilter: SCNFilterMode &#123; get set &#125; var magnificationFilter: SCNFilterMode Texture filtering for rendering the material property’s image contents at a size larger than that of the original image. 当材质表面的某些部分看起来比原始纹理图像大或小时，纹理过滤决定材质属性内容的外观。例如，纹理坐标在远离摄像机的一点可能对应于纹理图像中几个像素的区域。SceneKit使用缩小过滤器来确定采样texel在该点的颜色。 默认的缩小过滤器是scnfilter.linear。请参阅SCNWrapMode了解可用模式及其效果。 var mipFilter: SCNFilterMode Texture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image. 1var magnificationFilter: SCNFilterMode &#123; get set &#125; 当材质表面的某些部分看起来比原始纹理图像大或小时，纹理过滤决定材质属性内容的外观。例如，在摄像机附近的一个点上的纹理坐标可能对应于纹理图像中像素的一小部分。SceneKit使用放大过滤器来确定采样texel在该点的颜色。 默认的放大过滤器是scnfilter.linear。请参阅SCNWrapMode了解可用模式及其效果。 enum SCNFilterMode Texture filtering modes, used by the minificationFilter,magnificationFilter, and mipFilter properties. 123456789enum SCNFilterMode : Int'''case none//No texture filtering is applied.case nearest//Texture filtering returns the color from only one texel, whose location is nearest to the coordinates being sampled.case linear//Texture filtering sample texels from the neighborhood of the coordinates being sampled and linearly interpolates their colors.''' 当材质表面的某些部分看起来比原始纹理图像大或小时，纹理过滤决定材质属性内容的外观。例如，当纹理被应用到一个远离相机的平面上时: 在相机附近的一个点的纹理坐标可以对应原始图像中一个像素的一小部分。SceneKit使用放大率过滤器属性来确定采样后的texel的颜色。 纹理坐标在远离摄像机的一点可能对应于原始图像中几个像素的区域。SceneKit使用minificationFilter属性来确定采样texel的颜色。 SceneKit还在为纹理图像生成mipmap级别时使用mipFilter属性指定的过滤器。 var maxAnisotropy: CGFloat The amount of anisotropic texture filtering to be used when rendering the material property’s image contents. 1var maxAnisotropy: CGFloat &#123; get set &#125; 各向异性滤波是一种提高纹理呈现质量的过程，当纹理表面出现一个相对于相机的极端角度。这个过程通过从纹理的多个mipmap级别对每个呈现的像素进行采样来完成——各向异性是指每个像素的采样数量。各向异性越高，渲染质量越好，但渲染性能越差。 例如，下图左边的图像没有使用各向异性滤波，导致在棋盘模式后退到一定距离时呈现工件。其他图像使用更高的maxAnisotropy值，减少了呈现伪影。各向异性滤波需要mipmap，因此只有当mipFilter属性的值不是scnfilter.none时，该属性才生效。 SceneKit会根据需要自动增加或减少每个渲染像素的各向异性，以最大限度地提高渲染质量，直到该属性指定的限制。绘制时所使用的最大各向异性电平取决于所使用的图形硬件。将此属性的值设置为MAXFLOAT常量(默认值)，以使用GPU支持的最高各向异性级别。最大各向异性值为1.0或更低将禁用各向异性过滤。 var mappingChannel: Int The source of texture coordinates for mapping the material property’s image contents. 1var mappingChannel: Int &#123; get set &#125; 一个几何图形可以有多个独立的纹理坐标来源，每个来源都定义一个唯一的映射通道号。您可以使用这些通道以不同的方式映射材料的不同视觉属性。例如，表示图片框的几何图形可以使用一组纹理坐标来映射图片本身的材质，而另一组纹理坐标可以将图片放到图片框中。 有关使用多个纹理映射通道创建几何图形的信息，请参见SCNGeometry。]]></content>
      <categories>
        <category>Swift</category>
        <category>SceneKit</category>
        <category>SCNMaterialProperty</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SceneKit</tag>
        <tag>SCNMaterialProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCNMaterial]]></title>
    <url>%2F2018%2F12%2F10%2FSCNMaterial%2F</url>
    <content type="text"><![CDATA[前言当创建一个材质时，定义了一组可视化属性和它们的选项，然后您可以将它们用于场景中的多个几何图形。一个材质有几个视觉属性，每个属性都定义了SceneKit光照和阴影处理的不同部分。每个可视化属性都是SCNMaterialProperty类的一个实例，该类为SceneKit的呈现提供了一个纯色、纹理或其他2D内容。然后，材质的lightingModel属性确定SceneKit用于将视觉属性与场景中的灯光组合在一起的公式，从而为渲染场景中的每个像素生成最终颜色。有关呈现过程的更多细节，请参见SCNMaterial.LightingModel。使用SCNGeometry类的firstMaterial或materials属性将一个或多个材料附加到它的实例。多个几何图形可以引用相同的材料。在这种情况下，改变材质的属性会改变使用它的每个几何图形的外观。 内容均翻译自 apple developer documentation SCNMaterial1class SCNMaterial : NSObject 创建1convenience init(mdlMaterial: MDLMaterial) always: 1var material = SCNMaterial() 其他属性 Creating a Material init(mdlMaterial: MDLMaterial) var name: String? Choosing a Shading Model var lightingModel: SCNMaterial.LightingModel struct SCNMaterial.LightingModel Visual Properties for Physically Based Shading var diffuse: SCNMaterialProperty var metalness: SCNMaterialProperty var roughness: SCNMaterialProperty Visual Properties for Special Effects var normal: SCNMaterialProperty var displacement: SCNMaterialProperty var emission: SCNMaterialProperty var selfIllumination: SCNMaterialProperty var ambientOcclusion: SCNMaterialProperty Visual Properties for Basic Shading var diffuse: SCNMaterialProperty var ambient: SCNMaterialProperty var specular: SCNMaterialProperty var reflective: SCNMaterialProperty var multiply: SCNMaterialProperty var transparent: SCNMaterialProperty var shininess: CGFloat var fresnelExponent: CGFloat var locksAmbientWithDiffuse: Bool Managing Opacity and Blending var transparency: CGFloat var transparencyMode: SCNTransparencyMode enum SCNTransparencyMode var blendMode: SCNBlendMode enum SCNBlendMode Customizing Rendered Appearance var isLitPerPixel: Bool var isDoubleSided: Bool var cullMode: SCNCullMode enum SCNCullMode var fillMode: SCNFillMode enum SCNFillMode Managing Render Targets var writesToDepthBuffer: Bool var readsFromDepthBuffer: Bool var colorBufferWriteMask: SCNColorMask struct SCNColorMask Lighting models概述1var lightingModel: SCNMaterial.LightingModel &#123; get set &#125; 材质的lightingModel属性决定了SceneKit使用的公式，该公式将其漫反射颜色和其他视觉属性与场景中的灯光和其他内容结合在一起，从而为渲染场景中的每个渲染像素生成最终颜色。 材质的光照模型类型 constant：Uniform shading that incorporates ambient lighting only. 均衡（扁平化）的阴影，在渲染时只计算（包含）ambient信息 lambert：Shading that incorporates ambient and diffuse properties only. 在渲染时只计算（包含）ambient信息和diffuse信息 blinn：Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Blinn-Phong formula. 在渲染时只计算（包含）ambient信息、diffuse信息、specular信息，而且specular高光区是用Blinn-Phong法则计算的 phong：Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Phong formula. 在渲染时只计算（包含）ambient信息、diffuse信息、specular信息，而且specular高光区是用Phong法则计算的 physicallyBases：Shading based on a realistic abstraction of physical lights and materials. 基于物理光和材料的现实抽象的阴影，包含了真实情况下,物理光源和材质对光的漫反射和吸收 物理纹理的可视化属性概述 Visual Properties for Physically Based Shading 总共包含三个属性： diffuse：An object that manages the material’s diffuse response to lighting. 用于控制材料对光线漫反射的反映（纯物理状态下的属性或直接物理属性） metalness：An object that provides color values to determine how metallic the material’s surface appears. 根据颜色值来决定材料表面金属化（反光）程度 roughness：An object that provides color values to determine the apparent smoothness of the surface. 根据颜色值来决定材料表面光洁（凹凸）程度 diffuse（漫反射）1var diffuse: SCNMaterialProperty &#123; get &#125; 漫反射阴影描述的是从材料表面每个点均匀反射到各个方向的光的数量和颜色。像素的漫反射颜色与视点无关，因此它可以被看作是一种材料的“基色”或纹理。 metalness（金属性(反光)贴图）1var metalness: SCNMaterialProperty &#123; get &#125; 此属性仅度量颜色值的总强度;纹理内容最好用灰度来定义。 这种性质通常近似于物理表面的某些方面，如折射率、产生锐反射的倾向、以及在掠掠角产生菲涅尔反射的倾向，这些因素共同产生了整体的金属或非金属(也称为介质)外观。较低的数值(较深的颜色)会使材料看起来更像介质表面。较高的数值(较亮的颜色)会使表面看起来更金属。 roughness（光洁程度）1var roughness: SCNMaterialProperty &#123; get &#125; 此属性仅度量颜色值的总强度;纹理内容最好用灰度来定义。 这个特性近似于表面的微观细节——例如微小的碰撞和裂纹。通过将这些“微面”近似为单个术语，该特性有助于生成类似于真实物理中的能量守恒定律的照明计算，从而在哑光和闪亮表面之间产生更真实的变化。 较低的数值(较深的颜色)会使材料呈现光泽，并带有清晰的高光。较高的值(较亮的颜色)会导致高光发散，而材料的漫反射颜色会变得更加反射。 特殊效果的可视化属性概述 Visual Properties for Special Effects 总共包含五个属性： var normal: SCNMaterialProperty An object that defines the nominal orientation of the surface at each point for use in lighting. var displacement: SCNMaterialProperty var emission: SCNMaterialProperty An object that defines the color emitted by each point on a surface. var selfIllumination: SCNMaterialProperty An object that provides color values representing the global illumination of the surface. var ambientOcclusion: SCNMaterialProperty An object that provides color values to be multiplied with the ambient light affecting the material. normal1var normal: SCNMaterialProperty &#123; get &#125; 要模拟光与材料的相互作用，就需要了解每一点表面的方向。通常，由几何对象提供的法向量提供此信息。然而，这限制了表面轮廓的细节级别，因为一个几何结构只能为每个顶点提供一个唯一的表面法向量(增加顶点数量来建模一个非常详细的表面需要很高的性能成本)。 或者，您可以使用纹理图像作为法线映射，它描述纹理中每个像素的表面方向。当SceneKit使用图像时，它将每个图像的R、G和B分量视为曲面法向量的X、Y和Z分量。因为法线贴图纹理可以存储比几何图形更详细的表面信息，所以您可以使用材料的法线属性来模拟粗糙的表面，例如石头，或者在光滑的表面添加浮雕或雕刻设计。 默认情况下，normal属性的contents对象是白色的。将normal属性的内容设置为任何纯色都会禁用normal映射，导致SceneKit仅使用几何图形提供的表面normal信息对材料进行阴影处理。将normal属性的内容设置为图像或其他纹理映射内容将启用normal映射，这也将自动将材质的isLitPerPixel属性设置为true。 下图显示了在其他属性具有默认内容的材质上将normal属性的内容设置为纹理图像的效果。 displacement1var displacement: SCNMaterialProperty &#123; get &#125; emission1var emission: SCNMaterialProperty &#123; get &#125; 您可以使用发射贴图(emissive map)纹理来模拟表面的部分，这些部分会发光。SceneKit并不将材料视为光源——相反，发射特性决定了独立于照明的材料的颜色。(为了创建一个发光的对象，你可能希望结合一个几何图形，发射地图和额外的SCNLight对象添加到场景。) 默认情况下，emissive属性的contents对象是黑色的，这导致属性没有可见效果。将发射属性的内容设置为任何一种纯色，都会为材料添加一种不依赖于灯光的统一颜色。要创建选择性辉光效果，请将属性的内容设置为图像或其他纹理映射内容，其发光区域使用明亮的颜色，其他区域使用较暗的颜色。在发射贴图(emissive map)的深色部分(以及不透明度降低的部分)中，材质的其他视觉属性有助于它在场景照明下的外观。 下图显示了一个材质(带有纹理作为漫反射(diffuse)属性)在提供一个发射地图(emissive map)图像之前和之后。 selfIllumination1var selfIllumination: SCNMaterialProperty &#123; get &#125; 自照明适用于所有材料，但对于那些使用基于物理的阴影的材料尤其有用(参见physicallyBased)。基于物理的材料最适合于基于环境的照明(请参阅SCNScene属性lightingEnvironment)，但是对于某些材料来说，让一个表面本身定义它的部分照明是有用的——例如，一个物体的位置从提供主要照明环境的“天空”中模糊了它。当您为这个属性指定内容时，它们覆盖了环境照明对漫反射阴影的贡献，但是环境照明仍然对高光效果有贡献。 ambientOcclusion1var ambientOcclusion: SCNMaterialProperty &#123; get &#125; 使用此属性可将环境遮挡纹理映射指定到表面。如果场景中没有环境光，则此属性无效。如果该属性不是nil, SceneKit将忽略ambient属性。 当使用基于物理的阴影时(参见physicallyBased)，环境遮挡近似于掩盖全局光照的大规模表面细节。 基础纹理的可视化属性概述 Visual Properties for Basic Shading 总共包含九个属性： var diffuse: SCNMaterialProperty An object that manages the material’s diffuse response to lighting. var ambient: SCNMaterialProperty An object that manages the material’s response to ambient lighting. var specular: SCNMaterialProperty An object that manages the material’s specular response to lighting. var reflective: SCNMaterialProperty An object that defines the reflected color for each point on a surface. var multiply: SCNMaterialProperty An object that provides color values that are multiplied with pixels in a material after all other shading is complete. var transparent: SCNMaterialProperty An object that determines the opacity of each point in a material. var shininess: CGFloat The sharpness of specular highlights. Animatable. var fresnelExponent: CGFloat A factor affecting the material’s reflectivity. Animatable. var locksAmbientWithDiffuse: Bool A Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable. diffuse1var diffuse: SCNMaterialProperty &#123; get &#125; 漫反射阴影描述的是从材料表面每个点均匀反射到各个方向的光的数量和颜色。像素的漫反射颜色与视点无关，因此它可以被看作是一种材料的“基色”或纹理。 ambient1var ambient: SCNMaterialProperty &#123; get &#125; 环境阴影(Ambient shading)描述材料反射的环境光的数量和颜色。在一个表面上的所有点上，环境阴影在所有方向上都是均匀的。如果一个场景不包含周围环境类型的灯光，这个属性对材质的外观没有影响。 默认情况下，ambient属性的contents对象是深灰色的。更改ambient属性的内容可以为场景中没有被灯光直接照亮的区域指定不同的颜色或纹理。为了使材料对环境光和漫射光的响应一致，将其locksambientwith漫射属性设置为true。 下图显示了在将环境属性的内容设置为纯色之前和之后的材质(带有纹理作为漫反射(diffuse)属性)。 材质的lightingModel属性决定了SceneKit用于将其环境颜色和其他视觉属性与场景中的灯光和其他内容组合在一起的公式，从而为场景中的每个呈现像素生成最终颜色。有关详细信息，请参见照明模型。 此材料属性不适用于基于物理的材料(请参见physicallyBased)。 specular1var specular: SCNMaterialProperty &#123; get &#125; 高光材质(Specular shading)描述的是材料直接反射到观看者身上的光的数量和颜色，在表面形成一个明亮的高光，并模拟光滑或有光泽的外观。您可以使用材质的光泽属性来调整高光的锐度。 默认情况下，高光(specular)属性的内容对象是黑色的，这将导致材质看起来暗淡无光。改变高光(specular)属性的内容到一个更亮的颜色导致高光(specular)高亮出现在那个颜色，使表面看起来闪亮。当你对高光(specular)属性应用纹理时，纹理图像就变成了高光贴图(specular map)——图像中每个像素的亮度决定了材料表面每个点在被光照时产生高光的趋势。 下图显示了材质(带有纹理作为漫反射(diffuse)属性)在提供高光贴图图像之前和之后的效果。请注意，明亮的高光只出现在高光贴图(specular map)图像为白色的部分表面。 此材料属性不适用于基于物理的材料(请参见 physicallyBased)。 reflective1var reflective: SCNMaterialProperty &#123; get &#125; 您可以通过使表面反射其环境来模拟镜像或镀铬处理。SceneKit不呈现场景中对象的实时反射，但它可以使用环境映射纹理来模拟静态或动画图像的反射。当渲染表面上的每个像素时，SceneKit将光线从该点跟踪到环境映射中的一个像素，就像表面反射了该图像一样。 默认情况下，反射(reflective)属性的contents对象是白色的，这导致属性没有可见效果。将反射(reflective)属性的内容设置为任何纯色都会为材质添加均匀的阴影。要创建反射(reflective)效果，请将属性的内容设置为图像或其他纹理映射内容。 要使用环境映射产生镜像效果，纹理图像应该采用以下两种形式之一:一个球面图，一个正方形的图像，其内容描述了一个被镜像球面反射的环境。一个立方体映射，由六个正方形图像组成的阵列，它们共同构成一个包围场景的假想立方体，其内部表面被材质反射。您可以通过将反射属性的contents对象设置为一个包含6张图像的NSArray实例来创建一个多维数据集映射，每个图像按照以下顺序对应场景世界坐标空间中的一个方向:+X、-X、+Y、-Y、+Z、-Z(或右、左、上、下、近、远)。 下图显示了在为反射(reflective)属性提供立方体映射之前和之后的材质(带有纹理作为其普通(normal)属性)。 此材料属性不适用于基于物理的材料(请参见physicallyBased)。相反，这些材料根据它们的金属度和粗糙度特性反射基于环境的照明(参见SCNScene lightingEnvironment属性)。 multiply1var multiply: SCNMaterialProperty &#123; get &#125; 将材质的其他视觉属性与灯光和场景的其他信息相结合后，scene kit将每个渲染像素的颜色乘以该属性提供的颜色。您可以使用此属性使表面变暗或着色，而不受光照和其他属性的影响，或者通过阴影映射将预先计算的光照添加到场景中。 默认情况下，multiply属性的contents对象是白色的，导致属性没有可见效果。 下图显示了在将multiply属性的内容设置为纯色之前和之后的材质(带有纹理，用于漫反射(diffuse)和发射(emission)属性)。请注意，正片叠底的颜色甚至可以调节由辐射贴图添加的明亮区域。 transparent1var transparent: SCNMaterialProperty &#123; get &#125; 使用此属性可选择性地使材料的某些部分呈现透明。可以使用透明(transparency)属性统一调整材质的不透明度，也可以使用节点的不透明度属性对附加到节点上的所有内容进行调整。 默认情况下，透明属性的contents对象是完全不透明的黑色，这导致属性没有可见效果。将透明属性的内容设置为任何纯色，将基于该颜色的不透明度值均匀地淡入材质的不透明度。 要使材质的某些部分看起来是透明的，请将属性的内容设置为图像或其他纹理映射内容，其alpha通道定义了完全或部分不透明的区域。 下图显示了半透明材质在为其透明属性提供纹理图像之前和之后。(为了使透明效果更加明显，透明材质后面显示了一个蓝色球体。) transparencyMode控制SceneKit如何从透明属性的内容中解释颜色信息。 shininess1var shininess: CGFloat &#123; get set &#125; 材料的光泽(shininess)与其镜面(specular)特性和场景中的灯光(lighting)相互作用，从而在表面上产生明亮的高光。一个较高的值会产生更清晰的高光，使表面看起来更光滑和有光泽。 您可以对该属性的值进行动画更改。参见Animating SceneKit Content fresnelExponent1var fresnelExponent: CGFloat &#123; get set &#125; 材料的菲涅尔指数(Fresnel exponent)与其反射(reflective)特性相互作用，根据其相对于观察者的角度确定表面反射的强度。较高的菲涅尔指数增加以浅角度观察材料时的反射率。 A higher Fresnel exponent increases the visibility of reflections when the material is viewed from a shallow angle. 您可以对该属性的值进行动画更改。参见Animating SceneKit Content locksAmbientWithDiffuse1var locksAmbientWithDiffuse: Bool &#123; get set &#125; 当建模真实世界的照明，在可见的环境光(ambient)和漫射光(diffuse)，一个表面通常被认为有一个单一的“基础”颜色或纹理。 当该属性值为false时，SceneKit没有这个限制:您可以使用材质的漫反射属性来提供在直接照明下可见的颜色或纹理，而使用它的ambient属性来为未直接照明的区域提供不同的颜色或纹理。 当这个属性的值为true时，或者当使用基于物理的阴影模式时，SceneKit将漫反射属性用于环境照明，忽略环境(ambient)属性，并确保材料对环境光和漫反射光的响应一致。 对于所有平台上的新应用程序，此属性的默认值为true。(在OS X v10.9和更早的版本中，默认值为false。)您可以对该属性的值进行动画更改。参见Animating SceneKit Content 动画化此属性会在呈现每个状态的结果之间逐渐消失。 管理不透明度和混合transparencytransparency1var transparency: CGFloat &#123; get set &#125; SceneKit通过将材质透明属性的颜色乘以该属性的值来确定表面中每个呈现像素的总不透明度。然后，材质的透明模式属性决定了材质的像素如何融入场景。 还可以使用节点的不透明度属性统一调整附加到节点的所有内容的不透明度。 您可以对该属性的值进行动画更改。参见Animating SceneKit Content transparencyMode1var transparencyMode: SCNTransparencyMode &#123; get set &#125; 默认的透明模式是SCNTransparencyMode.aOne。有关可用值及其效果，请参见scntransparent mode。 SCNTransparencyMode1234567enum SCNTransparencyMode : Int'''case aOne//SceneKit derives transparency information from the alpha channel of colors. The value 1.0 is opaque.case rgbZero//SceneKit derives transparency information from the luminance of colors. The value 0.0 is opaque.''' blendingblendMode1var blendMode: SCNBlendMode &#123; get set &#125; 使用SCNBlendMode的默认混合模式。alpha，材质根据alpha(不透明度)值进行混合——alpha值高的像素比alpha值低的像素更不透明。更改此属性以创建特殊效果。 例如，SCNBlendMode.add模式可以使对象看起来发光。 SCNBlendMode123456789101112131415enum SCNBlendMode : Int'''case alpha//Blend by multiplying source and destination color values by their corresponding alpha values.case add//Blend by adding the source color to the destination color.case subtract//Blend by subtracting the source color from the destination color.case multiply//Blend by multiplying the source color with the background color.case screen//Blend by multiplying the inverse of the source color with the inverse of the destination color.case replace//Blend by replacing the destination color with the source color, ignoring alpha.''' 自定义外观呈现var isLitPerPixel: Bool当该属性的值为true(默认值)时，SceneKit为每个呈现的像素独立执行光照计算。这种方法提供了更好的呈现质量，但是会对呈现性能产生负面影响。 如果将该属性的值更改为false, SceneKit将为几何图形中的每个顶点执行光照计算，并允许GPU在顶点之间的像素之间插入光照结果。根据几何图形表面的形状和顶点数量以及被渲染的材质属性，这种方法可以在不显著影响视觉质量的情况下提高渲染性能。 您可以对该属性的值进行动画更改。参见Animating SceneKit Content 动画化此属性会在呈现每个状态的结果之间逐渐消失。 var isDoubleSided: Bool当该属性的值为false(默认值)时，SceneKit从一侧使用材质呈现一个表面。几何图形中的顶点数据和法向量指定每个多边形的哪一侧被认为是它的正面，几何图形相对于摄像机的方向决定了当前哪些正面是可见的。 如果将此属性的值更改为YES, SceneKit将同时呈现每个多边形的前表面和后表面。SceneKit假设面法线是正面法向量的负值。 您可以对该属性的值进行动画更改。参见Animating SceneKit Content 动画化此属性会在呈现每个状态的结果之间逐渐消失 var cullMode: SCNCullMode几何图形中的顶点数据和法向量指定每个多边形的哪一侧被认为是它的正面，几何图形相对于摄像机的方向决定了当前哪些正面是可见的。通常，后表面只出现在封闭几何图形的内部，被前表面所遮挡，因此渲染这些表面需要性能成本，但没有可见效果。 该属性的默认值是back，指定SceneKit应该选择或不呈现背面。您可以更改此属性的值，以使SceneKit只呈现材料的背面。有关可用值，请参见SCNCullMode。 您可以对该属性的值进行动画更改。参见Animating SceneKit Content 动画化此属性会在呈现每个状态的结果之间逐渐消失 SCNCullMode12345enum SCNCullMode : Int'''case backcase front''' 几何图形中的顶点数据和法向量指定每个多边形的哪一侧被认为是它的正面，几何图形相对于摄像机的方向决定了当前哪些正面是可见的。通常，后表面只出现在封闭几何图形的内部，被前表面所遮挡，因此渲染这些表面需要性能成本，但没有可见效果。 管理渲染目标var writesToDepthBuffer: BoolSceneKit的呈现过程使用深度缓冲区来确定相对于查看器呈现的表面的顺序。该属性的默认值为true，指定SceneKit为每个呈现的像素保存深度信息，以便稍后的呈现传递使用。 通常，在呈现半透明对象时禁用对深度缓冲区的写入，因为呈现过程的后续阶段可能需要关于其背后不透明对象的深度信息。 var readsFromDepthBuffer: BoolSceneKit的呈现过程使用深度缓冲区来确定相对于查看器呈现的表面的顺序。该属性的默认值为true，指定SceneKit在渲染材质时将每个渲染像素的深度与其深度缓冲区中的相应值进行比较。如果像素的深度大于深度缓冲区中相应的点，SceneKit不会呈现像素。 通常，在呈现无论场景中已经呈现的内容如何都应该可见的对象时(例如，游戏中的抬头显示)，您将禁用从深度缓冲区读取。在这种情况下，还应该为节点的renderingOrder属性设置一个高值，该属性包含要始终可见的任何内容。]]></content>
      <categories>
        <category>Swift</category>
        <category>SceneKit</category>
        <category>SCNMaterial</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SceneKit</tag>
        <tag>SCNMaterial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形式逻辑-第五版-华东师范大学出版社（1～4章）]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%BD%A2%E5%BC%8F%E9%80%BB%E8%BE%91-%E7%AC%AC%E4%BA%94%E7%89%88-%E5%8D%8E%E4%B8%9C%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6%E5%87%BA%E7%89%88%E7%A4%BE%2F</url>
    <content type="text"><![CDATA[形式逻辑的对象和意义形式逻辑的对象和性质形式逻辑的对象形式逻辑有传统和现代（即数理逻辑）之分。本书提及的是前者，也就是一门以系统介绍传统逻辑的基础知识为主的逻辑科学，也就是现在常说的普通逻辑。 思维的过程是对客观世界的一种概括性的间接反映过程，它具有概括性和间接性的特点。 所有的金属都是导体 所有的商品都是劳动产品 这些都是由一个反映判断对象的概念（主项）和一个反映判断对象属性的概念（谓项），以及一个表示对主项概念所反映的所有对象都作了断定的概念（量项）通过联系词“是”（联项）而构成的。 如果用S表示主项的概念，用P表示谓项概念，那么： 所有S都是P 这是一种常见的判断（命题）形式：全称肯定的直言判断（或命题）的形式 如果，用S、P、M表示推理中的三个不同概念： M是P S是M S是P 这是最常见的推理，即三段论推理的逻辑结构，也称为三段论推理的形式逻辑。 形式逻辑所研究的逻辑形式中，推理形式是最主要的。 形式逻辑的性质形式逻辑同数理逻辑、辩证逻辑的关系 学习形式逻辑的意义和方法学习形式逻辑的意义学习形式逻辑的方法 概念概念的概述什么是概念概念是思维形式最基本的组成单位，是构成命题、推理的要素。 概念是通过揭示对象的特性或本质来反映对象的一种思维形式。 概念和语词思想是离不开语言的，任何一个思想的产生和形式都要借助于语言，任何一个思想的表达也要借助于语言。 概念作为一种思维形式，离不开语言中的语词。 概念和语词有密切的联系。 概念要明确人们的行动是受思想支配的。 概念的内涵和外延概念的内涵和外延概念的内涵是指反映在概念中的事物的特性或本质，概念的外延是指反映在概念中的一个个、一类类的事物。 了解概念的内涵和外延，对概念明确来说是十分重要的。 概念的内涵与外延的反变关系内涵和外延是概念的两个不同方面，概念的这两个不同的方面有密切的内在联系。在这种密切联系中，有一种互相制约的关系：一个概念的内涵越多，那么这个概念的外延就会越少。反过来，如果一个概念的内涵越少，那么这个概念的外延就会越多。这种关系被称为内涵与外延的反变关系。 概念的种类形式逻辑关于概念的分类，是根据概念的最一般的特征进行的。 单独概念和普遍概念单独概念单独概念是反映某一单独对象的概念。 北京 华东师大 鲁迅 这些都是单独概念，其外延都是一个独一无二的对象。 语言中有两种语词表达单概念： 专有名词：上海、黄河 摹状词：通过对某一特定事物某方面特征的描述而指称该事物的一种词组。（例如：世界第一大河） 普遍概念普遍概念是反映某一类对象的概念。 人 共产党宣言的作者 小说 诗歌 集合概念和非集合概念集合概念一定数量同类事物的个体可以构成一个集合体，反映这种由同类个体事物构成的不可分割的整体的概念就是集合概念。 舟山群岛 中国工人阶级 非集合概念不以这种由同类个体事物构成的集合体为反映对象的概念就是非集合概念。 岛屿 工人 注意集合体所具有的属性，其构成分子（个体）未必具有，而分子所具有的属性，集合体也不必然具有。 有的语词可以在集合意义下使用，也可以在一般的分别的意义下使用。 正概念和副概念根据概念所反映的事物具有某种属性还是不具有某种属性，可分为正概念和副概念。 在思维中反映具有某种属性的事物的概念叫做正概念（肯定概念） 金属 理性 在思维中反映不具有某种属性的事物的概念叫做负概念（否定概念） 非金属 非理性 概念外延间的关系客观事物是互相联系的，因而反映事物的概念之间也是互相联系的，这就形成了概念之间的各种不同关系。 从外延考虑，两个概念所反映的两类事物可能是重合的，也可能是毫无重合之处的。 概念间的相容关系同一关系同一关系是指外延完成重合的两个概念之间的关系，又称全同关系 概念可定义为：“凡A是B，并且凡B是A” 当且仅当凡A都是B，并且凡B都是 同一关系的概念虽然在外延上是相同的，但内涵却有些不同，例如：“《阿Q正传》的作者”和“鲁迅”这两个概念，它们都反映鲁迅先生这个客观对象。正因为这两个概念的外延相同但内涵不同，才称为两个概念。否则，若外延和内涵都相同，那就是表达统一概念的不同词汇，例如：“马铃薯”和“土豆” 从属关系从属关系是指一个概念的外延包含着另一个概念的全部外延的这样两个概念之间的关系。例如：“学生”和“大学生” 在具有从属关系的两个概念中，外延大的概念称为属概念，外延小的概念称为种概念。 概念间的从属关系实际上表现为以下两种不同的关系（A为种概念，B为属概念）：一是A对B的关系，称为真包含与关系；一是B对A的关系，称之为真包含关系。 真包含于关系 一个概念，如果它的全部外延包含在另一个概念之中，并仅仅作为这另一概念的外延的一部分，那么，前一概念对后一概念之间的关系即为真包含于关系，亦称种属关系。 可定义为：凡A是B，有B不是A。A真包含于B可表示为，A⊂B 真包含关系 一个概念，如其外延包含着另一个概念的全部外延，并且，这另一概念的外延仅仅是前一概念外延的一部分，那么前一概念对后一概念之间的关系即为真包含关系，亦称属种关系。 可定义为：凡A是B，有B不是A。B真包含A可表示为，B⊃A 具有从属关系的两个概念，必然具有内涵于外延的反变关系，例如：“大学生”都是“学生”，“学生”不都是“大学生” “车刀”和“车床”没有从属关系，因为语句“车刀是车床”不成立（大学生是学生，成立） 交叉关系交叉关系就是外延有且只有一部分是重合的这样两个概念之间的关系。 交叉关系又称部分重合关系 可定义为：有的A是B，有的A不是B，有的B不是A 例如：“大学生”和“共青团员”；“作家”和“教师” 由于交叉关系的两个概念是有互相重合的部分，因此不可在逻辑上等同于互斥关系。 例如：语句“鲁迅是作家，不是教师”是错误的，之中，就将“作家”和“教师”看作了互斥关系来使用。 概念间的不相容关系所谓概念间的不相容关系，是指外延间互相排斥，没有任何重合部分的两个概念之间的关系，因此也称全异关系。 所谓A、B两个概念不相容，就是所有A都不是B，所有B都不是A。 矛盾关系矛盾关系是指这样两个概念之间的关系，即两个概念的外延是互相排斥的，而且两个概念的外延之和穷尽了它们属概念的全部外延。 例如：“金属”和“非金属” 具有矛盾关系的两个概念往往一个是正概念，一个是负概念，但也有两个都是正概念的，例如：“阳极”和“阴极”；“男运动员”和“女运动员” 反对关系反对关系是这样两个概念之间的关系，即两个概念的外延是相互排斥的，而且这两个概念的外延之和没有穷尽它们属概念的全部外延。 例如：“社会主义国家”和“资本主义国家”，属概念是“国家” #并列关系所谓概念之间的并列关系是指属于同一属概念的各个同层次的种属概念之间分关系。 概念间的并列关系，分为相容的并列关系和不相容的并列关系 同一个属概念包含着的几个同层次的种概念，如果其外延是相互交叉的，那么这几个概念之间的关系就叫做相容的并列关系。 例如：属关系为“科学家”，那么“农学家”、“生物学家”、“化学家”就是几个相容的并列关系。 不相容的并列关系是指同一个属概念包含着的几个同层次的种概念，其外延彼此互相排斥，没有重合之处。 例如：“奴隶社会”、“资本主义社会”、“社会主义社会” 概念的限制和概括概念要明确，这是形式逻辑的基本要求之一，所谓确切地阐明各个概念，就是要阐明各个概念的确切的内涵和外延。 概念的内涵和外延有着相互制约的关系。当我们的思维有种概念过渡到属概念，或者由属概念过渡到种概念的时候，概念的内涵和外延在量上表现出的一种规律性的变化，这就是内涵同外延的反变关系。概念的限制和概括就是根据内涵同外延的这种反变关系，通过增加或减少概念内涵以缩小或扩大概念的外延来明确概念的一种逻辑方法。 概念的限制概念的限制是通过增加概念的内涵以缩小概念的外延，即由属概念过渡到种概念来明确概念的一种逻辑方法。 对一个外延较大的概念，可以进行多次限制，但究竟限制到哪一个较小的概念才算达到了明确概念的目的，这要看人们在表达和交流思想时的具体论域。 对概念进行必要的限制有助于使人们的认识具体化。 限制的方法只适用于普遍概念，或者说只适用于包含有种概念的属概念。由于单独概念只反映一个独一无二的对象，所以对单独概念不必也不能加以限制。 为了使对概念的限制真正能起到明确概念的作用，必须根据概念本身的逻辑特性和具体论域来对概念加以限制，否则就有可能犯“限制不当”的逻辑错误。例如：“对错误的谬论必须坚决予以驳斥”，其中谬论本身就包含“错误的”的含义。 概念的概括概念的概括是通过减少概念的内涵以扩大概念的外延，即种概念过渡到属概念以明确概念的一种逻辑方法。 在表达和交流思想的过程中，如果我们对某些概念作必要的概括，就可以进一步加深人们对这些概念的理解。 在一定范围内，对一个外延较小的概念可以连续进行概括。 为了使概念的概括能够真正起到明确概念的作用，同样必须根据概念本身的逻辑特性和具体论域来对概念进行概括，否则就有可能犯“概括不当”的逻辑错误。 例如：“不随地吐痰”是“良好的个人习惯”，是人人应该遵守的“社会公德”。这样的概括是恰当的，但将“不随地吐痰”概括为“高尚的共产主义品德”，就过分了。 定义什么是定义明确一个概念就是明确这个概念的内涵和外延。明确一个概念的内涵，就是明确这个概念所反映的对象的特点和本质。定义就是这种明确概念内涵的逻辑方法。 具体地说，定义揭示概念所反映的对象的特点或本质的一种逻辑方法。 例如： 商品就是用来交换的劳动产品 人们在生产过程中发生的社会关系叫做生产关系。 人们的认识是发展的，概念不是一成不变的，因此定义也是发展的。 事物有许多方面，一个定义不可能把事物的多方面本质都揭露出来。 下定义的方法最常见的一种下定义的方法是属加种差的方法。 1被定义项=种差+邻近的属概念 这里需要说明的是，揭示被定义项的种差有不同的情况。比如，前述关于“商品”、“生产关系”这两个概念的定义是通过直接揭示被定义概念所反映的客观事物所具有的本质属性来作出的。 另一种情况是，其种差是通过揭示事物或产生现象产生的原因来揭示事物的本质的。例如：“当地球运行到月球和太阳中间时，太阳的光正好被地球挡住，不能照射到月球上去，因此，月球上就出现黑影，这种现象叫月食。”这种定义叫发生定义。 还有一种情况是，种差是通过揭示被定义概念所反映的对象与对象之间关系，或它与另一个对象对第三者的关系来揭示事物本质的，这种定义叫关系定义。例如：“偶数就是能被2整除的数”，就是一种关系定义，因为它揭示了偶数与2的关系。 属加种差定义的方法不是任何概念都是适用的。例如：哲学范畴是对客观事物的最高概括，因而是外延最大的概念，所以就不能用属加种差的方法来下定义。但这并不是说对哲学范畴不能下定义。事实上，每一个哲学范畴都有其科学的定义。 上述各种定义都是通过揭示反映在概念中的对象的特质或本质来明确概念的，所以称为本质定义，亦称为真实定义。 另外一种定义叫词语定义。词语定义是表明某一词语表达什么概念的定义，因而是明确概念的一种辅助手段。 词语定义又分为说明的词语定义和规定的词语定义两种 所谓说明的词语定义是对某一词语已被确认的意义加以说明。 例如：有人不了解“乌托邦”这一词语，我们可以引用列宁的话：“乌托邦是一个希腊词语。乌托邦的意思是没有的地方，是空想、虚构和神话”。列宁的话从字源和意义上对“乌托邦”这一词语作了说明，所以是一个说明的词语定义。 规定的词语定义是对某一词语（或符号）规定某种意义。 例如：“五讲四美是指讲道德、讲文明、讲礼貌、讲秩序、讲卫生，做到心灵美、语言美、行为美、环境美” 又如：质能关系式“E = mc^2^”，其中“E”表示能量，“m”表示质量，“c”表示光速 下定义应当遵守的逻辑规则下定义的规则有以下四条： 定义项与被定义项的外延必须重合 也就是说，定义项与被定义项必须在外延上具有全同关系，必须在外延上完全相等。 如果违反这条规则，定义项的外延就会比被定义项的外延多或者少。在这两种情况下，定义都不能正确揭示被定义项的内涵。 如：在“形式逻辑是关于直言推理的科学”这个定义中，“关于直言推理的科学”这个定义项的外延，比“形式逻辑”这个被定义的外延少，因为形式逻辑除了研究直言推理外，还研究概念、命题及一些推理。这种错误称之为“定义过窄”。 反之，如果把形式逻辑定义为“关于正确思维的科学”，这也不正确。因为“关于正确思维的科学”这个定义项的外延比“形式逻辑”中这个被定义项的外延多，“关于正确思维的科学”除了形式逻辑外，还有辩证逻辑等等。这种错误，逻辑上称之为“定义过宽”。 定义项不应该直接或间接地包括被定义项 所谓下定义就是用定义项去明确被定义项。事实上，正是因为被定义项不明确，才需要用定义项去加以明确。因此定义项本身必须是一个明确的概念。若定义项直接或间接包括被定义项，则定义项本身就不明确，因而被定义项也就无法得到明确。 违反这条规则的错误称为“循环定义”的错误。 如：“主观主义着是主观主义地观察和处理问题的人”，这就是一个循环定义，是同语反复。这是定义项直接包括被定义项的例子。 又如：“太阳就是白昼时发光星球(在白昼时发光的星球)”，这也是循环定义。“白昼发光的星球”这个定义间接暗含着“太阳”这个被定义项，因为“白昼”就是太阳照射在地球上的那段时间。 这种循环定义，在逻辑上又称为“无限循环” 定义不应包括含混的概念，不能用隐喻 下定义必须以简洁的语句，确切地揭示被定义项的内涵，而含混的概念和隐喻都不能明确揭示被定义项的内涵。 如：杜林曾给“生命”下过这样一个定义，“生命时通过塑造出来的模式化而进行的新陈代谢。”。这不仅是一个内容错误的定义，而且，从逻辑上说也是一个表述含混、模糊，而让人难明所以的概念，因而也是违反下定义的这条规则的。 又如：“建筑是凝固的音乐”、“儿童是祖国的花朵”，虽然很形象，意义也很深刻，但作为定义使用则不行。因为，它没有明确地、直接地揭示出被定义项的内涵。 定义不应当是否定的 给概念下定义就是为了明确揭示概念的内涵，因此，必须正面揭示它是什么，它具有什么性质。而如果定义是否定的，则只能说明被定义项不是什么。 如：“有机物不是无机物”、“经济基础不是上层建筑”，这些都是否定了它是什么，否定了它具有什么性质，而没有揭示固有的特性和本质。 12我认为，若A和C是明确且成立的概念，且A真包含于C，那么“B是不属于A的C中事物”这个定义是成立的&quot;不属于A的C中事物&quot;这个概念本身作为定义项，对于被定义项是”是“的逻辑关系，是肯定的 以上四条规则是下定义时必须遵守的。 但是，仅靠这些规则对于作出一个正确的定义只是必要条件，而非充要条件。 要作出一个正确的定义，还必须具有有关事物的具体知识。 形式逻辑不能提供关于事物的具体知识，不能告诉我们事物的特点或本质是什么。要获得具体知识，掌握事物的特点或本质，就需要学习相关的科学知识，对事物进行认真的、周密的研究调查。不能认为只要掌握了几条定义规则就足以对概念作出正确的定义。 划分什么是划分要明确概念，除了依靠定义来揭示概念的内涵，揭示这个概念所反映的事物的特性和本质以外，还需要了解概念的外延，了解一个概念究竟反映哪些事物。 划分就是帮助我们明确概念外延，从而明确概念的另一种方法。 要揭示一个概念的外延，往往只需将这个概念所反映的一类事物按照一定性质分为若干个小类就可以了，而不必一个一个列举这类事物所包含的个别对象。 如：按照矛盾性质的不同，将“社会矛盾”分为“人民内部矛盾”和“敌我矛盾” 又如：根据生产方式的不同，将“社会形态”分为“原始社会”、“奴隶社会”、“封建社会”、“资本主义社会”、“社会主义社会与共产主义社会”。 将一个概念所反映的一类事物，按照某个或某些性质分为若干个小类，这就叫划分。划分是明确概念的另一种逻辑方法。 划分是由三个要素组成的。被划分的概念称为划分的母项，划分后所得的概念称为划分的子项，划分时所依据的对象的属性或特征叫做划分的根据。 上述例子中：“社会矛盾”和“社会形态”就是母项；“人民内部矛盾”和“敌我矛盾”，以及“原始社会”、“奴隶社会”、“封建社会”、“资本主义社会”、“社会主义社会与共产主义社会”，分别是划分的子项；前一例以社会矛盾的性质作为划分的根据，后一例以社会生产方式作为划分的根据。 由于客观对象的属性的多样性，因此划分的根据不是唯一的。 划分的方法只适用于普遍概念，而不适用于单独概念。因为划分是在思维中把一个普遍概念所反映的一类对象分成若干个小类的方法，而单独概念所反映的是独一无二的对象，外延已经是明确的。所以，对单独概念没有必要，也不可能进行划分。 1如：“鲁迅”这个概念 注意：划分不同于分解。划分是把一个属概念分成若干个种概念，母项与子项之间具有属种关系。而分解是在思维中把整体的对象分成若干组成部分。而就概念来说，反映整体的概念同反映部分的概念并不具有属种关系，就对象本身来说，部分不具有整体的属性。 如：“地球分为南半球和北半球”，这是分解。因为，“地球”这个概念与“南半球”、“北半球”这两个概念之间不具有属种关系。 划分的种类和方法划分既可以是一次划分，也可以是连续划分。 所谓一次划分就是将一个需要明确其外延的概念只划分一次，划分的结果只有母项和子项两个层次。上面所举的例子都是一次划分。 连续划分就是在第一次划分之后，又根据一定的标准对第一次划分所得到的子项再进行划分，以此类推，一直到满足需求，即明确概念的外延为止。 此外，还有一种特殊的划分：二分法。 二分法是根据对象有无某种属性或特征对概念所作的划分。 例如：根据“战争”属否具有“正义性”，分为“正义战争”和“非正义战争” 二分法所得的结果只有两个项，而且是一对具有*矛盾关系的概念。而具有矛盾关系的两个概念中，往往有一个是负概念。由于负概念只表示对象不具有某种属性，因此就这个负概念本身来说其外延仍然是不明确的。 如：把“全厂职工”分为“党员”和“非党员”，但是“非党员”这个概念，究竟是“团员”还是“一般民众”是不明确的。但我们只需要知道党员所占比例时，用二分法就可以达到明确概念的目的。 划分同科学分类有联系，又有区别。划分是分类的基础，分类是划分得以进行的特殊形式。任何分类都是划分，但不是所有划分都是分类。 两者的区别只要是： 根据不同。可以把事物互相区别开来的一切属性或特征都可以作为划分的根据，但分类必须以对象的本质属性和显著特征为根据。 作用不同。划分既可用于科学分类，也可用于日常实践的需要，而分类主要用于科学研究，使科学知识系统化，因而分类的结果具有长远的意义。 划分的规则 划分应当相应相称 所谓划分应当相应相称是指划分所得的各子项的外延之和应该等于母项的外延。 违反这一条规则就会犯“划分不全”或“多出子项”的逻辑错误。 划分所得的各子项，其外延必须互相排斥 这就是说诸子项之间的关系必须是不相容关系。这是因为，如果诸子项之间是相容的，那就会使一些分子既属于这个子项，又属于另一子项，这就达不到明确概念外延的目的。 违反这一条规则就要犯“子项相容”的逻辑错误。 每次划分必须按同一标准进行 这就是说，每次划分的根据必须同一。这是因为，划分的根据是划分的决定因素。对于同一母项，划分根据不同，所得子项也就必然不同。因此，同一次划分只能采用同一个划分根据。 违反这一条规则就要犯“混淆根据”的逻辑错误。 以上三条规则是相互联系的。如果违反了其中的某一条规则，就有可能同时违反另一条规则。 遵守划分的逻辑规则是明确概念外延的必要条件。要真正对概念作出正确的划分，还必须具备相应的具体科学知识。 简单命题及其推理（上）命题和推理的概述命题和判断在这里，命题是判断的语言表达，即是表达判断的语句。 人们是用概念这种思维形式来反映和表示事物的。 孤立的概念是不能说明事物的。人们为了对事物进行说明，表达一个完整的思想，就必须运用概念作出判断。 判断就是对事物情况有所断定的一种思维形式。 如： 辩证唯物主义和历史唯物主义是无产阶级的世界观。 历史绝不是少数帝王将相的历史。 这些都是判断。尽管断定的具体对象是不同的，但总是对不同的对象作出了相应的断定，即，肯定了某种对象的情况，或，否定了某种对象的情况。 因此，可以说，判断就是思维对象有所肯定或否定的一种思维形式。 这种对思维对象有所肯定或否定，乃是判断的一个基本逻辑特征。 正因为判断总是对思维对象有所断定的，因此，就有一个断定是否正确的问题。 检验判断是否正确的唯一标准是人们的社会实践。如果断定的情况被实践证明是符合客观实际的，那么这个判断就是真的；否则，就是假的。 任何判断都是或真或假的，这是判断的又一逻辑特征。 一个语句，只有当它所表达的是对事物情况有所肯定或否定、并从而是或真或假的思想时，才说这个语句表达了判断，是命题。否则，它没有表达判断，就不是命题。 判断是一种思想，而任何思想都必须以某种物质材料为依托。不管哪一种物质材料，只要它在思想的存在与交流中起着物质承担者的作用，都可以广义地叫做语言。 每一个命题都表达了一个判断，亦即都表达了对客体情况的一个断定，从这个意义上讲，命题就是判断。而由于判断是通过可见可闻的命题表现出来的，所以，判断的内容实际上也就是相应命题所表达的内容，判断的形式也就是相应的命题形式。 因此，以思维形式的逻辑结构为对象的形式逻辑，不是以判断，而是以判断的语言表达，即命题的形式作为直接研究对象。 命题和语句就命题和语言材料的关系而言，虽然任何命题都具有一定的语言形式，但，并非任何语言形式都是命题。 因而，任何语言形式，如果它表达的是判断，亦即如果它是命题，那么它的陈述就一定能区分为真或假，否则就不是命题。因此，就语句而言，只有或真或假的句子才是命题。 在各种语句中，陈述句一般是能分真假的；其他句子，如疑问句、祈使句和感叹句，除了在特定的语言环境中，一般是不能区分真假。 语句中相当于命题的主要是陈述句。 如： 今天多云。 明天会下雨。 以上陈述句都是命题，因为它们都有真假。 作为命题的语句，往往除了表达对于对象情况的某个断定以外，还有各种不同的语法和修饰成分，倾注着表达者个人的情感、意愿、想象等主观感受，这是自然语言特有的光彩。但是，这些语句成分是语言学而不是逻辑学的研究对象。 如：她那款款的、椭圆的、刻满了皱纹并且有点浮肿的脸上露出了笑容。 这句话所要表达的判断无非是： 她的脸上露出了笑容 她笑了 因此，这三个在逻辑学看来，表达了同一个命题。 命题与判断、语句并不完全相同，它们分别属于不同的科学范畴。命题是逻辑学研究的对象，判断和语句分别是认识学和语言学研究的对象。命题实质上是判断内容和语言形式的统一。 命题的种类很多： 简单命题 性质命题 关系命题 复合命题 联言命题 选言命题 假言命题 负命题 等 模态命题 推理推理和概念、判断(命题)一样，也是一种思维形式。 例（1）： 小说是文艺作品； 所以有的文艺作品是小说。 例（2）： 一切文艺作品都是社会作用； 小说是文艺作品； 所以，小说有社会作用。 例（3）： 金是能够导电的； 银是能够导电的； 铜是能够导电的； 铁是能够导电的； 所以，凡金属都是能够导电的。 上述三个都是推理。虽然所表达的具体思想内容各不相同，但是结构上却有一个共同特点：推理都是由命题构成的，命题是推理的组成要素。 由此就可以给推理下这样一个简短的定义：所谓推理就是从一个或几个已知的命题出发推出另一个新命题的思维形式。 在推理中，把由其出发进行推理的已知命题称为前提，把由已知命题所推出的命题称为结论。任何推理，都是由一定前提推理出一定结论的过程，即由一些命题推出另一命题的过程。 一个正确的、能保证结论真实的推理必须具备两个条件： 前提是真实的，即应当是正确反映客观事物情况的真实命题。 推理的前提和结论间的关系是符合思维规律的要求的，也就是说，它们之间的关系不应当是偶然的凑合，而应当是具有一定的必然联系。 形式逻辑所能解决的只是：哪些推理形式是符合逻辑规则的，因而是形式正确的；哪些推理形式是不符合逻辑规则的，因而是形式不正确的。 推理的种类与演绎推理的特征按照划分根据不同，可以将推理进行各种不同的分类。 在本书中，首先根据推理的思维进程方向的不同，把推理分为演绎推理、归纳推理和关系推理。 演绎推理 从一般性知识的前提到特殊性知识的结论的推理。 归纳推理 从特殊性知识的前提到一般性知识的结论的推理 类比推理 从特殊性知识的前提到特殊性知识的结论的推理 把命题和推理结合起来介绍： 演绎推理： 简单命题及其推理 性质命题的直接推理 三段论推理 关系推理 复合命题及其推理 联言推理 选言推理 假言推理 负命题的等值推理 假言选言推理即二难推理 模拟命题及其推理 归纳推理：非必然性推理 完全归纳推理 简单枚举归纳推理 科学归纳推理 类比推理 演绎推理人们在实际思维过程中，常常运用自己过去所获得的关于某种事物的一般性认识，去指导自己认识这类事物中某些新的个别事物，这时所运用的就是演绎推理。 比如，通过对上层建筑进行马克思主义的分析，可以得出某种结论： 123上层建筑都是为经济基础服务的；文学艺术是上层建筑；所以，文学艺术是为经济基础服务的。 这就是一个演绎推理。就是说，演绎推理是由反映一般性知识的前提得出有关特殊性知识的结论的一种推理。 由于演绎推理的前提反映的是一般性知识，而结论反映的是特殊性知识，即起结论的断定的知识范围没有超出前提所断定的知识范围，也就是说，前提的知识蕴含着结论的知识，这就决定了演绎推理的结论具有必然性，因此，演绎推理也可称为必然性推理。 这要在演绎推理的过程中，遵循了正确推理的两个基本要求（前提是真的，前提和结论的联系是合乎逻辑规则的），它的结论就必然是真实的。 性质命题什么是性质命题性质命题是简单命题（即本身不包含其他命题的命题）的一种，它是断定事物具有（或不具有）某种性质的命题。也称之为直言命题。 如： 一切文艺作品都是有倾向性的。 有的国家不是社会主义国家。 这两个命题都是性质命题。前者是断定文艺作品具有“有倾向性的”性质；后者断定有的国家不具有“社会主义国家”的性质。 通过分析这两个命题，尽管它们断定的具体内容各有不同，但都是由下述几个部分组成的： 它们都有一个表示命题对象的概念。如上述两个命题中的“文艺作品”、“国家”。这个在命题中表示命题对象的概念，称之为命题的主项(subject)。逻辑学上通常用大写字母“S”来表示。 它们都有一个表示命题对象所具有或不具有某种性质的概念。如上述两个命题中的“有倾向性的”、“社会主义国家”。这个在命题中表示命题对象所具有或不具有的某种性质的概念，我们称之为命题的谓项(predicate)。逻辑学上通常用大写的英文字母“P”来表示。 它们都有一个用来联系主项与谓项的概念。如上述前一个命题中的“是”，后一个命题中的“不是”。这个联系主、谓项的概念我们就称之为命题的联项，通常也称之为命题的“质”。 在它们的主项前面都有一个表示命题对象数量的概念，我们称之为命题的量项(quantifier)。量项又有两种：一是例（1）中的“一切”，它表示在这个命题中对主项的全部外延作了断定，称之为“全称量项”；另一是例（2）中的“有的”，它表示在这个命题中没有对主项的全部外延作出断定，我们称之为“特称量项”。 在日常讲话以及写作中，表示全称量项的词语还有“所有”、“任何”、“每一”、“凡”等等；表示，特称量项的词语还有“有些”、“有”、“某些”等等。在判断的语言表达中，全称量项的语言标志（如“所有”）可以省略，而特称量项的语言标志不能省略。 据此，性质命题的逻辑结果可以表示为：所有（有的）S是（不是）P。 在这一逻辑结构中，量项“所有（有的）”和联项“是（不是）”是逻辑常项，主项S和谓项P是逻辑变项。 根据逻辑常项的不同，性质命题可以区分为不同的类型。 性质命题的种类按照命题联项的不同，可将性质命题分为肯定命题和否定命题两类。 肯定命题是断定对象具有某种性质的命题 马克思列宁主义是科学真理 雷锋是我们学习的好榜样 否定命题是断定对象不具有某种性质的命题 自然科学不是上层建筑 有的战争不是正义的战争 按性质命题量项的不同，可以把性质命题分为：单称命题、特称命题和全称命题。 单称命题是断定某一个别对象具有（或不具有）某种性质的命题。 北京是中华人民共和国的首都 李时珍不是现代医生 特称命题是断定某类事物中有对象具有（或不具有）某种性质的命题。 有的农民是科学家 有的工人不是共产党 全称命题是断定某类事物中的每一个对象都具有（或不具有）某种性质的命题 所有正义的事业都是不可战胜的 所有被子植物都不是裸子植物 按性质命题的质和量（即逻辑常项）的不同结合，可将性质命题分为下述六种基本形式。 单称肯定命题：是断定某一个别事物具有某种性质的命题。 中华人名共和国是社会主义国家 单称否定命题：是断定某一个别事物不具有某种性质的命题 黄河不是我国最长的河流 全称肯定命题：是断定一类事物的全部对象都不具有某种性质的命题 所有学校都是教育机构 全称否定命题：是判定一类事物的全部对象都不具有某种性质的命题 一切知识都不是先天获得的 特称肯定命题：是断定一类事物中有的对象具有某种性质的命题 有些解放军战士是战斗英雄 特称否定命题：是断定一类事物中有的对象不具有某种性质的命题 有些学校不是师范学校 这里需要注意的是，在特称命题中，特称量项“有些”，在使用时，仅包含“有些……”，并不能推理出“有些不……”。同时特称命题中，特称量项所指的“有些”是一个笼统的数量。它只断定某一类事物中的有的对象具有或者不具有某种性质，并不断定或能够推理出这一类事物未被断定的对象的情况。因此，特称量项“有些”至少表示有一个。 由于单称命题是对某一个别对象的断定，就外延情况说，对该对象作了断定，也就是对某一概念的全部外延作了断定。因此，在一般情况下可以把单称命题当作一种全称命题来对待。 性质命题就可以归结为四种基本形式： 全称肯定命题，逻辑形式为“所有S是P”（通常用大写的英文字母“A”来表示），可缩写为：“SAP” 全称否定命题，逻辑形式为“所有S不是P”（通常用大写的英文字母“E”来表示），可缩写为：“SEP” 特称否定命题，逻辑形式为“有的S是P”（通常用大写的英文字母“I”来表示），可缩写为：“SIP” 特称否定命题，逻辑形式为“有的S不是P”（通常用大写的英文字母“O”来表示），可缩写为：“SOP” 英国数学家凡恩提出一种用来直观地表示概念外延间的各种不同关系的图解，通称“凡恩图解”。 图中的“+”号表示存在，虚线组成的阴影部分表示不存在，两个圆圈之外的长方形表示主、谓项概念的论域（全域）。那么，A、E、I、O的凡恩图表示如下： 如图，运算公式可以表示为：S∩“非P” = 0 ；表示为：既属于S又属于非P的类是不存在的 如图，运算公式可以表示为：S∩P = 0 ；表示为：既属于S又属于P的类是不存在的 如图，运算公式可以表示为：S∩P ≠ 0 ；表示为：既属于S又属于P的类是存在的 如图，运算公式可以表示为：S∩“非P” ≠ 0 ；表示为：既属于S又不属于P的类是存在的 A、E、I、O四种性质命题的项的周延性例（1）： 唯心主义者不是马克思主义者 马克思主义者不是唯心主义者 例（2）： 师范大学都是高等学校 高等学校都是师范大学 因为性质命题的周延性不同，所以例（1）中的两个命题都是正确的，而例（2）中的第二个命题显然是错误的。 什么是性质命题的周延性？所谓性质命题中项的周延性是指在性质命题中，对主项、谓项外延数量的判定情况。如果在一个命题中，它的主项（或谓项）的全部外延都被作了断定，那么这个命题的主项（或谓项）就是周延的。如果没有对它的主项（或谓项）的全部外延作出断定，那么这个命题的主项（或谓项）就是不周延的。 接下来是特称命题的主、谓项的周延情况。 特称肯定命题：周延情况正好和全称否定命题相反，其主、谓项的外延在命题中都未被全部断定，即都不周延。比如：“有的粮食作物是水田作物。” 特称否定命题：周延情况正好与全称肯定命题相反，即它的主项在命题中没有被断定全部外延，而谓项却被断定了全部外延。比如：“有的粮食作物不是水田作物。” 据此，可以归纳为： 全称肯定命题：主项周延，谓项不周延 全称否定命题：主项周延，谓项周延 特称肯定命题：主项不周延，谓项不周延 特称否定命题：主项不周延，谓项周延 主、谓项相同的A、E、I、O四种命题间的真假关系性质命题中的主项S和谓项P实质上反映了类与类的关系。而类与类的关系有：全同关系、真包含关系、真包含于关系、交叉关系和全异关系等五种。 如图： SAP的真假情况是：当S与P反映了类与类之间的全同关系和真包含于关系时，SAP是真的；当S与P反映了类与类之间的真包含关系、交叉关系和全异关系时，SAP是假的。 SEP的真假情况是：当S与P反映了类与类之间的全同全异关系时，SEP是真的；当S与P反映了类与类之间的全同关系、真包含于关系、真包含关系和交叉关系，SEP是假的。 SIP的真假情况是：当S与P反映了类与类之间的全同全异关系、真包含于关系、真包含关系和交叉关系时，SIP是真的；当S与P反映了类与类之间的全异关系时，SIP是假的。 SOP的真假情况是：当S与P反映了类与类之间的真包含关系、交叉关系和全异关系时，SOP是真的；当S与P反映了类与类之间的全同关系和真包含于关系时，SOP是假的。 根据A、E、I、O的真假情况，可以确定同一素材的A、E、I、O之间的真假关系： 反对关系：反对关系指全称肯定命题（A）与全称否定命题（B）的关系 可以由真推假，而不能由假推真 矛盾关系：矛盾关系是指全称肯定命题（A）与特称否定命题（O）、全称否定命题（E）与特称肯定命题（I）的关系。 两者可以由真推假，也可以由假推真 差等关系：差等关系是指全称肯定命题（A）与特称肯定命题（I）、全称否定命题（E）与特称否定命题（O）之间的关系。 如果全称命题真，特称命题必真，如果全称命题假，则特称命题真假不定；如果特称命题假，则全称命题必假，如果特称命题真，全称命题真假不定。总的来说即可同真也可同假。 下反对关系：下反对关系是指特称肯定命题（I）与特称否定命题（O）之间的关系。 总的来说，可以同真，但不能同假。 性质命题的直接推理直接推理时最简单的演绎推理，是以一个命题为前提而推出结论的推理。 运用命题变形法的直接推理换质法改变命题的质（命题的联项）的方法，亦即把肯定命题改变成否定命题，或者把否定命题改变成肯定命题、并将原命题的谓项概念改为其矛盾概念的方法。 A→E 所有新生事物都是有生命力的 所有新生事物都不是没有生命力的 E如果A是真，则E是假，I是真，O是假；如果A是假，则E不定，I不定，O是真A 教条主义者不是马克思主义者 教条主义者是非马克思主义者 I→O 有些战争是正义战争 有些战争不是非正义战争 O→I 有些干部不是称职的 有些干部是称职的 换位法改变命题主词与宾词的位置的方法，亦即把命题主项与谓项的位置加以更换的方法。 换位只是更换主项和谓项的位置，命题的质不变 换位的主项与谓项在原命题中不周延的，换位后也不得周延。 换质位法把换质法和换位法结合起来连续交互运用的命题的变形法。即先进行命题换质、接着进行换位，或者接着换质、再换位，从而由原命题推出新命题。 换质位法不仅可以先换质后换位，也可以先换位后换质。 依据“逻辑方阵”的命题之间的直接关系 如果A是真，则E是假，I是真，O是假；如果A是假，则E不定，I不定，O是真 如果E是真，则A是假，I是假，O是真；如果E是假，则A不定，I真，O是不定 如果I是真，则A不定，E是假，O不定；如果I是假，则A是假，E是真，O是真 如果O是真，则A是假，E不定，I不定；如果O是假，则A是真，E是假，I是真 推理分为如下： 真→真 假→假 真→假 假→真 简单命题及其推理（下）三段论三段论及其结构三段论是演绎推理的一种。 三段论是由三个简单性质命题即直言命题所组成的。前两个命题是推理的前提，后一个命题是推理的结论。并且三段论是由而且仅有三个项（概念）所组成的。 在三段论中，在结论中作为主项的概念称为“小项”，用S来表示；在结论中作为谓项的概念称为“大项”，用P来表示；在前提中出现而在结论中没有出现的概念称为“中项”，用M来表示。在两个前提中，有大项的前提称为“大前提”，有小项的前提称为“小前提”。 由此可以看出，三段论是由两个包含共同项的性质命题作为前提推理出一个性质命题作为结论的推理。 三段论的公理与规则三段论的公理表述如下：一类对象的全部是什么或不是什么，那么这类对象中的部分对象也是什么或不是什么。也就是说，凡是肯定（或否定）了一类对象的全部，也就肯定（或否定）了这类对象的任何部分对象或个别对象。简单来说：凡肯定或否定了全部，也就肯定或否定了部分和个别。 这个公理反映了客观事物中的一般和个别的关系，即属和种的包含关系。是三段论推理的逻辑根据。 三段论的规则概括起来共有五条： 在三段论中，必须有而且只能有三个不同的概念（或“词项”） 三段论的三个概念在其重复出现的两次中，必须反映同一个对象（同一），具有相同的外延。否则就会犯四概念的错误。 如： 我国的大学是分布于全国各地的 华东师范大学是我国的大学 所以，华东师范大学是分布于全国各地的 显然这是错误的，在大前提中，我国的大学是一个集合的概念，包揽众多个体；而小前提中，我国的大学表示一种性质，即“我国的大学之一”的概念，不是集合概念。 中项在前提中必须至少周延一次 大、小项之所以能联系起来，组成新命题，是因为中项在前提中发挥了媒介的作用的结果。因此，如果中项在前提中一次也没有被断定过它的全部外延（周延），那么就无法起到媒介的作用，无法确定大、小项之间的必然的确定的联系，无法得出确定的结论。 大项或小项在前提中不周延，那么在结论中也不得周延 大项不当扩大 小项不当扩大 两个否定前提不能推出结论；前提之一否定，结论也应当是否定；结论是否定的，前提之一必须是否定的 两个特称前提不能得出结论；前提之一是特称的，结论必然是特称的 三段论的格与式如果中项在前提中的位置确定了，那么，大项、小项的位置随之也可以确定。 三段论共有一下四种格： 四个格的规则和有效式列举如下：（带有括号的即不存在——不符合三段论的规则） 大前提必须全称、小前提必须肯定 有效式：AAA、（AAI）、AII、EAE、（EAO）、EIO 两个前提中必须有一个是否定命题、大前提必须是全称命题 有效式：AEE、（AEO）、AOO、EAE、（EAO）、EIO 小前提必须为肯定命题、结论必须为特称命题 有效式：AAI、AII、EAO、EIO、IAI、OAO 如果前提有一个是否定命题，那么大前提必须是全称命题、如果大前提是肯定命题，那么小前提必须是全称命题、如果小前提是肯定命题，那么结论必须是特称命题 有效式：AAI、AEE、IAI、EAO、EIO、（AEO） 复合三段论和省略三段论在日常实际思维中，有时会将几个三段论连续运用，即进行一连串推理，又有时为了思维表达的明了简洁，省略三段论中的某个部分。因此，又有了复合三段论和省略三段论等形式。 复合三段论是由两个或两个以上的三段论构成的特殊的三段论形式，其中前一个三段论的结论组成后一个三段论的前提，形式有以下两种： 前进式的复合三段论：它是以前一个三段论的结论作为后一个三段论的大前提的复合三段论。 在这个推理中，思维的进程是由范围较广的概念逐渐推移到范围较狭的概念，由较一般的知识推进到较特殊性的知识。 公式为： 后退式的复合三段论：它是以前一个三段论的结论作为后一个三段论的小前提的复合三段论。 在这个推理中，思维的进程是由范围较狭的概念逐渐推移到范围较广的概念，由特殊性的知识推进到较一般性的知识，即思维推移的顺序正好和前进式相反。 公式为： 省略三段论它是省略一个前提或结论的三段论。 一般被省略的部分带有不言而喻的性质。 在必要时就必须对省略三段论进行检查。而有效的检查方式就是把省略的部分补上，复原为完整的三段论。 复原的步骤有： 先判明在省略三段论中哪一个命题是结论。 要找出大前提或小前提 依据一定的三段论格式，复原为完整的三段论。 用凡恩图解的方法检验三段论的有效性 关系命题及其推理什么是关系命题关系命题也是一种简单命题，它是断定事物与事物之间关系的命题。 例如： 事实胜于雄辩 5大于3 关系命题的主项有两个或两个以上。 因此有两项关系、三项关系，以此类推 任何关系命题都由三个部分组成，即：关系项、关系者项、量项。 例如：在教育实习中，（实习学校）有的老师表扬了（我们组的）全体同学。 在这里，“表扬了”是关系项，“老师”和“同学”是关系者项。“有的”和“全体”表明关系者项的外延的数量，称“量项” 因此可用公式表示为： 所有（有的）aR所有（有的）b 即：aRb 关系的性质对称关系在两个事物之间，如果一个事物与另一个事物有着某种关系，另一个事物必然与这个事物有着同样的关系，那么这两个事物之间的关系称为对称关系。 即：aRb真，bRa真 “相等关系”、“相同关系”、“对立关系”、“矛盾关系”、“反对关系”、“交叉关系”等等都是对称关系 反对称关系在两个事物之间，如果一个事物与另一个事物有着某种关系，另一个事物必然与这个事物不具有同样的关系，那么这两个事物之间的关系称为反对称关系。 非对称关系在两个事物之间，如果一个事物与另一个事物有着某种关系，另一个事物必然与这个事物可能有着同样的关系，也可能没有，那么这两个事物之间的关系称为非对称关系。 传递关系如果甲事物与乙事物有某种关系，乙事物与丙事物也有某种关系，因此甲事物与丙事物也具有这种关系。 即：aRb真、bRc真，aRc真 反传递关系如果甲事物与乙事物有某种关系，乙事物与丙事物也有某种关系，因此甲事物与丙事物肯定不具有这种关系。 即：aRb真、bRc真，aRc假 非传递关系如果甲事物与乙事物有某种关系，乙事物与丙事物也有某种关系，因此甲事物与丙事物可能具有这种关系，可能不具有。 即：aRb真、bRc真，aRc不定 关系推理直接的关系推理 对称关系推理 根据对称性关系的逻辑性质进行推演的关系推理 反对称性关系推理 根据反对称性关系的逻辑性质进行推演的关系推理 间接的关系推理 传递性关系推理 根据传递性关系的逻辑性质进行推演的关系推理 反传递性关系推理 根据反传递性关系的逻辑性质进行推演的关系推理 混合关系推理推理规则： 混合关系三段论前提中的性质命题必须是肯定的。 媒介项的概念必须至少周延一次。因为在混合关系三段论中，有一个概念在两个前提中都出现。这个概念叫做媒介概念，与三段论的“中项”相类似。因此必须要在前提中至少周延一次 前提中不周延的概念在结论中不得周延 如果作为前提的关系命题是肯定的，则作为结论的关系命题也必须是肯定的；如果作为前提的关系命题是否定的，则作为结论的关系命题也必须是否定的。 如果关系R不是对称的，则在前提中作为关系者前项（或后项）的那个概念在结论中也必须相应地作为关系者前项（或后项）]]></content>
      <categories>
        <category>哲学</category>
        <category>逻辑学</category>
        <category>形式逻辑</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>逻辑学</tag>
      </tags>
  </entry>
</search>
